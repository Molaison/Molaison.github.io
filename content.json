{"meta":{"title":"Molaison's blogs","subtitle":"Per Aspera Ad Astra.","description":"","author":"Molaison","url":"https://github.com/Molaison/Molaison.github.io","root":"/"},"pages":[{"title":"","date":"2022-10-04T13:32:41.000Z","updated":"2023-06-09T09:44:01.646Z","comments":false,"path":"about/index.html","permalink":"https://github.com/Molaison/Molaison.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-10-04T13:33:18.000Z","updated":"2022-10-05T02:58:23.993Z","comments":false,"path":"archives/index.html","permalink":"https://github.com/Molaison/Molaison.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-10-04T13:33:18.000Z","updated":"2023-06-10T05:55:39.577Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/Molaison/Molaison.github.io/categories/index.html","excerpt":"","text":":skill learningproblem solvingbasic knowledge Direction:mathstatscomputer sciencemachine learningdata analysisbiology"},{"title":"Tags","date":"2022-10-04T13:32:41.000Z","updated":"2023-06-09T09:44:48.541Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/Molaison/Molaison.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"蛋白质组学学习笔记","slug":"蛋白质组学学习笔记","date":"2023-06-10T05:53:57.000Z","updated":"2023-06-10T13:48:24.233Z","comments":true,"path":"2023/06/10/蛋白质组学学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2023/06/10/%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%84%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章—蛋白质组学绪论 蛋白质组学的必要性 You can have a protein in the cell when its mRNA is no longer present You can have lots of mRNA without translation of the message to protein No good correlation between mRNA abundance and protein amount in a cell at a given time. 从mRNA水平不一定能预测细胞中相应蛋白质 的水平。 各种mRNA不同的稳定性和不同的翻译效率 蛋白质形成后在稳定性和转换速度上有很大不同。 mRNA水平没有告诉我们相应蛋白质的调节状态，蛋白质的活性和功能常有一些内源翻译后的改变，也会因环境因素而改变 翻译后的多种修饰 蛋白质易受损伤 蛋白质修饰引发蛋白质降解 蛋白质白质表达水平变化极大 基因的转录速度 mRNA的翻译效率 细胞中蛋白质的降解速度 含有不常使用的某些基因倾向于较低水平表达。 针对生命活动 中某一种或某几种蛋白质，难以形成一种整体观， 难以系统透彻地阐释生命活动的基本机制。 基因组与转录组不能取代蛋白质组 基因和蛋白质并不存在严格的线性关系 ORF并不预示一定存在相对应的功能性基因 mRNA水平并非与蛋白质的表达水平对应 翻译后修饰及同工蛋白质(Isoforms)等现象在 基因水平无从表现 蛋白质与蛋白质的相互作用 蛋白质组学与蛋白质化学 后者同一时间内只研究一个蛋白质或多亚基蛋白质复合物。研究工作通常包括完整序列测定、结构测定以及结构控制功能的模型研究 前者需要获得体系内所有蛋白质组分的物理、化学及生 物学参数，如分子量、等电点、表达量等。是在数据库匹配工具帮助下 进行部分序列测定。 蛋白质组学所遇到的挑战 蛋白组学实验中, 往往只能检测到一小部分蛋白质 需要被研究物种的全基因组序列 无法进行大规模蛋白分析 蛋白质易降解 存在很多同工体 没有蛋白质的克隆手段 数据分析 数据存在噪声, 难以分离真实信号, 导致搜索耗费资源 数据库匹配只能给出可信度得分, 需要人为干涉消除假阳性 生物医学瓶颈 只能获得疾病某一时刻的状态, 无法追踪其真实进程 第二章—蛋白质样品的制备蛋白质的提取: 收集样品+破碎+抽提 样品收集: 要控制稳定的材料来源 注意因素 生长时期 组织位置 可溶性 蛋白质组的修饰 材料存储, 上中下三策, 解冻时要越快越好，但避免局部过热 优先直接用, 立即抽提 先以液氮处理后於 -70℃则更佳 在采集后，尽速置於 -20℃ 制备样品 待分析的蛋白样品全部处于溶解状态（包括多数疏水性蛋白） 防止样品在聚焦时发生蛋白的聚集和沉淀 防止发生样品的抽提后化学修饰（如酶性或化学性降解等） 完全去除样品中的核酸和某些干扰蛋白 尽量去除起干扰作用的高丰度或无关蛋白 破碎细胞: 分泌性蛋白质，多散布在材料中，只要研磨均匀，大多可抽取得到。不能研磨过度，以免细胞破得太碎。 液态氮研磨：以研钵打碎材料後研磨成粉。 均质器： 玻璃等材质，较温和的研磨方法。 把材料先切成碎片才容易进行抽取。材料亦可以液氮急速冷却 玻璃球 (glass bead)：以很细的玻璃球混在样本中，用力振荡 酶解 洗涤剂裂解 冻融 渗透裂解 超音波震荡 (ultrasonication)： 以超音波打破细胞，多用在微生物材料。 细胞裂解: 保持低温（冰浴，使用预冷的溶液）,直接加入含强变性剂的裂解液 目标: 必须打断non-covalent protein-protein, protein-DNA, protein-lipid interactions, disrupt S-S bonds 必须阻止蛋白裂解; 避免蛋白水解和降解的措施 保持低温 变性剂 蛋白酶抑制剂 裂解液主要成分 还原剂：用于还原二硫键或防止蛋白质氧化 DTT : 含有自由巯基，带电荷，IEF过程中降低溶解度 (抗氧化剂) TBP: 不带电荷，增强IEF过程中蛋白溶解度，提高一维向二维转移效率 缓冲液 NaN3:除菌 EDTA: 除二价离子 蛋白酶抑制剂 酶：用于消化污染的核酸、糖和脂类 变性剂: 改变溶液离子强度和PH，破坏蛋白质-蛋白质相互作用,破坏蛋白质的二级结构和三级结构。 尿素－硫脲混合物提高样品溶解度, 硫脲水溶性差，只有在浓尿素溶液中可溶性才好 去污剂：有助于溶解膜蛋白质，并有助于膜蛋白质与脂类的分离 SDS：阴离子去污剂，能破坏大多数非共价结合的蛋白; 破坏IEF，所以只用于前期溶解，然后用非离子或两性离子去污剂置换出来。 CHAPS：两性离子去污剂，对膜蛋白溶解有效 非蛋白物质的去除 核酸：超声（防止产生泡沫）和核酸酶（产生假点） 脂与多糖：超速离心（部分损失） 盐：小分子，浓度过高会降低等电聚焦的电压 透析（时间长），凝胶过滤，沉淀重悬法（部分损失） 蛋白质浓缩: 盐析及沉淀法: 蛋白质在水溶液中的溶解度，会因溶液中其它盐类浓度的改变而增減 硫酸铵 (ammonium sulfate) 硫酸铵是中性盐，对蛋白质有相当好的安定作用。 又因为其离子容积较大，吸走水分子的能力也大，成为有效的盐析工具。 有机溶剂沉淀法 因稀释水浓度而降低水活性，则蛋白质上亲水性区域的水合度降低，开始聚集在一起，产生沉淀。 使用有机溶剂, 先把温度降至零度左右，缓缓加到蛋白质溶液中，边搅拌使生沉淀。 以离心收集，以增加回收，并可去除丙酮。蛋白质沉淀可凉干，或在布氏漏斗中以少量乙醚洗过制成粉末； 顺序抽提法 蛋白质的分离纯化 目标: 高活性: 纯化成品与原始粗抽液二者间，其比活性之比值（纯化倍率）越高越好。 高回收率：一般指总活性的回收 高纯度：相对而言，在电泳上看不到其它杂质，即可视为均质。 方便与快速: 经济 要求: 高分辨率 高通量 与质谱的下游分析兼容 可用于分离的性质: 分子大小: 透析（dialysis）和超过滤（加压或离心） 截留分子量 (MWCO): 一种超滤膜对大小已知的分子化合物的截留性质 对于大于截留分子量的分子，通过超滤膜可以有90 / 95 %的截留效率 可以在温和条件下进行,没有大的生物活性的损失 密度梯度（区带）离心 每种蛋白质颗粒沉降到与自身密度相等的介质密度梯度时,即停止不前,最后各种蛋白质在离心管中被分离成各自独立的区带(zone)。 降系数即用来描述此沉降性质；单位为 S (Svedberg unit)。 凝胶过滤法: 不改变样品的生物学性质 又称凝胶层析Gel chromatography、分子筛层析moleculer chromatography或排阻层析ellusion chromatography 。 凝胶条件: 化学惰性 没有或只有极少量的离子交换基团 有足够的机械强度。 凝胶的交联度或孔度（网孔大小）决定了凝胶的分级分离范围: 对大分子物质的分离，多采用琼脂糖。对小分子物质的分离，多采用葡聚糖。 依次洗脱收集后，通过紫外吸收法测定吸收峰。 溶解度 等电点沉淀和PH值控制 当pH = pI，净电荷为零，相邻蛋白质分子之间失去了静电斥力而趋向于聚集沉淀。 不同的蛋白质等电点不同，因此可以通过控制溶液的PH值来沉淀混合物中的某种蛋白成分。 蛋白质可以保持天然构象，能重新溶解于一定浓度的溶液中。 蛋白质的盐析 当溶液中的离子强度达到一定的数值时（盐浓度高达一定数值时），蛋白质的溶解度开始下降，很多蛋白质可以从水溶液中析出，这种现象称为盐析。 有机溶剂分级分离法 有机溶剂的加入改变了介质的介电常数。 这些有机溶剂不仅能引起蛋白质沉淀，而且伴随着变性。 改变温度 一般蛋白质的分级分离操作一般都在0~4oC温度下进行。 0~40oC之间：大部分球状蛋白质的溶解度随温度升高而增加， 电荷 离子交换层析 阳离子交换型树脂: 与树脂中的带电基团相互作用，结果X与Na＋交换（阳离子交换），形成SO3-X 在样品与树脂充分交换后，可通过提高流动相中的盐浓度，或改变流动相的pH，或是同时采用这两种方法进行逐一洗脱 电泳 等电聚焦或称电聚焦: 高分辨率的蛋白质分离技术, 也可用于蛋白质等电点的测定 在具有pH梯度的介质（如浓蔗糖溶液）中, 在外电场作用下, 各种蛋白质将移向并聚焦（停留）在等于其等电点的pH梯度处，并形成一个很窄的区带。 pH梯度制作: 预电泳, 利用缓冲液在电场作用下在凝胶内沿电场方向制造一个pH梯度。 只要它们的pI有0.02（甚至&lt;0.02）pH单位的差别就能分开。 吸附性质 硅胶,氧化铝和活性炭等.主要用来分离非离子、水不溶性化合物 对配体分子的生物学亲和力 利用蛋白质分子对其配体分子特有的识别能力, 即生物学亲和力 经常只需一步处理即可将某种所需蛋白质从复杂混合物中分离出来，纯度相当高。 2D Gel Electrophoresis 过程: 第一向：等电聚焦电泳(SDS破坏电荷条件), 水平方向, PH从大到小 very high voltages (5000V) a long period of time (10h) Presence of a pH gradient pH gradient and electric field strength决定分辨率 IPG等电聚焦优点 pH梯度稳定； 可以生成任意的适当的pH梯度用于不同目的的分离 非线形梯度胶条也可以在特定pH范围使蛋白质分布更均匀 上样量大，可达几十毫克 胶越长, 上样量越大, 分辨率越高; 快速筛选或高丰度蛋白质则用短胶条 重复性好； 强度好，易操作 。 第二向：SDS-PAGE, 垂直方向, 分子量从大到小 modest voltages (200V) shorter period of time (2h) Presence of SDS %acrylamide &amp; electric field strength, 丙烯酰胺含量和电场强度决定分辨率 丙烯酰胺含量越高, 带跑的越近, 尽量让要研究的带在中间位置 效果: 0.0025 pH units精度 能够获得蛋白相对丰度(染色强度) 通过比较能够获得差异蛋白 能够发现新的蛋白 缺点: Cannot handle extremely acidic / basic proteins 超出PH梯度范围的无法处理 Misses some large proteins (&gt;150 kD )&amp; membrane proteins (&gt;30% of all proteins) Only detects high abundance proteins (top 30% typically) 低丰度蛋白的分离: 将总蛋白组分成蛋白质组亚群，再用pH梯度小于2个pH单位的IPG胶进行窄pH范围的分离。 耗时长 第三章—Strategies for protein Identification and Quantification 两大鉴定方法, 爱德曼降解法和质谱 Edman degradation: phenyl isothiocyanate(硫氢酸苯): labeling the N-terminal amino acid 第四章—蛋白质相互作用检测技术第五章—蛋白质生物信息学","categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"}],"tags":[{"name":"biology","slug":"biology","permalink":"https://github.com/Molaison/Molaison.github.io/tags/biology/"}]},{"title":"Linux 文本处理: Regex is all you need!","slug":"Linux-文本处理-Regex-is-all-you-need","date":"2023-06-10T00:41:40.000Z","updated":"2023-06-11T03:18:24.074Z","comments":true,"path":"2023/06/10/Linux-文本处理-Regex-is-all-you-need/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2023/06/10/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-Regex-is-all-you-need/","excerpt":"","text":"什么是正则表达式?正则表达式是一种功能强大、灵活性高的模式匹配工具。它可以进行更复杂的模式匹配，包括字符的重复、选择、分组、反向引用等。在Linux系统使用过程中, 有时会把它和通配符(wildcards)弄混淆. 通配符是一种特殊字符或字符序列，用于在文件名匹配和搜索中代表其他字符或字符序列。通配符可以替代一个或多个字符，以便匹配符合特定模式的文件名或文本字符串。它的形式与正则表达式非常相似, 但逻辑有所不同: 通配符的执行通常由操作系统或特定工具处理，其匹配逻辑可能是基于简单的字符串匹配算法。而正则表达式通常由正则表达式引擎执行，这些引擎会使用更复杂的算法和技术来实现正则表达式的模式匹配，如NFA（非确定有限自动机）或DFA（确定有限自动机）。 以下是一些常见的通配符: “[]”（范围通配符）：用于指定一个字符范围。例如，”[a-z]” 可以匹配任何小写字母字符，”[0-9]” 可以匹配任何数字字符。 “[!]”（否定通配符）：用于排除特定字符。例如，”[!a-z]” 可以匹配任何非小写字母字符，”[!0-9]” 可以匹配任何非数字字符。 “{,}”（集合通配符）：用于指定多个选项。例如，”{cat,dog}” 可以匹配 “cat” 或 “dog”。 集合通配符中的值可以没有,表示为空. 但值之间需用逗号分隔. 且逗号前后不能有空格, 否则拓展失效(因为是直接在bash中运行, 空格是分割符). 不是文件拓展(如*, []等), 不管文件存在与否都拓展成给定值. 对于文件拓展, 当你按下tab时, 它会自动搜索匹配的文件, 并将所有匹配到文件直接原位置展开, 以空格分割. 优先级高,总是先被运行(相较于其他拓展) 可以嵌套拓展 {A{1,2},B{1,2}}: 等于A1 A2 B1 B2 {Start..End}: 与方括号类似,不过用”..”连接 {Start..End..Step}: 指定步长 “()”（分组通配符）：用于将多个字符组合在一起以进行更复杂的匹配。例如，”(ab)+” 可以匹配连续出现的 “ab”。 “*“（星号）：匹配任意字符序列（包括空字符序列）。例如，”*.txt” 可以匹配所有以 “.txt” 结尾的文件名，如 “file.txt”、”document.txt” 等。在正则表达式中这通常表示匹配前面的字符0次或多次. “*/“再加上通配符可以匹配子目录,有几层子目录就写几层 “**/“可以匹配零个或者多个子目录 “?”: 匹配任意单个字符. 使用通配符能够让你在处理多个文件作为输入或是批量查看文件时提高效率, 然而它的重心在于”文件”, 而非专门的”文本”, 这也是为什么不将单列为一节. 要对文本进行处理, 还得看我Regex. 正则表达式有哪些类型?或许你使用过多种语言, 也使用过他们提供的正则表达式工具, 那么你就会发现尽管大体相似, 但似乎每个语言的正则表达式都不尽相同. 通常我们将正则表达式分为三类, BRE, ERE, Perl正则. BRE（Basic Regular Expressions）：BRE是一种比ERE更简单的正则表达式语法，支持较少的元字符和操作符，但仍可以满足基本的模式匹配需求。它主要被诸如grep、sed和awk等POSIX工具使用. ERE（Extended Regular Expressions）：ERE是一种比BRE更强大的正则表达式语法，支持更多的元字符和操作符，如重复次数限定符（+、*、?等）、分组、反向引用等。Perl, Python, PHP中均用到了ERE, 需要注意的是 Python的re模块要使用ERE语法，需要通过指定标志参数（如re.VERBOSE）启用ERE语法。 Perl正则表达式（Perl-regex）：Perl正则表达式是一种高度灵活和功能强大的正则表达式语法，扩展了ERE和BRE的功能，并添加了许多Perl特定的功能和语法。它主要在Perl编程语言中使用，但也在其他编程语言中得到了应用, 如JavaScript：JavaScript的正则表达式语法受到Perl正则表达式的影响，例如，使用(?:…)进行非捕获分组，使用\\1、\\2等进行反向引用。R与python默认使用的就是perl正则表达式语法. 从BRE到ERE再到Perl-regex, 其拥有的高级特性越来越多. 然而直接列出每个正则的语法对我们使用他们没有任何帮助, 故而我接下来会逐点介绍他们的异同之处. 不同Regex语法的相同之处 “[:alnum:]”,”[:alpha:]”,”[:digit:]”,”[:lower:]”,”[:upper:]”,”[:space:]”,”[:blank:]”,”[:graph:]”,”[:print:]”,”[:cntrl:]”,”[:punct:]”,”[:xdigit:]”,”[0-9]”,”[xyz]”,”[\\^xyz]”,”[A-Za-z]”,”[\\^A-Za-z]”,”*“,”\\W”,”\\w”,”\\B”,”\\b”,”\\\\“ 以上字符在各个Regex语法中 用法,功能都一致, 我们也可以将其称之为基础功能. 但需要注意的是形如[:alnum:]的正则符和通配符中的保持一致, 但真正使用时, 我们需要将其用[]再包起来, 而通配符和JavaScript的RegExp对象则不需要. 相同Regex符号的不同之处 单词边界: 除\\b外, 还有两个符号可以匹配边界,\\&lt;,\\&gt;. 其中\\&lt;匹配左边界,\\&gt;匹配右边界. 然而后者仅仅在BRE和ERE中支持, Perl-regex无法使用. (): ()是一个极其重要的符号, 它可以: 1) 将一部分正则表达式视为一个整体，形成一个分组, 从而能对这个分组进行整体操作; 2) 构建子表达式，用于定义复杂的模式。这允许你组合和嵌套多个子表达式，以构建更复杂的模式匹配规则; 3) 捕获匹配的文本。匹配成功后，捕获组会记录匹配的文本，以便后续处理和引用。可以通过编号或命名来引用捕获组, 实现重复出现相同模式的匹配，或者进行替换操作。在ERE和Perl-regex中, 可以直接使用, 但在BRE中需要对括号进行转义(这是BRE使用高级功能的办法, 为了后续说明简单, 若需要进行转义则表述为转义使用). ?: 匹配前面的子表达式 0 次或 1 次（等价于{0,1}). 只有BRE需要转义使用. +: 匹配前面的子表达式 1 次或多次（等价于{1, }). 只有BRE需要转义使用. &#123;n&#125;,&#123;n,&#125;&#123;n,m&#125;: 匹配n次/大于n次/n到m次. BRE需要对&#123;&#125;进行转义(即\\&#123;\\&#125;) .: 匹配除换行符（’\\n’）之外的任意单个字符. 如果要匹配包括“\\n”在内的任何一个字符，请使用：’(^$)|(.)‘ (对于ERE), ‘[.\\n]‘ (对于Perl-regex). 对于BRE, awk中句点能匹配换行符. \\num: 匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用. BRE不支持. 有哪些文本处理工具?文本处理最常用的三个命令行工具被我们称之为”linux三剑客”, 它们是： grep：grep 是 “Global Regular Expression Print” 的缩写，用于在文件中搜索匹配指定模式的文本行。它支持使用正则表达式进行强大的模式匹配，并可以递归搜索子目录。 sed：sed 是 “Stream Editor” 的缩写，它是一个流式文本编辑器，用于对文本进行流式处理。它主要用于在文本流中匹配和替换模式，并支持正则表达式、行选择、行删除、行插入等功能。 awk：awk 是一种强大的文本处理工具，用于从结构化文本文件中提取和操作数据。它支持灵活的模式匹配和处理，具有强大的文本处理能力和内置函数，可以进行数据过滤、转换、计算和格式化等操作。 好像讲了, 又好像什么都没讲, 只知道用处不知道用法学了等于没学. 这三个命令各有所长, 接下来将逐一介绍. Grep命令: 控制匹配格式: -i（--ignore-case）： 忽略大小写进行匹配。 例如：grep -i &quot;hello&quot; file.txt -e pattern（--regexp=pattern）：指定一个模式进行搜索匹配。 例如：grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; file.txt -v（--invert-match）： 反转匹配，只显示不匹配的行。 例如：grep -v &quot;error&quot; file.txt -w（--word-regexp）：仅匹配完整的单词，而不是部分匹配。 例如：grep -w &quot;word&quot; file.txt -x（--line-regexp）：只匹配整行，而不是行中的部分内容。 例如：grep -x &quot;exact line&quot; file.txt 事实上等同于^pattern$ -w (--word-regexp) : 只显示全字符合的列。 -f file（--file=file）：从指定文件中读取模式，逐行搜索匹配。 例如：grep -f patterns.txt file.txt 选择不同的正则表达式语法: -E（--extended-regexp）：使用扩展的正则表达式语法ERE。 例如：grep -E &quot;pattern&quot; file.txt 等同于egrep &quot;pattern&quot; file.txe -P（--perl-regexp）：使用 Perl 兼容的正则表达式语法Perl-regex。 例如：grep -P &quot;pattern&quot; file.txt -F（--fixed-strings）：按照字符串字面值进行匹配，而不是正则表达式。 例如：grep -F &quot;string&quot; file.txt -G (--basic-regexp) : 默认情况下，grep 命令使用基本正则表达式进行匹配，因此可以省略 -G 参数。 控制匹配的文件 -x（--exclude=file）：指定要排除的文件模式。 例如：grep &quot;pattern&quot; --exclude=&quot;*.log&quot; directory 其他用法同下; --include=file：指定要包含的文件模式。 例如：grep &quot;pattern&quot; --include=&quot;*.txt&quot; directory 多个文件：使用逗号分隔多个要包含的文件模式。例如：--include=*.txt,*.log。 通配符模式：使用通配符模式指定要包含的文件。例如：--include=prefix*。 文件路径：使用相对或绝对文件路径指定要包含的文件。例如：--include=/path/to/included/file.txt。 -r 参数同样会递归搜索指定目录及其所有子目录中的文件内容，但不会包括符号链接所指向的目录。当遇到符号链接时，它会忽略链接所指向的目录，而不会进一步递归搜索。 例如：grep -r &quot;pattern&quot; directory -R 参数会递归搜索指定目录及其所有子目录中的文件内容，包括符号链接所指向的目录。它会遍历整个目录树来搜索匹配的文件内容。 --exclude-dir=dir：排除指定目录的搜索。该选项只适用于递归搜索，并且排除的目录将被完全忽略，不会搜索其下的任何文件或子目录。 例如：grep &quot;pattern&quot; --exclude-dir=docs directory 单个目录：指定要排除的单个目录的名称。例如：--exclude-dir=logs。 多个目录：使用逗号分隔多个要排除的目录名称。例如：--exclude-dir=logs,cache。 通配符模式：使用通配符模式指定要排除的目录。例如：--exclude-dir=docs*。 目录路径：使用相对或绝对目录路径指定要排除的目录。例如：--exclude-dir=/path/to/excluded。 -l（--files-with-matches）：只显示包含匹配的文件名，而不显示匹配的具体行。 例如：grep -l &quot;pattern&quot; file1.txt file2.txt -L（--files-without-match）：只显示不包含匹配的文件名。 例如：grep -L &quot;pattern&quot; file1.txt file2.txt -Z（--null）：使用 NUL 字符作为文件名分隔符。NUL 字符是 ASCII 字符集中的控制字符，表示空字符或空值。它的 ASCII 值为 0（十进制）。在 Unix-like 系统中，NUL 字符通常用于表示字符串的结尾或作为文件名分隔符。grep 命令由此能够处理包含特殊字符或空格的文件名列表。Xargs命令也可以使用-0参数达到同样效果. 例如：grep -lz &quot;pattern&quot; file1.txt file2.txt12345678# 测试文件：echo &quot;aaa&quot; &gt; file1echo &quot;bbb&quot; &gt; file2echo &quot;aaa&quot; &gt; file3grep &quot;aaa&quot; file* -lZ | xargs -0 rm# 执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。 控制匹配输出格式 -n（--line-number）：显示匹配行的行号。 例如：grep -n &quot;pattern&quot; file.txt -c（--count）：只显示匹配的行数。 例如：grep -c &quot;pattern&quot; file.txt -q（--quiet）：静默模式，不输出任何结果。 例如：grep -q &quot;pattern&quot; file.txt -s（--no-messages）：静默模式，不显示错误信息。 例如：grep -s &quot;pattern&quot; file.txt -o (--only-matching): 只显示匹配PATTERN 部分。 匹配 = 定位, 以下系数控制输出更多行, 譬如匹配一个ID, 输出它下面N行的数据. -A num（--after-context=num）：显示匹配行之后的 num 行内容。 例如：grep -A 3 &quot;pattern&quot; file.txt -B num（--before-context=num）：显示匹配行之前的 num 行内容。 例如：grep -B 2 &quot;pattern&quot; file.txt -C num（--context=num）：显示匹配行之前和之后的 num 行内容。 例如：grep -C 2 &quot;pattern&quot; file.txt --group-separator=SEP: 将匹配的组(也即匹配的行以及要输出的上下文)用分隔符分开 -m num（--max-count=num）：设置匹配的最大行数。 例如：grep -m 5 &quot;pattern&quot; file.txt Sed命令:1sed [选项] [脚本命令] 文件名 参数解析 配置命令输出格式 -n,--quiet, --silent：禁止自动打印模式空间的内容。默认情况下，sed会自动打印模式空间的内容到标准输出。使用-n参数后，只有通过sed的打印命令（例如p）才会输出内容。 -i：直接在源文件中进行修改。默认情况下，sed会将修改后的结果输出到标准输出。使用-i参数后，sed会直接在源文件中进行修改，并将结果写入源文件。例如：sed -i &#39;s/pattern/replacement/&#39; file.txt。 与grep命令中含义一致的参数: -e：允许在命令行上指定要执行的sed脚本。可以使用多个-e参数来指定多个命令。例如：sed -e &#39;command1&#39; -e &#39;command2&#39; file.txt。与Grep命令中含义一致. -f：从指定的文件中读取sed脚本。脚本文件中可以包含多个sed命令，每个命令占据一行。例如：sed -f script.sed file.txt。和Grep命令中含义一致. -r,-E,--regexp-extended：启用扩展的正则表达式语法。默认情况下，sed使用基本的正则表达式语法。使用-r参数后，可以使用更多的元字符和语法结构。-E与Grep命令中含义一致. -z：将输入文件视为以null字符分隔的记录。默认情况下，sed将输入文件视为以换行符分隔的记录。使用-z参数后，sed将输入文件视为以null字符（\\0）分隔的记录。与Grep命令中含义一致. 处理方式控制 -l N,--line-length=N: 在sed命令中，-l参数（或—line-length）用于指定输出行的最大长度。它限制了sed命令所产生的输出行的字符数量。当输出行的长度超过指定的最大长度时，sed命令将会对输出行进行截断，只保留指定长度的部分。这可以用来控制输出的格式，使得输出行在显示或处理上更易于处理。 -s：在处理多个文件时，将每个文件视为独立的流。默认情况下，sed会将所有文件视为一个连续的流，并在所有文件上执行给定的命令。使用-s参数后，sed会将每个文件视为独立的流，并在每个文件上分别执行命令。file-wise形式执行命令. 不那么常用的参数(毕竟核心是命令): -b 或 --binary：以二进制模式打开文件。默认情况下，sed将文件视为文本文件并以文本模式打开。使用-b参数后，sed将以二进制模式打开文件，可以用于处理二进制文件。 -u 或 --unbuffered：禁用输出缓冲。默认情况下，sed会在打印输出之前对其进行缓冲。使用-u参数后，禁用输出缓冲，使得输出立即可见。 -y：执行逐字符替换。默认情况下，sed会按照给定的替换规则对文本进行模式匹配和替换。使用-y参数后，sed将执行逐字符的替换，将一个字符映射为另一个字符。 -h 或 --no-default-hold：禁用默认的模式保持空间。默认情况下，sed使用一个特殊的模式保持空间来存储处理过的行。使用-h参数后，禁用默认的模式保持空间，可以使用自定义的保持空间。 -H 或 --default-hold：启用默认的模式保持空间。如果在使用-h参数后想恢复默认的模式保持空间，可以使用-H参数。 command解析sed命令语法格式为[addr]X[options], [addr]是可选参数, 控制X(单个字符,决定执行什么命令)处理的对象, 若[addr]为空则默认全部. 而[options]则是对于X而言的, 只有部分命令用得上. [addr]可以是一个数值(sed &#39;35d&#39; input.txt), 正则表达式(sed &#39;/^foo/q42&#39; input.txt, 表示当该行找到时, 会以42状态码退出命令), 或是一个范围(sed &#39;30,35d&#39; input.txt). 执行多个命令有多种不同格式. 你可以使用;隔开, 命令会先后执行, 首先，/^foo/d这个命令会匹配以”foo”开头的行，并删除这些匹配到的行。这是一个针对行的操作。然后，s/hello/world/命令会在每一行中将第一个出现的”hello”替换为”world”。All characters following a,c,i commands are taken as the text to append/change/insert, 所以不能使用;分隔, 必须是-e参数或添加换行. r,R,w,W同理, 不过这次是文件名被破坏.1sed &#x27;/^foo/d ; s/hello/world/&#x27; input.txt &gt; output.txt你也可以使用-e参数指定不同命令:1sed -e &#x27;/^foo/d&#x27; -e &#x27;s/hello/world/&#x27; input.txt &gt; output.txt你甚至可以直接指定含有命令的文件:123echo &#x27;/^foo/d&#x27; &gt; script.sedecho &#x27;s/hello/world/&#x27; &gt;&gt; script.sedsed -f script.sed input.txt &gt; output.txt括号 &#123;&#125; 用于分组多个命令，以便对一组命令进行相同的操作或逻辑控制。大括号 &#123;&#125; 内可以包含多个sed命令，每个命令之间使用分号 ; 分隔。当sed处理到大括号时，它会将大括号内的命令作为一个单独的组，并按照顺序逐个执行其中的命令。在匹配特定模式时执行一系列操作.12$ sed -e &#x27;/pattern/&#123;s/foo/bar/; s/baz/qux/&#125;&#x27; input.txt# 以下单独解释下各个命令的作用. 常用命令a\\ (\\n) text,a text: 在匹配处之后添加新行.c\\ (\\n) text,c text: Replace (change) lines with text (alternative syntax).d: Delete the pattern space; immediately start next cycle.D: 用于删除模式空间中的第一个换行符及其之前的内容，并将剩余的内容重新加载到模式空间中，然后继续执行后续的sed命令。s/regexp/replacement/[flags]: (substitute) Match the regular-expression against the content of the pattern space. If found, replace matched string with replacement.i\\ (a \\n) text,i text: insert text before a line (alternative syntax).e command: s/foo/echo bar/e命令将会将匹配到的”foo”替换为”echo bar”，然后执行这个替换后的内容作为Shell命令。该Shell命令的输出结果会取代原始匹配的文本。需要注意的是，e命令只能在替换命令中使用，并且仅在替换命令的右侧才会生效。它不能用于其他sed命令或正则表达式的匹配部分。1$ sed &#x27;s/foo/echo bar/e&#x27; input.txt 模式空间与保持空间 模式空间是sed命令处理的主要工作区域，它会逐行地读取输入文本并进行处理。每次处理一行时，当前行的内容会存储在模式空间中。sed命令会对模式空间中的数据进行操作，例如匹配、替换、删除等操作。完成对当前行的处理后，模式空间会被清空，然后继续处理下一行。保持空间是另一个临时存储区域，它可以用来存储额外的数据。保持空间在整个处理过程中可以持久存在，不会像模式空间那样在处理完一行后被清空。你可以使用sed命令的特定命令（如g、G、h、H等）来在模式空间和保持空间之间进行数据交换。这样可以在不同的行之间传递数据，或者将数据保存起来供后续处理使用。 g: 将保持空间中的内容复制到模式空间中。它会用保持空间的内容替换当前模式空间的内容。G: 将保持空间中的内容追加到模式空间中的行后。在模式空间中的当前行和保持空间中的内容之间会添加一个换行符。h: 将模式空间中的内容复制到保持空间中。它会用模式空间的内容替换当前保持空间的内容。H: 将模式空间中的内容追加到保持空间中的行后。在保持空间中的当前行和模式空间中的内容之间会添加一个换行符。x:交换两空间的内容;z:(zap) This command empties the content of pattern space.n: 当sed处理文件，遇到n命令时，它会将当前模式空间的内容输出，然后读取下一行，替换当前模式空间的内容。在下面的这个案例中, 每一次执行, 首先读取一行到模式空间并print, 随后n命令直接读取新的一行替换掉当前行, 后续命令会对该行进行处理(这里没有后续命令了), 同时由于该行已经被读取出来了, 第二次直接读取了第三行, 所以从结果上看类似与跳过了第二,四行.1234567891011sed -n &#x27;1,5 &#123;p; n&#125;&#x27; /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:2:2:bin:/bin:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncsed -n &#x27;1,5 p&#x27; /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncN: 用于将下一行添加(而非替换)到模式空间中，并在两行之间插入一个换行符。这允许对多行文本进行操作。一旦多行文本位于模式空间中，可以使用其他sed命令对其进行处理，如正则表达式匹配、替换或删除等操作。1$ sed -n &#x27;N; s/foo\\nbar/baz/&#x27; input.txt 输出当前文本信息p: Print the pattern space(单行或多行). 如果模式空间中有多行内容，p命令会将它们全部打印出来。P: Print the pattern space, up to the first \\. P命令用于将模式空间中的当前行的第一行部分复制到标准输出，并且只打印复制的部分。它不会打印整个匹配到的行。l: 显示当前处理的文本行，并在行的末尾显示其非打印字符的编码。F: 输出当前正在处理的文件的名称, 并附上一个换行符.=: Print the current input line number (with a trailing newline). 标签跳转b label:当sed解析到b命令时，它会立即跳转到指定的标签处，继续执行后续的命令。这意味着b命令可以用于跳过当前处理行中的后续命令，直接转到指定位置继续处理下一行。123456789$ sed &#x27;/pattern/ &#123; s/foo/bar/ b end s/hello/world/ :end&#125;&#x27; input.txt#如果某一行匹配了`/pattern/`模式，那么sed将执行该块内的命令。在#这个块内，首先执行`s/foo/bar/`命令替换第一个出现的&quot;foo&quot;为&quot;bar&quot;。#然后，`b end`命令会跳转到标签`:end`处，继续处理下一行，跳过了`s/hello/world/`命令。t label: sed命令在执行过程中，会逐行处理输入文本。当遇到t命令时，它会检查最近执行的s（替换）命令是否成功（即是否有发生替换）。如果有替换发生，t命令将会将控制转移到指定的标签处继续执行后续命令。1234$ sed &#x27;s/foo/bar/ ; t label ; s/123/456/&#x27; input.txt#`s/foo/bar/`命令会尝试将每一行中的&quot;foo&quot;替换为&quot;bar&quot;。#如果发生了替换，`t label`命令将跳转到标签`label`处继续执行后续命令，即`s/123/456/`命令。#如果没有发生替换，`t label`命令不会执行跳转，直接执行下一个命令。T label: 含义与t相反, 当不成功时进行跳转.#: A comment, until the next newline.: label: Specify the location of label for branch commands (b, t, T). 其他q[exit-code]: (quit) Exit sed without processing any more commands or input.Q[exit-code]:(quit) This command is the same as q, but will not print the contents of pattern space. Like q, it provides the ability to return an exit code to the caller.w filename:用于将匹配到的行写入指定的文件。语法为：w filename，其中filename是要写入的文件名。例如，/pattern/w output.txt会将匹配到模式pattern的行写入到output.txt文件中。如果output.txt文件已存在，行将被追加到文件末尾；如果文件不存在，将创建新文件。W filename:与w命令类似，但它只写入匹配到模式的行中的第一行，并且在写入后删除该行。语法为：W filename，其中filename是要写入的文件名。例如，/pattern/W output.txt会将匹配到模式pattern的行中的第一行写入到output.txt文件中，并在写入后将该行从模式空间中删除。r filename:Reads file filename.R filename:Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read. 如何选择行? 直接通过行号: number: 选择对应行 $: 选择最后一行 first~step: 从first开始, 以step为步长选择行. 通过正则表达式: 默认使用BRE(Grep也是), 除非指定-E,-r参数. /regexp/: 注意当使用//即空的正则时, 会使用上一个正则, 不论是;,-e,-f方法指定的. \\%regexp%: %可以是任何其他单字符. 主要用在需要匹配路径的情况, 毕竟一个个转义也太麻烦了. /regexp/I,\\%regexp%I: I修饰符的作用主要是令匹配大小写不敏感. 注意i是插入命令, 并非大小写敏感开关! /regexp/M, \\%regexp%M: M意为multiple, 开启多行模式, ^$只会匹配空行, 而非buffer的起点和终点(\\` 和\\‘, 注意一个是行内代码符号`, 一个是单引号). 通过范围: num1,num2: 匹配 [num1, num2]行, 包含num1,2. 注意若num2\\&lt;num1, 则","categories":[{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"Linux /etc/ 目录详解","slug":"Linux-etc-目录详解","date":"2023-06-09T10:13:10.000Z","updated":"2023-06-10T05:55:39.582Z","comments":true,"path":"2023/06/09/Linux-etc-目录详解/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2023/06/09/Linux-etc-%E7%9B%AE%E5%BD%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"/etc/ 文件夹的作用是什么?根路径下各个文件都有其特殊的用处, 譬如/bin 目录包含了系统启动和基本操作所需的核心命令（二进制文件）;/boot 目录包含了启动系统所需的文件，如内核映像文件和引导加载程序（bootloader）配置文件;/dev 目录是设备文件的存放位置等. 而/etc则是包含了系统的配置文件,大多数系统级别的配置文件和脚本都存放在此处，例如 /etc/passwd（存储用户信息）、/etc/hosts（存储主机名和 IP 地址的映射）等。了解其下各个子文件夹的内容对我们了解Linux的工作特性大有帮助, 许多我们常用的命令只是将配置文件的信息打印出来而已. /etc/ 子文件(夹)类型/etc文件夹中并不是只有文本文件, 还有文件夹, 比如/etc/cron.d/. 在Linux系统中，”.d” 的后缀通常表示一个目录（directory）。这种命名约定用于指示特定目录中包含了相关配置文件或脚本的集合。在特定的上下文中，”.d” 目录通常用于允许系统管理员或应用程序添加、修改或删除与特定功能相关的配置文件，而无需修改主配置文件。这种设计模式提供了一种灵活的方式来管理和组织配置。 除了.conf后缀外, 还有一类特殊的后缀-. 在Linux系统中，”/etc/passwd-“ 文件的 “-“ 后缀通常表示一个备份文件。这种命名约定用于表示原始文件的备份副本，通常在对原始文件进行修改或更新之前创建。对于 “/etc/passwd-“ 文件而言，它是 “/etc/passwd” 文件的备份副本。”/etc/passwd” 是一个重要的系统文件，它包含了关于系统中用户账户的基本信息，如用户名、用户ID、用户主目录等。 常见的文件有哪些? 用户相关信息: 基本子文件夹: /etc/passwd： 这个文件包含了系统上所有用户的基本信息，如用户名、用户ID、默认shell、主目录等。它用于验证用户登录和识别用户。 /etc/group： 这个文件包含了系统上所有用户组的信息，如组名、组ID和组成员。它用于管理用户和组的关系，控制访问权限等。 /etc/shadow： 这个文件存储了用户的加密密码和密码过期信息。它通常只对管理员可见，用于保护用户密码的安全性。 /etc/default/useradd : 新增用户的默认设置。 与用户相关的命令有: useradd 命令用于创建新的用户账户。它会读取 /etc/default/useradd 文件中的默认设置，并将新用户的信息添加到 /etc/passwd、/etc/shadow 和 /etc/group 文件中。 passwd 命令用于更改用户密码。它会修改 /etc/shadow 文件中的密码字段，将新密码加密后保存。 usermod 命令用于修改现有用户账户的属性。它可以修改 /etc/passwd 和 /etc/shadow 中的相关字段，如用户名、用户组、用户主目录等。 userdel 命令用于删除用户账户。它会从 /etc/passwd、/etc/shadow 和 /etc/group 文件中删除与用户相关的信息。 id 命令用于显示用户的标识号（UID）和所属的组标识号（GID）。它会读取 /etc/passwd 和 /etc/group 文件来获取用户和组的相关信息。 who 命令用于显示当前登录系统的用户信息。它读取 /var/run/utmp 文件来获取已登录用户的信息。 网络配置信息: 手动配置网络: /etc/hosts： 这个文件用于配置主机名与IP地址的映射关系。你可以在这里手动添加或编辑条目，以便在本地系统上解析主机名。 /etc/resolv.conf： 这个文件包含了用于解析域名的DNS服务器的配置信息。你可以在这里指定DNS服务器的IP地址、搜索域等。 /etc/network/interfaces 或 /etc/sysconfig/network-scripts/ifcfg-*： 这些文件用于配置网络接口的设置，如IP地址、子网掩码、网关等。具体文件名称可能因不同的Linux发行版而有所不同。 与用户信息相关的不同, 网络配置相关配置文件多是用于手动配置. 下面列出的命令通过读取内核的网络状态信息，不涉及具体的文件。 ip： ip 命令是一个强大的网络工具，用于配置和显示网络接口、路由表、网络命名空间等。它可以读取和修改网络接口的各种属性，如 IP 地址、子网掩码、网关等。 netstat： netstat 命令用于显示网络状态和连接信息。它可以显示当前活动的网络连接、监听的端口以及路由表等信息。 route： route 命令用于配置和显示网络路由表。它可以添加、删除和修改路由表项，指定网络流量的传输路径。 iptables： iptables 命令是一个强大的防火墙工具，用于配置和管理网络包的过滤和转发规则。它可以读取和修改防火墙规则，控制网络流量的传输。 为什么没有ifconfig? 因为ip命令要强大的多, 故而最新版Ubuntu甚至不默认安装该命令了. 硬盘配置信息: /etc/fstab： /etc/fstab 文件是用于存储文件系统挂载信息的配置文件。它包含了挂载点、文件系统类型、设备文件和挂载选项等信息。通过编辑该文件，你可以配置系统启动时自动挂载文件系统的行为。 相关命令: fdisk： fdisk 命令用于分区硬盘。它可以读取和修改硬盘的分区表，允许你创建、删除、调整分区等操作。fdisk 命令直接操作硬盘设备文件，例如 /dev/sda。 parted： parted 命令也用于分区硬盘，但提供了更高级的分区操作功能。它可以读取和修改硬盘的分区表，支持更多的分区类型和功能。parted 命令直接操作硬盘设备文件，例如 /dev/sda。 mkfs： mkfs 命令用于创建文件系统。它可以在指定的分区上创建不同类型的文件系统，如 ext4、NTFS 等。mkfs 命令直接操作分区设备文件，例如 /dev/sda1。 mount： mount 命令用于挂载文件系统。它可以将指定的文件系统挂载到指定的挂载点上，使得文件系统中的内容可访问。mount 命令会修改 /etc/fstab 文件以记录挂载信息。 umount： umount 命令用于卸载文件系统。它可以卸载已经挂载的文件系统，使得挂载点上的内容不再可访问。umount 命令会修改 /etc/fstab 文件以移除挂载信息。 fsck： fsck (file system check)命令用于检查和修复文件系统。它可以读取和修改文件系统的元数据，检测和修复文件系统中的错误。fsck 命令直接操作文件系统设备文件，例如 /dev/sda1。 工作逻辑: 分区操作：fdisk 和 parted 命令直接操作硬盘的分区表，可以读取和修改分区信息，包括创建、删除、调整分区等。 文件系统操作：mkfs 命令用于创建文件系统，可以在指定的分区上创建不同类型的文件系统。mount 命令用于挂载文件系统，将文件系统挂载到指定的挂载点上。 /etc/apt 目录相关的重要文件和目录： /etc/apt/sources.list 或 /etc/apt/sources.list.d/ 目录：这些文件用于定义软件包源（软件仓库）。sources.list 是主要的源配置文件，而 sources.list.d/ 目录包含了其他源配置文件，通常以 .list 扩展名结尾。这些文件指定了系统从哪些源获取软件包，包括官方源、第三方源以及其他自定义源。 /etc/apt/apt.conf 或 /etc/apt/apt.conf.d/ 目录：这些文件是APT的配置文件。你可以在这里设置各种选项，如代理设置、下载限速等。apt.conf 是主要的配置文件，而 apt.conf.d/ 目录包含了其他配置文件，通常以 .conf 扩展名结尾。 /etc/apt/preferences：该文件是一个可选的配置文件，用于定义软件包的优先级。你可以使用它来指定系统如何处理软件包版本冲突或优先选择特定版本。 /etc/apt/trusted.gpg 和 /etc/apt/trusted.gpg.d/ 目录：这些文件和目录包含了用于验证软件包签名的 GPG 密钥。APT使用这些密钥来确保下载的软件包是经过验证和信任的。 /etc/crontab 是一个系统级别的crontab文件，用于配置在Linux系统上定期运行的任务。Cron是一个用于执行预定时间间隔任务的守护进程。在 /etc/crontab 文件中，你可以定义系统范围的定时任务。这些任务可以是系统维护、备份、日志清理、定期脚本等等。 m：分钟（0-59） h：小时（0-23） dom：一个月的某一天（1-31）, 即 day of a month mon：月份（1-12） dow：星期几（0-7，其中0和7都代表星期日）,即 day of a week user：执行任务的用户 command：要运行的命令或脚本 run-parts命令表示运行路径下所有脚本. 上述文件表明: 每小时的第17分钟，系统会运行 /etc/cron.hourly 目录中的脚本；每天的早上6:25，系统会运行 /etc/cron.daily 目录中的脚本；每周的星期天早上6:47，系统会运行 /etc/cron.weekly 目录中的脚本；每月的第一天早上6:52，系统会运行 /etc/cron.monthly 目录中的脚本。 当我们要增加全局性的计划任务时，一种方式是直接修改/etc/crontab。但是，一般不建议这样做，/etc/cron.d目录就是为了解决这种问题而创建的。 /etc/cron.d 是Linux系统中存放 Cron 任务的目录。Cron 是一个用于在预定时间或间隔上运行指定命令或脚本的任务调度程序。在 /etc/cron.d 目录中，你可以找到一系列以文件名结尾为 .conf 的配置文件，这些文件包含了 Cron 任务的定义。 /etc/ssh/sshd_config： 这个文件包含了SSH服务器的配置选项，如端口号、允许的用户、登录选项等。它用于控制SSH连接的行为。 /etc/alternatives 是一个特殊的目录，它在Linux系统中扮演着重要的角色。它实际上是一组符号链接（symbolic link）的集合，用于提供系统中不同可替代项之间的选择。 在Linux系统中，有一些命令或路径有多个可选项，比如不同的版本或不同的实现方式。正是 /etc/alternatives 目录中的符号链接允许你在这些可选项之间进行切换。每个符号链接指向一个真正的可执行文件、路径或其他资源。通过更改这些符号链接，你可以更改系统中默认使用的可选项。 update-alternatives --config &lt;link&gt;用于管理这些链接. 替换 &lt;link&gt; 为你要管理的符号链接名，比如 vi。显示一个列表，其中列出了可用的选项及其对应的编号、名称和路径。 /etc/sysctl.conf 是一个重要的配置文件，用于管理Linux系统内核参数。内核参数是控制和调整操作系统内核行为的设置。 在 /etc/sysctl.conf 文件中，你可以定义和修改各种内核参数的值。这些参数影响着系统的性能、安全性和行为。通过修改这些参数，你可以优化系统的性能、改变网络设置、提高安全性等。 以下是一些 /etc/sysctl.conf 文件的示例设置：","categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"机器学习杂记","slug":"机器学习杂记","date":"2022-11-27T07:45:26.000Z","updated":"2023-06-10T05:55:39.577Z","comments":true,"path":"2022/11/27/机器学习杂记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2022/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0/","excerpt":"","text":"线性可分SVM: 主要参考这样一步一步推导支持向量机，谁还看不懂？,及【机器学习】支持向量机 SVM 优化公式: D = \\frac{||\\omega^Tx+b||}{||\\omega||} $\\omega$和$b$为超平面有关参数; 定义$\\omega^Tx+b\\geq 0$的为正样本(y=1), 反之($\\leq$)则为负样本(y=-1) 则有: \\frac{y_i\\times(\\omega^Tx+b)}{||w||\\times D}\\geq 1 仅当样本点为支持向量时, 等于$||w||\\times D$, 此时的D为超平面的间隔, 也是我们想要最大化的对象; 故而所求变为: D = \\max\\frac{(\\omega^Tx_{sup}+b)\\times y}{||w||} $x_{sup}$表明它为支持向量, 总是在超平面上, 不影响最优化结果, 式子变为: D = \\max\\frac{1}{||w||} 等价于: D = \\min||w|| 为方便计算,将式子化为: D = \\min\\frac{1}{2}||w||^2 约束条件为: (\\omega^Tx+b)\\times y\\geq 1 \\Rightarrow g_i(\\omega,b)=1-y_i(\\omega^Tx_i+b)\\leq 0 KKT条件: \\frac{\\partial L}{\\partial w_ {i}} = \\frac {\\partial f}{\\partial w_ {i}}+\\sum^{n}_{j=1} \\lambda _ {j}\\frac {\\partial g_ {j}}{\\partial w_ {i}} =0\\\\ \\lambda_ig_ {i} (w)=0\\\\ g_{i} (w) \\leqslant 0\\\\\\lambda_i>0 引入松弛变量: g_i(w)\\leq 0\\Rightarrow h_i(w)=g_i(w)+a_i^2=0 \\Rightarrow L(w,\\lambda,a) = f(w)+\\sum_{i=1}^n\\lambda_i\\times[g_i(w)+a_i^2] = f(w)+\\sum_{i=1}^n\\lambda_i\\times g_i(w)+\\sum_{i=1}^n\\lambda_i\\times a_i^2 因为 \\lambda_i\\geq 0\\\\\\Rightarrow \\sum\\lambda\\times a_i^2\\geq0 故原式变为 L(w,b)= f(w)+\\sum_{i=1}^n\\lambda_i\\times g_i(w) 当 $f(w)$ 取到最小值 $p$ 时, 我们得到最佳参数,然而由于约束的存在,我们不一定能够取到最小值,只能尽量接近; 由于 \\sum_{i=1}^n\\lambda_i\\times g_i(w)\\leq 0 所以 L(w,b) \\leq p 故而我们需要先尽可能接近 $p$ \\max_\\lambda L(w,b,\\lambda) 接着再求总体最小值 \\min_{w,b}\\max_\\lambda L(w,b,\\lambda)\\\\ s.t.\\qquad\\lambda _ {i}\\geqslant 0 从而可以构造Lagrange函数: \\min_{w,b}\\max_\\lambda L(w,b,\\lambda)=\\\\\\ \\frac{1}{2}||w||^2+\\sum_{i=1}^m\\lambda_i\\times[1-y_i(w^Tx+b)]\\\\ s.t.\\qquad\\lambda _ {i}\\geqslant 0 注意维度问题, $\\omega$ 维度与样本个数相同, 而 $\\lambda$ 维度与一个样本点的特征数相同(即 $m$) 强对偶性转换(与KKT互为充要条件, 前面已满足),等价于 \\max_\\lambda\\min_{w,b} L(w,b,\\lambda) 由此我们可以先求 $\\min_{w,b} L(w,b,\\lambda)$ \\frac{\\partial L}{\\partial w} = 0\\\\\\frac{\\partial L}{\\partial b}=\\sum_{i=1}^m{x_y\\times y_i} = 0 第一个式子怎么求($\\frac{\\partial L}{\\partial w} = 0$)? L(w,b,\\lambda)=\\frac {1}{2}||w|^ {2}+\\sum_{i=1}^{m}\\lambda_i\\times(1-y_ {i}(w^ {T}\\vec{x_ {i}}+b)) $i$ 表示第 $i$ 特征, $m$ 为总特征数; 具体推导建议查看这样一步一步推导支持向量机，谁还看不懂？; Adaboost推导Adaboost基本流程: 输入: Datasets: {…,[$x_i$,$y_i$],…}; 学习器: $F(x) = sign(F_m(x)) = sign(\\Sigma_k^M{F_k(x)\\times \\alpha_k})$; 参数: $W_i, i = 1…N$: 各个样本点的权值;这一权重代表了被分类错误的严重性,也即当一个学习器分类; $\\alpha_k$:各个学习器的权值; 流程: 初始化样本点权重: $W_i = 1/N$; 迭代: 训练一个弱学习器$G_k$,G 代表 gender; 更新$\\alpha_k,W_i$: error rate: e_m = \\Sigma_i^N{W_i\\times I(G(x_i)\\ != y_i)} the weight of the Gender learner: \\alpha_k = \\frac{1}{2}\\log{\\frac{1-e_m}{e_m}}, i.e.\\frac{1}{2}\\log{\\frac{positive\\ rate}{negative\\ rate}} The weight of each sample points: $W{k,i} = W{k-1,i}\\times \\exp{-\\alpha_m\\times y_i\\times G_m(x)}$ $Fm = F{m-1}+\\alpha\\times G(x)$ 最终学习器:$F(x) = sign(F_m(x)) = sign(\\Sigma_m^M \\alpha_mG_m(x))$ 更新公式的推导 Loss function: Loss = $\\exp(-yi\\times[F{m-1}(x)+\\alpha_m\\times G_m(x)])$ $= \\exp(-yi\\times F{m-1}(x))\\times\\exp(-y_i\\times\\alpha_m\\times G_m(x))$ 定义:$Wi = \\exp(-y_i\\times F{m-1}(x))$ $= W_i\\times\\exp(-y_i\\times \\alpha_m \\times G_m(x))$ 故而损失最小化也即: $W_i$已知; $G^*(x) = \\alpham\\times G_m(x) = \\argmin{\\alpha,G(x)}[{\\exp(-y_i\\times \\alpha_m \\times G_m(x_i))}]$ 由于要在整个训练集上最小化损失,故而要将其期望最小化: E[Loss] = \\exp(-\\alpha \\times y_i \\times G_m(x_i))\\\\ => \\exp(-\\alpha)\\times P(y=G_m(x))+\\exp(\\alpha)\\times P(y != G_m(x)) 离散型变量的期望求和公式; -\\exp(-\\alpha)\\times P(y=G_m(x))+\\exp(\\alpha)\\times P(y != G_m(x))==0 求导并使其等于0, 从而找到最小点; \\alpha_k = \\frac{1}{2}\\log{\\frac{1-P(y != G_m(x))}{P(y != G_m(x))}} $\\alpha$更新公式; 损失函数: 类型: 0-1损失: 平方损失: 绝对损失: 对数损失: 直接将(f(x),y)带进Loss函数去算,得到的是单个预测的损失; 我们要验证决策函数f的优良性, 应当求其期望: 输入输出遵循联合分布P(X,Y),则期望损失: R_{exp}(f) = E_P[L(Y,f(X))] = \\inf_{\\kappa\\times y}L(x,f(x))P(x,y)dxdy 然而我们无法知道P(X,Y) [这正是我们需要的], 故而我们只能用已知的—训练集的损失, 也即经验损失: R_{emp}(f) =\\frac{1}{N}\\sum_{i=1}{N}L(y_i,f(x_i) 根据经验风险最小化求最优: \\min_f \\in F{\\frac{1}{N}\\sum_{i=1}^N{L(y_i,f(x_i))}} 就如同下图, 忽略黑线, 能够直接取到最中心的等值线[最小值]; 然而我们在这种情况下求到的只能是过拟合的, 因为根据大数定律, 只有当样本量无穷大的时候,我们才能让经验风险接近期望风险; 我们当然不希望过拟合(这意味着我们得到的模型只是贴近于训练数据集),因此我们要为其加上正则项: R_{srm}(f) =\\frac{1}{N}\\sum_{i=1}{N}L(y_i,f(x_i)+\\lambda J(f)\\\\ srm = structural risk minimization\\\\ J(f) = 模型复杂度 关于正则化可查看什么是正则化 这时,当结构风险过小,也即模型过于复杂时[含有多个非零参数],第二项模型复杂度会比较大,因而不会被选取; 泛化误差: 刚才我们讲到的是对于训练数据集的风险, 最小化其得到模型f,用这个模型去预测没被用来训练的数据, 就可以得到泛化误差: R_{exp}(\\hat{f}(X)) = E_P[L(Y,\\hat{f}(X)] = \\inf_{\\kappa\\times y}L(x\\hat{f}(X))P(x,y)dxdy 泛化误差也叫out of sample error,因为是经过最小化风险得到的模型, 参数已然确立, 相当于测定模型离真实值的偏离程度; 正则化作用: L1正则化: $\\alpha||w||_1$, 1-范数 权值向量各个元素的绝对值之和 作用: 偏向于让权值向量在优化过程中接近于0,即变得稀疏; 原理: L2正则化: $||\\alpha||w||_2^2$, 2-范数的平方 权值向量各个元素平方和的平方根 作用: 对于大数值的权值向量进行惩罚, 从而更偏向分散的权重向量;[也即使用更多特征,从而能够减少过拟合] 原理: 我们求解实质上是优化问题, 最小化loss; 正则化相当于在我们优化的过程中添加了限定条件, 如 等值限定条件: \\begin{align*}&min \\quad f(x)\\\\ & s.t. \\quad h(x) = 0\\end{align*} 如果不添加该限定条件, 那么应当按照f(x)的极值点来求, 也即是找到$\\frac{\\partial{f(x)}}{\\partial{x}} = 0$的点; 但是由于$h(x)=0$这一条件的存在, 我们只能选择在上图黑线上的点, 由等值线可知, 越往圈内越小, 故最小值在图中相切处取得; 也只能在相切处取得, 因为若是相交, 则说明: 往圈内走还有别的取值线与之相交, 也即是说: 沿着圈向内还能取到更小值; 所以也就是说, 对于f(x)和h(x)而言, 在相切的地方, 两个函数的梯度一定在同一条直线上, 可以表示为: \\nabla f(x) = \\lambda \\times \\nabla h(x)...(1) 变化一下式子: \\nabla f(x) +\\lambda \\times \\nabla h(x) = 0...(2) 这就又回到了起点, 我们再对$\\lambda,x,y$分别求偏导, 并使偏导等于0, 再解方程组即可; 那么对于多个约束的情况呢? 上面我们得到了: G(x) = \\nabla f(x) +\\lambda \\times \\nabla h(x) = 0...(3) 再加一个约束$h_2(x)=0$, 也无非是: \\nabla G(x) +\\lambda_2 \\times \\nabla h(x) = 0...(4) 再多来点也无非是: L(x,\\lambda)=f(x)+\\sum_{i-1}^{n}\\lambda_{i}\\nabla h_{i}(x)...(5) 然后对$\\lambda_i,x$求偏导, 使其等于0; 对于等式约束和不等式约束混合: 又要分为两个情况: 由于一个在可行域内部的h(x)上的点, 如果他不是f(x)的极值点[下图左], 那么除非h(x)在该点处与等值线相切,并且位于边界处,就能够沿着h(x)在可行域内找到f(x)更小的点; 因此实质上只有两种情况: 上图右:在 h(x) 和 等值线相切的地方[并且是边界处] \\nabla f(x)+\\lambda \\nabla h(x)+\\mu \\nabla g(x) = 0\\\\ h(x)=0\\\\ g(x)=0\\\\ \\mu \\geq 0...(6) 由图可知, 越往外值越大, 故而g(x)的梯度方向是向外的, 而f(x)的极小值点在中间, 也即其梯度是向内的; 所以二者梯度相反, 所以对应(1)式中$\\lambda&lt;0$, 变化为(2)的形式后自然大于0了; 上图左:f(x) 的极值点本身就在可行域里面。 等于没有不等式约束; 用松弛变量的方法引入: 将$g(w_i)&lt;0$变为 $h(w_i) = g(w_i)+a_i^2 =0$, 再作为无约束优化求解: λ为什么大于0? 同上面集合方法的证明; 对于$\\lambda\\times a_i = 0$,有两种情形(对应上面) 情形1:$\\lambda_i=0,a_i\\neq 0$ $\\lambda_i=0$, 相当于没有约束 情形2:$\\lambda_i\\neq0,a_i=0$ 此时$g_i(w) = 0$,且$\\lambda_i&gt;0$; 如何在一个方程里面显示出来:[也就是KKT条件] \\nabla f(x)+\\lambda \\nabla h(x)+\\mu \\nabla g(x) = 0\\\\ \\mu g(x) = 0\\\\ \\mu \\geq 0 \\\\ h(x)=0\\\\ g(x) \\leq 0...() 这个优化问题的极值点一定满足这组方程组。 不是极值点也可能会满足，但是不会存在某个极值点不满足的情况; 也即该优化问题取得极值的必要条件; 回到L1,L2正则化, 我们可以用只有两个权值w1,w2的模型作为例子; 对于L1正则化(右图): 它将原本在整个坐标系的解空间, 限制到了方形的边缘上(不等式限制$w_1+w_2\\le C$) 而等值线与菱形端点相交的概率要大很多, 所以会有权值在最优时取到0(端点位于坐标轴上),至于为什么概率会更大: 在不加约束的条件下, loss函数中心的位置落于红色区域,则等值线与端点相交[取一个点,灵活半径画圆,总是最先碰到端点]; 将图线不断延伸, 即可发现红色区域面积远大于白色区域[或许截个圆比较合适] 对于L2正则化(左图), 圆形区域对于任意极值点, 边缘上每个点被取到的概率都一样; 设输入向量x=[1, 1, 1, 1]，两个权重向量$w_1=[1, 0, 0, 0]，w_2=[0.25, 0.25, 0.25, 0.25]$。那么$w_1^Tx=1,w_2^Tx=1$，两个权重向量都得到同样的内积，但是w1的L2惩罚是1.0，而w2的L2惩罚是0.25.因此，根据L2惩罚来看，w2更好，因为它的正则化损失更小。从直观上来看，这是因为w2的权重值更小且更分散。所以L2正则化倾向于是特征分散，更小。 损失函数: 类型: 0-1损失: 平方损失: 绝对损失: 对数损失: 直接将(f(x),y)带进Loss函数去算,得到的是单个预测的损失; 我们要验证决策函数f的优良性, 应当求其期望: 输入输出遵循联合分布P(X,Y),则期望损失: R_{exp}(f) = E_P[L(Y,f(X))] = \\inf_{\\kappa\\times y}L(x,f(x))P(x,y)dxdy 然而我们无法知道P(X,Y) [这正是我们需要的], 故而我们只能用已知的—训练集的损失, 也即经验损失: R_{emp}(f) =\\frac{1}{N}\\sum_{i=1}{N}L(y_i,f(x_i) 根据经验风险最小化求最优: \\min_f \\in F{\\frac{1}{N}\\sum_{i=1}^N{L(y_i,f(x_i))}} 就如同下图, 忽略黑线, 能够直接取到最中心的等值线[最小值]; 然而我们在这种情况下求到的只能是过拟合的, 因为根据大数定律, 只有当样本量无穷大的时候,我们才能让经验风险接近期望风险; 我们当然不希望过拟合(这意味着我们得到的模型只是贴近于训练数据集),因此我们要为其加上正则项: R_{srm}(f) =\\frac{1}{N}\\sum_{i=1}{N}L(y_i,f(x_i)+\\lambda J(f)\\\\ srm = structural risk minimization\\\\ J(f) = 模型复杂度 关于正则化可查看什么是正则化 这时,当结构风险过小,也即模型过于复杂时[含有多个非零参数],第二项模型复杂度会比较大,因而不会被选取; 泛化误差: 刚才我们讲到的是对于训练数据集的风险, 最小化其得到模型f,用这个模型去预测没被用来训练的数据, 就可以得到泛化误差: R_{exp}(\\hat{f}(X)) = E_P[L(Y,\\hat{f}(X)] = \\inf_{\\kappa\\times y}L(x\\hat{f}(X))P(x,y)dxdy 泛化误差也叫out of sample error,因为是经过最小化风险得到的模型, 参数已然确立, 相当于测定模型离真实值的偏离程度;","categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"}],"tags":[{"name":"machine learning","slug":"machine-learning","permalink":"https://github.com/Molaison/Molaison.github.io/tags/machine-learning/"}]},{"title":"基因工程学习笔记","slug":"基因工程学习笔记","date":"2022-10-14T02:05:40.000Z","updated":"2023-06-10T05:55:39.577Z","comments":true,"path":"2022/10/14/基因工程学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2022/10/14/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"绪论 Basic steps in gene cloning 将DNA片段插入载体; 导入宿主细胞 recombinant molecule 复制 宿主细胞分裂 plating产生clony basic steps in PCR:特异引物识别DNA片段从而使其被复制从而富集 94°C 氢键断开, 双链分开 50-60°C, DNA与引物杂交, 退火 74°C, Taq DNA polymerase(抗高温), 引物5’-&gt;3’复制 94°C下一轮循环 Limitation of PCR: 必须知道退火位点,也即知道引物结合地方序列; 长度限制: 5kb-40kb(特殊技术可以最高复制40kb) usage: virus dectation: 高倍扩增 purifying gene 载体Plasmid 载体要求: 能够在宿主体内复制: 含有复制起点 理想大小小于10kb,大了会断开,而且不易于操作; 宿主细胞:大肠杆菌, 一次只接受一个质粒拷贝; 类型I: plasmids, 环形分子 独立于基因组 携带一个或多个基因 携带抗体基因可作为选择性标签,四环素和青霉素抗性基因; 质粒复制方式: integrative:插入宿主基因组复制 non-integrative:含有复制起始位点，独立复制,也称为episome; copy number: 宿主体内独立存在的质粒分子数； stringent:少但是大, 1-2/cell relaxed:多, over 50/cell conjugation: 物理接触 产生pilus(管道?) 宿主DNA滚环复制并转移到受体中 conjugative&amp;non-conjugative:产生pilus or not; 由于conjugative plasmid 会传播至其他细胞; tra基因控制(含有则conjugative) compatibility:是否两质粒能共存; incompatiblity:在复制过程中两个子代细胞分别获得一个 F plasmid/F factor: 含有tra基因,conjugative; Bacteriophage(Phage) 噬菌体特征: 侵染细菌 结构简单 含有DNA|RNA:编码复制的基因 Capsid:外衣 类型I:λ phage episome 环状和线性DNA之间切换(cos位点) 基因成簇排列 裂解型 感染时间小于20min 基因组大小49kb prophage:整合进基因组的噬菌体DNA; lysogen:携带prophage的宿主; 编码capsid的基因成簇排列 便于控制基因组表达 b2 region: 可以删掉以增加能放进capsid的外源DNA长度 cos site:sticky end 线性的DNA分子通过两cos位点环化，从宿主基因组脱离 内切酶识别序列，能够将滚环复制得到的长链切断成单个噬菌体基因组 类型II:M13 环状, 但是却是单链DNA 不发生细胞裂解，M13颗粒持续释放 capsid由三个基因的多份拷贝(不是多次复制)编码 不发生整合 M13复制流程: 单链DNA注入并合成双链，称为RF，复制态 双链DNA 通过滚环复制生成新的RF 双链replicative form(RF)通过滚环机制重新产生单链DNA(滚环但是不复制) 单链DNA环化并组装 M13的优势: 基因组小于10kb; RF类似质粒,能够以质粒形式感染; 单链形式DNA有利于测序和体外突变(in vitro mutagenesis);还能用于phage display(将要表达的蛋白基因和衣壳基因连在一起使其位于噬菌体外部) DNA纯化 Terminology: Total cell DNA: genomic DNA加上additional DNA molecules(如质粒) Pure plasmid DNA:从细菌中提取,去除genomic DNA后的; Phage DNA:from bacteriophage particles 需要去除衣壳(M13除外,RF直接na) Defined medium: all the components are known(M9) Undefined medium:the precise identity and quantity of the components are not known(LB) Basic steps: 细菌培养 E.coli培养: LB medium 37°C 摇床充气 检测细胞浓度: 光学法:测量在600nm处的吸光度(光密度OD是在特定波长下的吸光度) $1\\ OD_{600} = 0.8\\times 10^9\\ cells/ml$ 离心使细胞裂解 细胞抽提(去除除DNA外组分) 物理方法:研磨 化学方法: 溶菌酶:digests the cell wall EDTA: removes magnesium ions sodium dodecyl sulphate (SDS):removes lipid molecules. 离心:remove insoluble debris DNA纯化: 方法1:降解污染物 proteinase K处理: 消化蛋白质; 苯酚和氯仿混合(Phenol&amp;chloroform):沉淀蛋白质 ribonuclease:去除RNA 方法2:组分分离 离子交换层析:DNA, RNA,部分蛋白质带负电结合与正电树脂,随后盐溶液洗脱,RNA+protein首先脱出,DNA最后,保留; silica method: guanidinium thiocyanate硫氰酸胍：将除DNA外的物质变性, 同时使得DNA结合于silica particles; DNA富集: Ethanol precipitation:$Na^+$, -20°C条件 玻璃棒搅动附着DNA 离心沉淀DNA DNA浓度: 测量在260nm波长时的吸光度 $1 \\ OD_{260} = 50\\ ug/ml$ DNA纯度: The ratio of the absorbances at 260 and 280 nm around 1.8 with a pure DNA sample. 分离质粒和细菌基因组: 物理性质: 质粒DNA分子较小, 细菌基因组较大 质粒和细菌基因组都为环状,但是在细胞抽提时基因组会断裂成线性分子,所以我们要做的是分离环状DNA分子; 质粒DNA双链的两种形式: Covalently closed circular (ccc) DNA (Supercoiled DNA) Open-circular (oc) DNA 超螺旋分子能很轻易地从非超螺旋分子中分离,且大多数质粒以超螺旋形式存在于细胞中; alkaline denaturation:碱变性法 线性DNA在高PH时变性双链分开,而超螺旋质粒则保持原样; 再将PH调回7,DNA分子复性,但交织在一起,通过离心被去除; 这一过程大部分RNA和蛋白质也变得不溶, 被离心去除; 氯化铯密度梯度离心: 密度不同，导致蛋白质(浮力小)在管的顶部，而RNA则相反在底部,DNA的浮力密度在蛋白质与RNA之间故而在管中间; EtBr处理:分离超螺旋DNA和其他DNA EtBr通过插入相邻碱基对与DNA结合，导致双螺旋部分解开。 超螺旋不易结合故而浮力密度减少较少,而线性分子减少较多; 质粒扩增: 多拷贝质粒能够在没有蛋白质合成的情况下复制 氯霉素, 蛋白质合成抑制; λ噬菌体DNA获取: 获取噬菌体颗粒: 侵染后离心后噬菌体颗粒在清液层,而细菌沉积; 噬菌体分为烈性噬菌体和溶原性噬菌体; 在感染于寄主细菌细胞时，前者往往在菌体内增殖并将菌体裂解； 后者则不使细菌裂解，而成为与细胞同步增殖的遗传因子——原噬菌体。 温和噬菌体的基因组整合于宿主菌基因中，这种整合在细菌染色体上的噬菌体基因称为原噬菌体，原噬菌体可随细菌染色体的复制而复制，并通过细菌的分裂传给下一代，不引起细菌裂解，这种带有原噬菌体的细菌称为溶原性细菌。 lysogenic型λ噬菌体获取: cI基因:控制噬菌体处于prophage状态; 在cI内引入一个温度敏感突变(temperature-sensitive,即cIts) 30°C:正常分裂; 42°C:裂解; non-lysogenic型λ噬菌体获取: 许多载体都删除了cI基因,无法整合入细菌基因组; 所以只能通过细胞裂解获得噬菌体,故而需要注意噬菌体与细菌的比例; 富集噬菌体颗粒: PEG,一种长链多聚化合物,在有盐的条件下能够让噬菌体颗粒沉淀; 能够有效减少悬液的体积,有助于DNA提取; 噬菌体颗粒提纯:氯化铯密度梯度离心; 去除细菌残骸,DNA; DNA提取:只要去除蛋白外壳即可,苯酚或者蛋白酶处理; M13噬菌体DNA获取: Replicative form形式同质粒一样获取; 单链DNA形式获取: 类似λ烈性菌; Manipulation of Purified DNA DNA外切酶: 直接移除双链末端碱基对; 移除双链中一条单链的末端核苷酸; DNA内切酶: 只能切开单链，或者双链中裸露的单链; 既可以切单链也可以切双链; 在特异性位点切割双链; DNA连接酶: 连接双链中的单链断开 连接两双链分子 DNA聚合酶: 需要有双链区(primer)起始聚合; DNA聚合酶I 5’-3’外切酶活性由一个323氨基酸片段决定，失去这一片段不影响聚合酶功能，但是无法解聚DNA, 缺失该片段后的酶,叫做Klenow fragment;(注意是这个修改后的酶!!!) 修复功能通过替换旧链方式实现，当5’-3’外切酶功能失去后，只能填充缺口，无法切除确实部分; 注意5’-3’外切酶,缺口处理方向; Taq DNA polymerase: 耐高温的嗜热菌DNA聚合酶I DNA modifying enzymes 去除5‘端末端磷酸基团 重新在5’端接上磷酸基团 将脱氧核苷酸加到DNA链(单双)3‘末端(OH基团) 限制性内切酶: Host-controlled restriction:宿主细胞能够在噬菌体复制之前切割噬菌体DNA,而细菌自身的DNA受到保护，不会被降解，因为它被甲基修饰。 II型限制性内切酶在基因克隆中很重要。 识别位点为回文序列； II限制性内切酶有相同的亚基，识别的序列必然相同； 两亚基位置不平行，故而结合位置有差异, 所以产生粘性末端; BamHI和BglII具有相同的粘性末端; 还需要注意的是切割出的粘性末端长度: 如EcoRI,切割”G|AATTC”,但是由于对称结构,左右两边各留出一个核苷酸,粘性末端为”AATT” restriction digest: Ethidium bromide (EtBr):前面说到能够插入DNA双链,同时也能用来给DNA染色; DNA分子大小评估: a size marker; 使用不同的酶切割获取不同的基因; DNA ligation: 互补粘性末端的连接比钝性末端要高效的多; Putting sticky ends onto a blunt-ended molecule: Linkers There should not be any BamHI recognition site in the fragment! Adaptors 实际上是带有粘性末端的片段; Part c是可能的问题:adaptor相互连接; 解决办法:将粘性末端突出链(5’端)的磷酸基团去除,从而无法互相结合 Producing sticky ends by homopolymer tailing Terminal deoxynucleotidyl transferase:末端转移酶,见上文 DNA modifying enzymes;能够往3’端添加核苷酸; 目的基因加poly C,载体加poly G,结合稳定; polymer长度不同的问题: Klenow polymerase+ligase Introduction of DNA into Living cells 未连接的载体 未连接的DNA 自体连接的载体 携带错误片段的分子 [质粒DNA引入]Transformation:the introduction of any DNA molecule into any living cell. 只有少部分物种能够轻松转化; 大肠杆菌只吸收少量DNA; 大肠杆菌需要化学或者物理处理使得其competent; competent: DNA吸收能力增强的细菌培养物; Competent treatment: calcium chloride($CaCl_2$)溶液,低温处理; 氯化钙能使DNA沉积于细胞表面; 同时造成细胞膜产生物理变化(如打出孔) 将温度提升到42°C,使得DNA被吸收 检测是否吸收完成|稳定:通过判断某些基因是否表达(如表达青霉素抗性的基因) Select transformed cells: 1 ng pUC8质粒只能够产生100-10000个转化体, 仅为总DNA分子数的0.01%,故而要经过挑选; 抗生素选择: 用共有抗性 amp 筛选出载体分子和重组分子(不含载体的被筛去); 需要37°C培养1小时以让抗性基因表达; Recombinant identification 插入失活:正常表达的载体含有的选择性标签由于目的基因的插入而失活; 插入后原本表达的特征不表达; 抗生素抗性基因选择(pBR22): pBR22携带四环素和青霉素抗性[BamHI插入] 用木板记录下菌落位置,并按位置移植到$tet^R$培养基中,重组分子由于插入失活从而无法生长, 在第一个中取反即可得知重组分子菌落位置; lac基因选择(pUC8): pUC8携带青霉素抗性基因[BamHI插入] 半乳糖苷酶由两部分组成:一部分由宿主编码(编辑过的大肠杆菌,缺失了编码lacZ’的部分),另一部分由质粒表达,组合成全酶; X-gal:乳糖类似物,被半乳糖苷酶分解生成深蓝色产物; IPTG: 在没有乳糖存在时，lac操纵子（元）处于阻遏状态。此时，I序列在PI启动序列操纵下表达的Lac阻遏蛋白与O序列结合，阻碍RNA聚合酶与P序列结合，抑制转录启动。当有乳糖存在时，lac操纵子（元）即可被诱导。在这个操纵子（元）体系中，真正的诱导剂并非乳糖本身。乳糖进入细胞，经β-半乳糖苷酶催化，转变为异乳糖。后者作为一种诱导剂分子结合阻遏蛋白，使蛋白构象变化，导致阻遏蛋白与O序列解离、发生转录。异丙基硫代半乳糖苷（IPTG）的作用与异乳糖相同，是一 种作用极强的诱导剂，不被细菌代谢而十分稳定，因此被实验室广泛应用。 由于recombinants中的lac基因被插入失活,故而无法合成半乳糖苷酶片段,无法分解X-gal,呈现白色; [噬菌体DNA引入]transfection&amp;in vitro packaging: transfection: equivalent to transformation; M13双链的RF形式DNA导入 in vitro packaging: λ噬菌体转染效率低,使用in vitro packaging方法; capsid 蛋白准备: 系统1: 缺陷cos位点,cos位点无法被识别, 致使λ噬菌体无法复制(滚环需要环状DNA),但是能够合成蛋白; 系统2:有两个重组, 两个所携带capsid基因中分别有一个突变,生成的蛋白不全,故而无法独立完成感染循环,将之混合后能够进行组装从而获得噬菌体. 噬菌斑: 对于λ噬菌体:包含裂解的宿主细胞和噬菌体颗粒; 对于M13:包含生长缓慢的细菌和M13颗粒; 每个噬菌斑来自于单个感染的细胞; 可能是recombinants,也可能是self-ligated vectors; Select recombinant phages: lac基因插入失活:recombinant的噬菌斑不是white,而是clear! λ cI基因插入失活:non-recombinant的cI基因正常工作,形成lysogen,故而呈现浑浊噬菌斑; Spi表型:λ噬菌体不能感染P2噬菌体已经感染的大肠杆菌,称之为$Spi^+$; 插入新的DNA能够使λ转变为$Spi^-$,从而能够形成噬菌斑[也只有重组型可以]; Cloning Vectors for E.coli 经典质粒: pBR322 4363bp大小,体积小; 青霉素和四环素抗性基因; 15copies, 高拷贝数; pBR327 比pBR22更高的拷贝数(30-45copies) pUC8 500-700copies; 青霉素抗性基因+lac’基因,能够完成重组体选择 lac’基因上有一簇限制性位点,允许DNA片段两不同粘性末端; pGEN3Z 青霉素抗性基因+lac’基因 含有两promoter序列在lac’基因的两端,可以用于体外转录,从而允许双向转录; 噬菌体载体: lambda噬菌体: 大小问题: 噬菌体衣壳大小有限,能放入的DNA长度有限; solution: 将无重要功能的b2区去除从而省出空间; 酶切位点问题:λ噬菌体有多个酶切位点(甚至对于同一个限制酶); solution: 将分泌限制酶的E.coli突变体用λ噬菌体感染,如果只有产生突变的,去除了限制位点的噬菌体能形成噬菌斑; 绝大部分的λDNA被降解, 少数剩下的(产生plaque)丢失了限制位点; 种类: λ insertion vector:去除b2区得到,存在一个酶切位点; 普通λ基因组只能增加5%的DNA,也即3kb,否则放不进capsid,去除非必要区后,容量大大增加; λgt10:CI基因能够保持基因组在Prophage状态,含有EcoRI限制位点, 基因插入失活,从而产生clear plaque;携带8kb λ ZAPII:含有lacZ’基因,故而能够允许插入失活,并含有6个限制性位点; replacemnet vector替换型载体: 含有一个stuffer区, 能够通过限制性位点替换掉Stuffer fragment;携带10kb; λ噬菌体既可以用环状DNA以质粒形式转染,也可以使用liner形式(含有EcoRI和cos位点) cosmid : a plasmid that carries a cos site; 所需的克隆数:N N = \\frac{\\log{1-\\rho}}{\\log{1-\\frac{a}{b}}} $\\rho$ = 在基因文库中gene of interest出现的概率; $a$ = 插入片段的大小 $b$ = 基因组总大小; M13噬菌体: 由于M13基因组基因相隔很近, 修改或者是删除这些基因将会导致RF的功能受阻,只有508个碱基的修改不会影响, 也即是复制起始位点所在区; 插入lacZ’到起始位点后面的流程: 怎么做到将限制性位点插入lacZ’? 首先利用密码子的简并性, 突变得到EcoRI位点同时不改变lacZ’的功能; 接着将两端有EcoRI粘性末端的polylinker(携带多个限制位点)插入lacZ’的限制位点; Hybrid plasmid-M13 vectors (phagemids):杂交M13和质粒: 将M13的一部分DNA(形成RF的基因)导入pUC8从而使得质粒能像M13一样进行; Cloning vectors for Eukaryotes 出于某些特殊目的, 我们可能需要使用真核生物作为宿主: 为了获得大量药用蛋白; 为了改变某个生物的性质,如为农作物添加除草剂抗性; 真菌载体(酵母): 2 μm plasmid: REP1 and REP2 are involved in replication of the plasmid. FLP: 编码能够使质粒内重组的蛋白; copy numbers:70-200 selective marker: LEU2: 编码将丙酮酸转化为亮氨酸的酶, 对于trp-营养缺陷型的宿主来说是必要的,故而以之作为宿主,再使用含LEU2的载体从而得到recombinant; 其他的marker也类似,主要是使用缺陷型; 克隆载体: 种类: Yeast episomal plasmids (YEps): 为shuttle vector, 能够同时在酵母和大肠杆菌中复制; 这一性质使得其能首先通过大肠杆菌进行纯化, 再转入酵母; 载体通过与宿主基因组中同源的基因发生重组从而整合进基因组: LEU突变体和酵母LEU基因发生重组.使得质粒进入酵母基因组,类似插入序列,会复制目标片段,形成两个基因,但通常只有一个有效 Yeast integrative plasmids (YIps) 跟episome的区别在于没有起始位点,只能通过整合进基因组和宿主一起复制; Yeast replicative plasmids (YRps) 跟integrative相对, 以质粒形式复制; Yeast centromere plasmids (YCps) 含有复制区和着丝粒,能够像基因组一样复制,故而被称为mini-chromosome; 几种克隆载体比较: 转化频率: 加入一定量质粒DNA能获得的转化体数(个每微克) YEps &gt; YRps,YCps &gt;&gt; YIps 拷贝数: YEps:20-50 YRps:5-100 YIps == YCps == 1 重组体稳定性: YIps &gt; YCps &gt; YEps &gt; YRps 特殊载体:YAC yeast artificial chromosome 组成成分: centromere: 能够像基因组一样复制 two telomeres: 作用1: 让末端能够正确地被复制; 作用2: 避免其被外切酶消化; 复制起点; TEL: act as seeding sequences for telomeres building CEN4: DNA from the centromere region of chromosome ori: The origins of replication SUP4: selectable marker into which new DNA is inserted. Yeast are normally red(accumulation of red pigment), and those transformed with YAC will form colorless colonies. URA3 and TRP1: selectable markers. Electroporation: 电穿孔法:在膜上打出暂时的孔洞从而吸收DNA, 对于植物来说则是要多加两步, 去细胞壁和重新生成细胞壁; 对于植物: Ti(tumor inducing) plasmid: Ti质粒转染后T-DNA会整合进基因组,从而使细胞表现出成瘤性 Ti质粒过大, 不利于操作: 解决方法1: 双质粒法, 将T-DNA从原来的Ti质粒移出至质粒B,剩下质粒A; 质粒A负责表达转移T-DNA的蛋白; 质粒B则小到便于我们操作,从而能够添加限制位点; 解决方法2:共整合法,Ti质粒加上一个携带有T-DNA同源片段的质粒(含目的基因) T-DNA和小质粒发生同源重组,从而将目的基因转移到T-DNA中; T-DNA整合的机理: 质粒载体直接转移: 超螺旋质粒能够通过同源重组整合进植物基因组; 导入细胞的方法: Biolistics,PEG-induced DNA delivery,Electroporation 将基因导入叶绿体基因组: 通过同源重组导入, 叶绿体数量多,表达量高; 植物病毒载体: 植物病毒多为RNA,仅有的两种DNA病毒不适合作为克隆载体; 动物克隆载体: 部分蛋白在细菌或者真菌中无法正常表达;基因疗法,通过将一个基因导入病人细胞; P elements:","categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"}],"tags":[{"name":"biology","slug":"biology","permalink":"https://github.com/Molaison/Molaison.github.io/tags/biology/"}]},{"title":"Javascript学习笔记","slug":"Javascript学习笔记","date":"2022-10-07T09:20:49.000Z","updated":"2023-06-09T09:40:22.543Z","comments":true,"path":"2022/10/07/Javascript学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2022/10/07/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Javascript简介Javascript的特性与其他语言的不同之处: 在JavaScript 中，函数与其他对象共存，并且能够像任何其他对象一样地使用。函数可以通过字面量创建，可以赋值给变量，可以作为函数参数进行传递，甚至可以作为返回值从函数中返回。 函数闭包 JavaScript 还没有(类似C语言中的)块级作用域下的变量，取而代之则只能依赖函数级别的变量和全局变量. 不同于其他主流的面向对象语言(例如C#、Java、Ruby)使用基于类的面向对象，JavaScript 使用基于原型的面向对象 特殊的功能, 特性: 生成器, 一种可以基于一次请求生成多次值的函数,在不同请求之间也能挂起执行. Promise，让我们更好地控制异步代码。 代理，让我们控制对特定对象的访问。 高级数组方法，书写更优雅的数组处理函数。 Map，用于创建字典集合；Set，处理仅包含不重复项目的集合。 正则表达式，简化用代码书写起来很复杂的逻辑。 模块，把代码划分为较小的可以自包含的片段，使项目更易于管理。 转换编译器: 当新的标准制定, 新的特性出现时, 部分用户往往仍然使用老旧的浏览器, 一种解决方法是使用转换编译器, 将较新的Js代码转化为等价的, 能在当前浏览器运行的代码. Traceur 和 Babel是较为流行的两种 理解浏览器浏览器环境概念: 文档对象模型(DOM): Web应用的结构化的UI表现形式, 最初由web应用的HTML代码构成; 事件: 大部分JavaScript 应用都是事件驱动的应用，这表示大部分代码执行在对某个特殊事件响应的上下文中。 如网络事件、计时器、用户生成事件例如点击、鼠标移动、键盘按压事件等。 浏览器 API: 获取设备的信息、存储本地数据或与远程浏览器交互的API。 调试工具: 探索 DOM、调试 JavaScript、编辑 CSS 样式和跟踪网络事件等。 测试: assert(condition, message); 第一个参数是一个应为真值的条件，第二个参数是当断言为假时所展示的一句话。 性能分析: 把要被测量的代码放在两个计时器调用之间; 12345console.time(&quot;My operation&quot;); //My operation是名字/* codes to count*/console.timeEnd(&quot;My operation&quot;); 跨平台开发: 通过使用浏览器和 Node.js(源自于浏览器的环境)，你能够开发几乎你能想到的任何类型的应用。 桌面应用，通过使用如NW.js或Electron的库可以开发桌面应用。 包装javascript和浏览器核心 移动应用，使用类似Apache Cordova的框架开发。 使用Node.js 开发服务器端应用和嵌入式应用，Node.js 是源自于浏览器的环境，使用了很多类似浏览器的底层原理。 浏览器页面构造过程 Fig 1.1 web应用的生命周期 主要由两个步骤构成: 页面构建和事件处理; 页面构建又分为两个步骤, 在页面构建过程中交替进行; 解析HTML代码并构建文档对象模型(DOM); 执行 JavaScript 代码. 当遇到脚本节点时执行; HTML 解析和 DOM 构建 尽管 DOM 是根据 HTML 来创建的，两者紧密联系，但需要强调的是，它们两者并不相同。你可以把 HTML 代码看作浏览器页面 UI 构建初始DOM 的蓝图。 浏览器修正了错误的HTML代码 当页面构建遇到脚本元素时, 会暂停构建DOM转而执行JavaScript代码; DOM与脚本的关系: window 对象是获取所有其他全局对象、全局变量（甚至包含用户定义对象）和浏览器 API 的访问途径。 全局 window 对象最重要的属性是 document，它代表了当前页面的 DOM。 通过使用这个对象，JavaScript 代码就能在任何程度上改变 DOM 全局代码与函数代码: 函数代码指的是包含在函数中的代码,全局代码指的是位于函数之外的代码; 全局代码以一种直接的方式自动执行，每当遇到这样的代码就一行接一行地执行。 函数代码必须被调用才执行; 事件处理浏览器处理代码特性: 浏览器同一时刻只能执行一个代码片段，即所谓的单线程执行模型。 所有生成的事件都被放在同一个事件队列中(注册事件监听器), 从头部开始被处理; 事件类型: 浏览器事件，例如当页面加载完成后或无法加载时； 网络事件，例如来自服务器的响应（Ajax 事件和服务器端事件）； 用户事件，例如鼠标单击、鼠标移动和键盘事件； 计时器事件，当timeout 时间到期或又触发了一次时间间隔。 注册事件监听器方式: 通过把函数赋给某个特殊属性； window.onload = function()&#123;&#125;;, 将函数赋值给window对象的onload属性; 这一方式的缺陷在于对于一个事件只能注册一个事件处理器, 创建新的处理器时会将上一个给改写掉; 通过使用内置addEventListener方法。 123456789document.body.addEventListener(&quot;mousemove&quot;, function() &#123; //#为mousemove事件注册处理器 var second = document.getElementById(&quot;second&quot;); addMessage(second, &quot;Event: mousemove&quot;); &#125;); document.body.addEventListener(&quot;click&quot;, function()&#123; //#为 click 事件注册处理器 var second = document.getElementById(&quot;second&quot;); addMessage(second, &quot;Event: click&quot;); &#125;); 函数函数与对象函数中最重要的概念: 函数是第一类对(first-class objects),可以被视为其他任意类型的 JavaScript 对象。 能被变量引用: 能以字面量形式声明: function ninjaFunction()&#123;&#125; var ninja = &#123;&#125;; 甚至能被作为函数参数进行传递。 call(function()&#123;&#125;) 回调函数(callback): 将在随后调用的函数, 也即作为参数被其它函数执行的函数; 执行 useless(getText)调用后的执行流 回调函数排序:我们提供一个函数用于比较, 返回值大于0需要调换,小于等于0不需要;在比较时调用回调来决定数组的顺序; 1234var values = [0,1,2,9,6,5,3,4]values.sort(function(value1,value2)&#123; return value1-value2&#125;) 储存函数: 存储元素唯一的函数集合; 123456789101112131415161718var store = &#123; nextId: 1, cache: &#123;&#125;,//使用一个对象作为缓存，我们可以在其中存储函数 add: function(fn) &#123; if (!fn.id) &#123; fn.id = this.nextId++; this.cache[fn.id] = fn;//仅当函数唯一时，将该函数加入缓存 return true; &#125; &#125; &#125;; function ninja()&#123;&#125; //测试上面代码是否按预期工作 assert(store.add(ninja), &quot;Function was safely added.&quot;); assert(!store.add(ninja), &quot;But it was only added once.&quot;); 自记忆函数: 当函数计算得到结果时就将该结果按照参数存储起来,如果另外一个调用也使用相同的参数，我们则可以直接返回上次存储的结果; 1234567891011121314151617181920212223function isPrime(value) &#123; if (!isPrime.answers) &#123; isPrime.answers = &#123;&#125;; //创建缓存 &#125; if (isPrime.answers[value] !== undefined) &#123;//检查缓存的值 return isPrime.answers[value]; &#125; var prime = value !== 1; for (var i = 2; i &lt; value; i++) &#123; if (value % i === 0) &#123; prime = false; break; &#125; &#125; return isPrime.answers[value] = prime;//存储计算的值 &#125; assert(isPrime(5), &quot;5 is prime!&quot; ); assert(isPrime.answers[5], &quot;The answer was cached!&quot; );//测试该函数是否正常工作 函数定义方式 函数声明: function myFun() &#123; return 1;&#125; 函数声明与函数表达式的不同之处 函数声明:作为独立表达式;函数表达式:作为其他语句的部分,作为右值/参数/返回值; 对于表达式, 函数名不是必须的,对于声明, 他们被引用的唯一方式是通过名字; 立即调用函数表达式IIFE):(function()&#123;&#125;)(2),创建了一个新函数并调用; 括号的作用: 不加括号时, 以function开头的语句会被解释为声明, 然而没有函数名, 故而会报错 上图四个语句都是立即函数,但是使用一元操作符指明处理的是表达式,而非语句;符号得到结果没有被储存,关键在于IIFE被调用了; 箭头函数(lambda函数): param =&gt; expression 省去function,大括号,return; param: 参数, 单个参数省略括号, 多个参数与声明一致; expression: 多行表达式需要&#123;&#125;; 函数构造函数: 以字符串形式构造函数;new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;) 生成器函数:在执行过程中,能够退出这个函数再重新进入,过程中保留函数内变量值;function* myGen()&#123; yield 1; &#125; 函数参数 参数性质: 实参多于形参: 按照顺序赋值, 多余的实参不会被赋值; 形参多于实参: 没有对应实参的形参则会被设为undefined; 剩余参数: 剩余参数以……做前缀, 且只能是最后一个参数, 被放到以去除…后的名称(reaminingNumbers)的数组中; 默认参数: 原理是未被赋值的形参为undefined 另一种方法是函数重载: 定义一个名字相同但参数不同的函数;但JavaScript不支持; 直接在定义中为参数赋默认值 每次函数调用时都会从左到右求得参数的值,当对后面的默认参数赋值时可以引用前面的默认参数 函数调用 arguments参数: 传递给函数的所有参数的集合; 为实参的集合, 不论是否有对应形参; 通过数组下标方式访问参数, arguments[i]; arguments.length获取实参个数,但它不是数组,只是与数组类似,在其上使用数组的方法会报错; 相比较之下, 剩余参数则是作为数组; arguments对象是函数参数的别名, 在函数内改变arguments对象的值也会改变对应形参,反之亦然; 在JavaScript 提供的严格模式（strict mode）中无法再使用别名。&quot;use strict&quot;; this参数:函数调用相关联的对象(函数上下文) this 参数的指向不仅是由定义函数的方式和位置决定的，同时还严重受到函数调用方式的影响; 函数调用的四种方式: 作为一个函数(function)直接被调用;test() 非严格模式下,this==window全局对象;严格模式下this==undefined; 作为一个方法(method),关联在一个对象上,实现面向对象编程;myobj.test(), 此时this指向该对象; 作为一个构造函数(constructor),实例化一个新的对象;new ObjName() 当使用关键字 new 调用函数时，会创建一个空的对象实例并将其设置构造函数的上下文 当构造函数有非对象返回值时,用new调用则返回新建对象,直接调用则返回该值; 但当返回对象时, this对象将被舍弃; 构造函数命名通常以大写字母开头,为描述对象的名词;函数方法则以小写字母开头,为描述行为的动词; 通过函数的apply 或者call 方法;obj.apply(...) or obj.call(...) Button函数中, 原本通过button.click调用this应该指向button,但是由于我们将其绑定到了按钮上,故而this指向了elem元素; apply方法, 上下文对象和参数数组; call方法, 上下文对象和参数, 无需使用数组传递参数; forEach方法(call|apply)迭代数组 解决上下文问题的其他方法: 箭头函数: 箭头函数从定义时的所在函数继承上下文,相比较函数表达式指向全局对象; 与清单4.10比较:4.10中Button构造函数的click函数上下文被addEventListener绑定到了elem元素, 而箭头函数的click函数从Button函数处继承上下文,故仍然指向button. 存在的问题: click 箭头函数是作为对象字面量的属性定义的，对象字面量在全局代码中定义, 所以箭头函数this指向window; bind方法: 不管如何调用该函数，this 均被设置为对象本身。 被绑定的函数与原始函数行为一致，函数体一致。 闭包与作用域 闭包能够允许函数访问并操作函数外部变量; 全局作用域实质上是一种闭包, 但是从未消失; 通过outerFunction我们封装了一个innerFunction,并将该function赋给全局变量later,从而能够访问到inner*,并且该函数的作用域为全局+outerFunction; 这里ninja是outerfunction的局部变量,按理来说应当无法访问,但是声明inner*时,创建了一个闭包,不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。 也即是说,创建闭包不仅保存了函数,还有其作用域内的变量; feints变量不是通过this.feints方式定义的,故而不能直接访问,但是其包含于Ninja的作用域中,能被this.feint()函数所访问; 这一功能有点类似于shiny的模块化,闭包被不同的参数调用,其内部变量互不影响; 全局执行上下文只有一个，当JavaScript程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的。 函数上下文是内部的, 而执行上下文是JS引擎追踪函数执行使用的; 基本和其他语言差异不大; 词法环境: 也即作用域(scopes); 当使用变量时, 从内向外开始查找, 从调用栈从上往下一级一级查, 直至找到或者是全局作用域中都没有而报错; 不是从定义函数的环境查找; 变量类型: const关键字: 声明的变量的值无法变更(指用新的值覆盖);compared with var and let(能多次覆盖) 用于定义无需重新赋值的变量, 或者是某个固定的值(通常用于描述性变量名替代单纯数值); 不允许将全新的值赋值给const变量,但是可以修改; var关键字:声明变量是在距离最近的函数内部或是在全局词法环境中定义的; 与C不同,js不关注块级作用域,var声明的变量在距离最近的函数或全局作用域中实现; forLoop的块级作用域中声明的元素仍能被外部访问; 与var不同, let和const在最近词法环境定义变量(块级,循环,函数,全局); 块级作用域: for(){}, if(){}, with(obj){}, try{}/catch{},even simple {}; 标识符注册: 定义在使用之后(谈恋爱要在世界拯救之后??); 注册流程: 找到函数声明, 创建arguments和函数参数; 扫描当前代码进行函数声明（不会扫描其他函数的函数体),对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上. 扫描当前代码进行变量声明。 在函数或全局环境中，查找所有当前函数以及其他函数之外通过 var 声明的变量，并查找所有通过 let 或 const 定义的变量。 在块级环境中，仅查找当前块中通过 let 或 const 定义的变量。 generator和promise生成器函数 基于每次请求生成值, 从而生成一组序列; 每次请求生成新的值 / 或者告诉我们不再生成新值; 在关键字function前加星号*,从而在生成器内部使用yield生成独立值; for-of循环: 新的循环方式; 将值赋给const变量得到迭代器object; iter.next()返回一个对象,包含 result.value: 返回的值,如生成已结束则为undefined; result.done: 是否生成器结束,如已结束则为true; 调用next方法 -&gt; 执行代码直到遇到yield -&gt; 返回中间值; yield* otherGenerator将执行权交给另外的生成器; 整体执行逻辑不变,仍旧是遇到yield就返回值, 相当于生成了一个栈, 新加一个生成器就加一层栈; 生成器用法: 生成ID序列:定义一个无限循环的生成器,每次返回++ID; 遍历DOM树: 深度优先,优先往下访问; 向生成器发送值: 情况1:在初始状态调用并传入参数; 情况2:next方法传入参数; 用throw方法向迭代函数抛出一个错误,该错误会被catch()函数获取,传递给参数e; 生成器执行流程: 生成器比较特殊，它不会执行任何函数代码。而是生成一个新的迭代器再从中返回，通过在 代码中用 ninjaIterator 可以来引用这个迭代器。 由于迭代器是用来控制生成器的执行的，故而迭代器中保存着一个在它创建位置处的执行上下文。 每次调用next方法,不是像普通函数那样,生成新的上下文,而是把原有的上下文重新放入栈中; 挂起开始 — 创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。 执行 — 生成器中的代码已执行。执行要么是刚开始，要么是从上次挂起的时候继续的。 当生成器对应的迭代器调用了next方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。 挂起让渡 — 当生成器在执行过程中遇到了一个yield表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。 完成 — 在生成器执行期间，如果代码执行到return语句或者全部代码执行完毕，生成器就进入该状态。 promise promise实例化对象传入的是两个函数参数,第一个为resolve函数表成功,reject表失败; 当承诺成功兑现（在promise上调用了resolve),前一个回调就会被调用，而当出现错误就会调用后一个回调函数（可以是发生了一个未处理的异常，也可以是在promise上调用了reject） promise 对象是对我们现在尚未得到但将来会得到值的占位符； 它是对我们最终能够得知异步计算结果的一种保证。如果我们兑现了我们的承诺，那结果会得到一个值。如果发生了问题，结果则是一个错误，一个为什么不能交付的借口。 回调函数缺陷: 错误难以处理:不是很理解这段话,学完再看; 执行连续步骤麻烦: 一个长期任务结束后我们可能会用得到的数据开启另一项任务,就需要不停的缩进+嵌套; 并列步骤需要书写多段类似代码: promise执行逻辑: promise对象从pending开始,标记为未完成; 若promise对象resolve方法被调用,获取值,进入完成状态; 若reject方法被调用,则获取出错原因,进入完成状态; 需要注意的是第二个Inmmediatepromise,为什么会在”at code end”后执行? 拒绝promise: then中调用第二个回调函数 then中只传入第一个回调函数, 错误通过catch获取 then可以有很多步,从而完成任务流,而catch函数,只要前面有任何一个promise出错,就会将其捕捉; 不是主动调用,而是函数内部出错; Promise.all函数接受的是一个promise对象的数组; 只有全部成功才会被解决, 只要有一个失败就被拒绝; 拒绝与接受取决于第一个成功的promise; 生成器与promise结合 每个promise也即异步任务都被yield返回; 如果生成器的结果是一个被成功兑现的承诺，我们就是用迭代器的 next 方法把承诺的值返回给生成器并恢复执行iteratorValue.then(res =&gt; handle(iterator.next(res))); 如果出现错误，承诺被违背，我们就使用迭代器的throw方法抛出一个异常.catch(err =&gt; iterator.throw(err))","categories":[{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"hexo-blog环境配置","slug":"hexo-blog环境配置","date":"2022-10-05T10:59:58.000Z","updated":"2023-06-09T12:12:32.269Z","comments":true,"path":"2022/10/05/hexo-blog环境配置/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2022/10/05/hexo-blog%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"基本软件安装与配置node安装step 1: 进入nodejs官网 —- nodejsstep 2: Download for Windows(x64) —&gt; 选择Long Term Support(LTS)项下载.step 3: 打开msi文件, 等待guide wizard安装, 随后一路next即可(除了路径切换).step 4: win+R —&gt; 输入cmd —&gt; 输入node -v查看版本信息 —&gt; 显示版本代表安装成功. git安装与配置下载与配置过程过于麻烦, 考虑到本文主题, 这里不做详细介绍, 可参照git安装与配置. hexo安装与配置1234567//选择一个文件夹作为本地博客，右键 &gt; Git Bash Herenpm i hexo-cli -g //安装Hexohexo -v //查看hexo版本hexo init chniny-blog //新建并初始化一个文件cd chniny-blog //进入文件夹npm install //安装所需模块npm install hexo-deployer-git --save //安装用于写markdown文档的模块 next主题下载step 1: 下载next主题method 1: 在本地博客文件夹右键 &gt; Git bash here: 12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next method 2: 进入next-github, 点击Code按钮, 点击Download ZIP. 将ZIP解压至本地文件夹的theme文件夹下, 并重命名为next(此处名称在设置主题时需要与配置文件保持一致). step 2: 打开本地博客文件夹根目录下的_config.yml文件, 找到theme并配置为theme:next. 连接Githubstep 1: 设置用户名和邮箱, 右键 -&gt; Git Bash Here: 12git config --global user.name &quot;你的GitHub 用户名&quot;git config --global user.email &quot;你的GitHub 邮箱&quot; step 2: 创建ssh密钥, 输入命令ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;. 进入 [C:\\Users\\用户名.ssh]目录, 找到”id_rsa.pub”右键-&gt;打开方式-&gt;记事本, 打开并复制里面内容. step 3: 登录github, 点击头像-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key-&gt;将title命名为hexo,并将step 2复制的文本粘贴入key文本框中-&gt; Add SSH key. step 4: Git Bash -&gt; 输入ssh -T git@github.com -&gt; 出现”Are you sure…”, 输入yes确认. step 5: 点击github页面左上角logo进入主页 -&gt; Create a new repository -&gt; 见下图介绍: step 6: 打开博客文件夹配置文件_config.yml, 在末尾加上: 1234deploy: type: git repository: https://github.com/name/name.github.io.git branch: main 需要注意的是, name为你的github用户名, 且每个”:”与后接的值之间必须要有一个空格; 图床配置这里博主选择使用Github+Picgo+Jsdelivr搭建图床. Github配置:与上一步一样,新建Github repository, 设置库为Public, 但是名称可以任意设置; Token获取: GitHub主页 -&gt; 右上角头像 -&gt; settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token -&gt; 填写note并点击Generate token -&gt; 复制token; Picgo安装: 从Picgo官网直接下载对应版本安装即可; Picgo配置: 打开Picgo -&gt; 图床设置 -&gt; GitHub图床, 参考配置如下;仓库名设定: “用户名/仓库名”, 也即下图中红框部分:将第二步获得的token粘贴到对应输入;指定路径表示我们上传的图片存放于库中哪个目录下; jsdelivr加速: 由于github在不科学上网的条件下不稳定, 且速度较慢(通过修改hosts文件或者使用代理能够解决), 使用cdn为github加速. 配置如下:其他可用域名: 123CloudFlare: test1.jsdelivr.netCloudFlare: testingcf.jsdelivr.netFastly: fastly.jsdelivr.net 替换图中gcore.jsdelivr.net即可; 网站主题与信息配置站点信息配置个人信息配置: 12345678910title: Molaison&#x27;s blogssubtitle: &#x27;Per Aspera Ad Astra.&#x27;description: &#x27;&#x27;keywords: - Bioinformatics - Computational Biology - Machine Learningauthor: Molaisonlanguage: zh-CNtimezone: &#x27;&#x27; 网址信息配置: url设置为你的Github库的网址, 即下图中红框部分; root节点设置为”/“, 2022/10/4日实测不设置该节点 or 设置为”/name.github.io/“ or “/name.github.io” 均会导致网站样式表无法加载, 呈现下图样式, 具体原因可能是js文件路径错误导致; 123456789## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://github.com/Molaison/Molaison.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 主题配置打开目录”theme\\next\\”下的_config.yml文件, 主题配置主要在此文件中进行; 布局设置: next主题提供了四种布局,可依照需求选择,预览效果见awesome-next给出的示例,即”Live Preview”下的链接; 1234# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 菜单设置: menu下的键值对代表侧边栏中是否含有该标签,即下图红框部分(由于设置了语言,这里显示为中文,但并不是通过翻译实现,而是在next主题目录下的language文件夹中对应的yml配置文件中,使用键值对实现);menu_settings中icons和badges分别表示是否显示图标和计数符号; 1234567891011121314menu: home: / || fa fa-home about: /about/ || fa fa-user tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive schedule: /schedule/ || fa fa-calendar sitemap: /sitemap.xml || fa fa-sitemap commonweal: /404/ || fa fa-heartbeat# Enable / Disable menu icons / item badges.menu_settings: icons: true badges: true 侧边栏设置:设置侧边栏位置;头像设置: 根目录-&gt;theme-&gt;next-&gt;source-&gt;images-&gt;avatar.gif,调整图像大小,随后将其转成gif即可; 1234567891011sidebar: # Sidebar Position. position: left #position: rightavatar: # Replace the default image and set the url here. url: /images/avatar.gif # If true, the avatar will be dispalyed in circle. rounded: false # If true, the avatar will be rotated with the cursor. rotated: false 文章目录设置: 12345678910toc: enable: true # 是否开启目录 # Automatically add list number to toc. number: true # 自动增加列表数，比如`1.1 1.2 1.3` # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false # 标题内容大于侧边栏宽，是否再下一行显示 # If true, all level of TOC in a post will be displayed, rather than the activated part of it. expand_all: false # 是否自动扩展所有列表，而不是仅扩展当前二级标题下的列表 # Maximum heading depth of generated toc. max_depth: 6 代码块主题设置: 更多可用主题可以查看next-highlight code; 12345678910111213codeblock: # Code Highlight theme theme: light: default dark: tomorrow-night prism: light: prism dark: prism-dark # Add copy button on codeblock copy_button: enable: false # Available values: default | flat | mac style: mac","categories":[{"name":"problem solving","slug":"problem-solving","permalink":"https://github.com/Molaison/Molaison.github.io/categories/problem-solving/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"GENEXII学习笔记","slug":"GENEXII学习笔记","date":"2022-09-03T03:01:24.000Z","updated":"2023-06-10T05:55:39.584Z","comments":true,"path":"2022/09/03/GENEXII学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2022/09/03/GENEXII%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"The First Section: Gene is DNA that encodes RNA and polypeptidesTerminology Genome/基因组: 脱氧核糖核酸(deoxyribonucleic acid,DNA)链提供了有机体，以及它的每一个细胞所携带的全部遗传信息。它包括染色体DNA、质粒DNA,以及(真核细胞中)存在于线粒体和叶绿体的细胞器DNA。 protein—coding gene、结构基因(structural gene)：编码的RNA依次编码多肽。 gene locus: 每一条染色体由线性排列的基因组成，每个基因位于染色体的特殊位点上。 allele : 基因座上所发现的不同形式。 linkaage : 一条染色体上的等位基因表现出连锁遗传。 transfection: 转染，指纯化的DNA加入到动物细胞中产生特殊的蛋白质。 nucleotide：在C-5与磷酸基团相连的核苷称为核苷酸。 supercoiling : DNA双螺旋结构自身相互缠绕从而改变DNA分子空间构象。同向扭转(顺时针)正超(positive),反之负超。 lingking number(L) : DNA一条链绕另一条链的环绕圈数。不同L的NDA分子称为拓扑异构体。 writhing number(W) : DNA双链的轴所绕圈数，无量化值，W=0则为松散分子。 twisting number(T) : 一条链相对于另外一条的旋转情况。由每圈多少个碱基决定。 L~0~为松散状态L, L/L~0~可视为超螺旋密度。 bent DNA:一条链上出现8~10个连续腺嘌呤(A)导致双螺旋弯曲。 melting temperature: 使DNA双链分开的温度范围的中点。 hybrization : 两条不同来源的互补核酸序列退火形成双链结构。 滤膜上吸附有变性DNA，置于含有其他变性DNA的溶液中，即可检测是否含有互补序列。检测紫外吸收峰值测定杂交程度或是通过放射性强度决定。 mutation rate: 贯穿全基因组的突变(突变率以每个基因组每代发生多少来表示)：基因内的突变(突变率以每个基因座每代发生多少来表示)：特殊核苷酸位点的突变(突变率以每个碱基每代发生多少来表示)。 transposable element: 具有可从一个位置移动到另一个位置的DNA序列。这一插入往往导致基因活性消失造成移码突变(frameshift mutation)。 插入发生时往往会删除部分或者全部插入序列，邻近区域也可能被删除。 forward mutation:正向突变，使基因失活的突变。相对应的是back mutation，回复突变。 true reversion:真实回复。原始突变的严格逆转。 second-site reversion:第二位点回复。第二次突变弥补了第一次的功能。 suppression mutation: 一个基因座上的突变能够抑制另一个的突变效应。该locus称为抑制基因(suppressor) 点突变可能导致多肽的氨基酸替换，而tRNA基因上的一种突变使得它能识别突变的密码子，那么在翻译中就会插入原来的氨基酸残基(请注意：这抑制了原来的突变，但在其他mRNA的翻译中会引入错误)。 cistron: 处于顺式构型或是反式构型的基因是指两个突变是否在同一条链上。 null mutation: 基因功能被完全消除。 loss-of-function mutation: 阻止基因功能的突变。 leaky mutation: 突变不完全消除蛋白质活性，保留一定活性。 silent mutation: 无明显效应的突变。 synonymous mutation: 碱基改变但是氨基酸残基不变。 neutral substitution: 碱基改变，氨基酸残基也改变，但多肽活性不变。 中性突变(neutralmutation) : 它对有机体表型没有影响。 一些中性突变是同义突变，但不是所有的同义突变都是中性的。具体运送特定氨基酸的单一RNA的浓度是不同的，一些同义tRNA(不同tRNA携带一样的氨基酸)比其他的丰富，一些特殊密码子可能缺少足够的tRNA； frameshift mutation移码突变：吖啶acridine引起，引进或者缺失一个碱基。(-)和(+)两种，分别表示缺失与增加。同时(+)(-)和(-)(+)两种方式可相互抑制，一个称为另一个的移码抑制基因(frameshift suppressor)。 当构建三突变体时，只有(+++)和(—-)表现野生型表型，而其他组合都是突变型。 错义突变(missense mutation): 产生编码不同氨基酸的密码子; 无义突变(nonsense mutation): 产生终止密码子。 reading frame:阅读框，如果遗传密码是不重叠的三联体，根据起始位点的不同，那么会有3种可能的方式将核苷酸翻译成蛋白质。 一个由能翻译成氨基酸的三联体构成的阅读框称为可读框(open reading frame,ORF)。 多肽序列有一个特殊的起始密码子(initiation codon)(AUG),从此延伸出一系列代表氨基酸的三联体，直到遇到3种类型的终止密码子(termination codon)(UAA、UAG或UGA)中的一个时才结束翻译。 如果终止密码子频繁出现，就会阻止阅读框被翻译成蛋白质，我们称之为关闭(closed)或阻断(blocked):如果一个序列的3个阅读框全部被阻断，那么它就失去编码蛋白质的功能。 在3种可能的阅读框中，只有一种阅读框是可翻译的，而其他两种会受到频繁的终止信号的阻断。 colinear: 基因与蛋白质是否共线性。核苷酸序列与蛋白质中氨基酸序列是否恰好一致。如果一个多肽含有N个氨基酸残基，那么编码这一多肽的基因就包含3N个核苷酸残基。 gene expression : 用来自基因中的信息合成RNA或多肽的过程称为基因表达。 mRNA还包括两边的附加序列，这些序列不编码蛋白质 5’端的非翻译区称为前导区(leader)或5’非翻译区(5’untraslatedregion,5’UTR). 3’端的非翻译区称为非翻译尾区(trailer)或3’非翻译区(3’untraslated region,3’UTR). cis-acting: 顺式作用。DNA序列包含两个部分，控制位点和编码区，控制位点的缺陷仅仅影响与其相连的编码区，而这不影响其他等位基因的表达能力，这种仅影响邻近DNA序列表达的性质称为顺式作用(cis-acting)。 trans-acting:反式作用，调节物突变。如果突变能发挥反式作用，我们就认为其作用是通过产生可扩散分子(通常是蛋白质或调节性RNA)进行的，它可作用于细胞内多个靶标； Key concepts 碱基配对互补： 一条单链分子中两段互补序列通过碱基配对可以形成分子内的双链体。 一条单链分子可以和另一条独立、互补的单链分子进行碱基配对，形成分子间的双链体。 突变(自发或诱发)只需要在单链形成即可。 突变热点的出现是多个突变事件在一个位点发生的结果。 热点的存在是因为胞嘧啶发生了高频率的自发脱氨基，从而产生尿嘧啶，而甲基化的胞嘧啶脱氨基则产生胸腺嘧啶! 由于U不存在于DNA中，故而胞嘧啶脱氨基能够很快被识别。 Inexplicable points 为什么处于解链温度DNA双链体是稳定的?(comes from GENE XII P16) Interrupted geneTerminology interrupted gene: 断裂基因，编码区和非编码区互相间隔开但又连续镶嵌而成 外显子(exon)的序列包含在成熟RNA中，精确地说，一个成熟转录物(maturetranscript)起始于一个外显子的5’端，终止于另一个外显子的3’端。 内含子(intron)是插入序列，在初始转录物加工成成熟RNA时被除去。 反式剪切：不同mRNA的序列连接到一起 First parity rule: 即碱基配对原则 second parity rule: 在双链的每条单链中AT，CG几乎相等，也即碱基对不是偏向某一条链，而是相对均匀的散落在两条链中；更多地适用于内含子； cluster rule : DNA中嘌呤和嘧啶往往分别聚集在一起，AG，CT，更多适用于外显子； GC rule: 一个基因组中，GC的含量的总体比例具有物种特异性；在基因组内，单一基因往往具有独特的值； 外显子GC含量高于内含子 negative selection: 也称纯化选择(purifying selection), 外显子序列是保守的，因为如果序列改变(不再保守)，就会导致表型的改变，这种改变会使物种难以生存和很难产生可繁殖的后代。 overlapping gene: 同一DNA序列编码两种非同源蛋白，使用了一次以上的阅读框。 nested gene: 一个基因被发现存在于另一个基因的大的、类似于“宿主”的内含子中 重叠基因往往存在于“宿主”基因的另一条链上。 alternative splicing: mRNA前体以多种方式将exon连接在一起的过程; in series gene: equal to no allele; gene family : 为一组源自基因复制事件的、编码相关或相同多肽的基因。在第一次复制事件后，两份拷贝完全一致，随后，当不同突变在序列上累积后，它们就开始趋异。 superfamily: 当我们发现基因相距较远，但还是认为它们具有共同的祖先, 称该组基因为超家族； orthologous gene : 也称ortholog, 是物种进化后所形成的同源基因(homologous gene,homolog),换句话说，它们是不同物种的相关基因。 Key concepts 只有外显子中的突变才会影响多肽链序列；但内含子中的突变会影响RNA的加工，从而可能影响序列和(或)多肽的产生。 DNA碱基组成的4条规则是：第一均等规则、第二均等规则、成簇规则和GC规则。 我们能根据第一条之外的所有规则来区分外显子和内含子。 第二均等规则提示，来自双链体DNA、固定的茎-环区段的外突在内含子出现得更多。 不同生物间内含子的位置通常是保守的，但是相应的内含子的长度变化可以很大。 比较不同物种的相关基因发现，相应的外显子序列通常是保守的，而内含子序列的相似性则低得多。因为缺乏使用有用序列去产生多肽，所以没有选择压力，这样内含子比外显子进化要快得多。 相关性：编码序列和邻近外显子的内含子区域保持了相似性；而在更长的内含子与非编码序列两侧的区域则存在着很大的趋异。 处于正选择下，相对于无突变的其他基因，碰巧产生有利突变的单一基因存活下来； 此时外显子进化要比内含子快； 内含子保守： RNA剪接所需的内含子序列，如5’和3’剪接位点，以及分支位点是保守的； 碱基顺序也被进化以适应于增进这个区域中双链体DNA外突茎-环结构的潜能(折叠潜能) 外显子通常短小，典型的外显子编码小于100个氨基酸。一个基因的总长度主要由它的内含子所决定。 抗体特异性的产生：抗体结构 - 知乎 (zhihu.com) 中关于超变区的描述; Inexplicable points pressure 具体指什么？为什么把它说成信息？ 选择压，就是自然选择淘汰一些表型的基因 Overview of GenomeTerminology genome: 有机体的一整组完全地的基因，最终由DNA的全序列决定。 transcriptome: 在特定条件下表达的一组完整的基因，根据细胞中所存在的这一组RNA分子来决定 proteome: 一组完整的多肽，它可由全基因组编码，或者在某一种细胞或组织中产生。 interactome: 相互作用组，蛋白质可以独立地或者作为多蛋白组装物或多分子复合体的一部分而起作用，如全酶或代谢途径中这些酶簇拥在一起。如果我们能够鉴定出所有的蛋白质与蛋白质之间的相互作用，那么我们就能够确定独立的蛋白质组合体的数目。 reassociation kinetics: 真核生物基因组的总体特征可以通过变性DNA的复性动力学(reassociation kinetics)来估计。 非重复DNA(nonrepetitive DNA)由单一序列组成，在单倍体基因组中只有一份拷贝。 重复DNA(repetitive DNA)是在每一单倍体基因组中含有两份以上的拷贝。重复DNA经常被分为两种类型。 中度重复DNA(moderately repetitive DNA)由相对较短的序列组成，在基因组中，其重复次数一般在10~1000次。 这些序列遍布整个基因组，并负责前mRNA剪接时二级结构的形成，此时内含子中的反向重复配对形成双链体区域。编码tRNA和rRNA的基因也是中等重复的。 高度重复DNA(highly repetitive DNA)由基因组中非常短的序列(一般小于100bp)组成，重复次数达几千次，一般组成长的串联重复。 Linkage map: 根据基因座之间的重组率来确定距离; restriction map:通过限制性内切核酸酶把DNA切成片段, 再测量切割位点的碱基对距离(电泳迁移) genetic polymerphism: 一个基因座上存在多个等位基因; transposon:转座子。有相当大一部分的中度重复DNA是由转座子(transposon)组成的，它们的序列比较短小(最多约5kb),能够移位到基因组中新的位置，或者进行自我拷贝。 synteny : 同线性，不同物种基因组在局部范围内，总体上基因的排列顺序是相同的：当成对的人类和小鼠染色体同源区域进行比较时，位于对应位置的基因通常是同源的。 expressed sequence tag: EST就是转录序列的一小部分，它通常来自于gcoreA文库中的克隆片段的一端或双末端测序。EST能证明一个所怀疑的基因确实是转录的，或有助于鉴定影响特殊疾病的基因。 Key Concepts 蛋白质编码的基因的最大数目： 根据可读框来确定 根据转录物组(通过直接确定所有的mRNA)或蛋白质组(通过直接确定所有的蛋白质)来直接定义基因的数目，这种方法能保证我们处理的是真实基因，即它们是在已知环境下所表达的基因。 非重复DNA随着全基因组的增大趋向于更长。故基因组中的非重复DNA组分与有机体的相对复杂性有较好的相关性。 多肽一般是由非重复DNA编码的。 在同一个分类群中，较大基因组并不一定含有更多基因，但包含有较多的重复DNA。 大部分重复DNA是由转座子组成。 细胞器基因组: 通常为环状DNA分子; 线粒体DNA — mtDNA, 叶绿体DNA — ctDNA or cpDNA; Inexplicable pointsGenome sequence and evolutionTerminology tandem repeat :串联重复序列，以相对恒定的短序列为重复单位，首尾相接， 串联连接形成的重复序列，又称卫星DNA (satellite DNA)。 abundance:在每一个细胞中，每一种mRNA的平均数量被称为这个分子的丰度(abundance)。 scarce mRNA: 也称complex mRNA, 占总量约一半的mRNA组成了大部分不同的序列，约为上万种，每一种mRNA成分的量都不是很多，通常少于10份拷贝。稀有mRNA的表达是广泛重叠的。 constitutive gene: 约10%的mRNA序列在这个细胞中是独特的，大部分表达序列在许多、有时甚至所有细胞类型中都是相同的。这些基因是所有细胞类型所必须的。 luxury gene: 特定细胞类型必需并只在其中表达的基因(如卵清蛋白或珠蛋白) microarray: 含有微陈列(microarray)的芯片，这些陈列包含一排排的、高密度的微量DNA寡核苷酸样品。这种装置是建立在全基因组序列已知的基础之上。在酵母的6181个ORF中，当我们对每一条进行分析时，我们将20条25-寡核苷酸(25-mer,它与mRNA是完全匹配的)和20条不完全匹配的等长的寡核苷酸(它们只在一个碱基位置上是不同的)用来代表同一个ORF,从完全匹配的模式中所得到的信号减去不匹配的信号，就能计算出每个基因的表达水平。 这一技术非常敏感； 不完全匹配的寡核苷酸目的是检测突变； transversion mutation: 从嘧啶到嘌呤或者从嘌呤到嘧啶； transition mutation：从嘌呤到嘌呤，嘧啶到嘧啶； genetic drift: 群体中突变变异体频率的随机变化称为遗传漂变(genetic drift)这是某一种基因型的“抽样误差(sampling error)” 可能一群特殊类型亲本的子代基因型不完全匹配孟德尔遗传定律所预测的数值; 在非常大的群体中，遗传漂变的随机效应往往被平均化了，所以每一种变异体的频率几乎不存在改变； 然而在小群体中，这些随机变化将会非常显著，遗传漂变对群体的遗传变异会产生显著的效应。 genetic hitchhiking : 核苷酸序列以一定速率中性进化，在特定核苷酸中以这种速率进行的变异会影响杂合性(heterozygosity)(在某一基因座的杂合子的比例)。如果变异体序列是有利的，那么这个位点将显示核苷酸杂合性的降低，而变异体在频率上会增加，并最终固定于群体中; divergence: 趋异度, 两基因的差异。可通过在每一个位点上获取最常见碱基，就可计算一个家族的祖先共有序列。每个现存成员的趋异度用它与祖先序列的差异碱基比例来计算； unit evolutionary period: 单位进化时期，产生1%的趋异度所需的时间；百万年为单位； C-value: 活体生物基因组的DNA总量； C-value paradox: 基因组大小与遗传形态复杂性之间缺乏必然联系; CpG岛：p指的是磷酸二酯键，不是pair!! 哺乳动物的基因组里，CpG序列只占1%。其中70%-80%的CpG是零散分布的，但有一部分CpG会聚集成团，就像岛屿一样散布于基因的海洋里，因此得名CpG岛。CpG岛内的CpG可占据总序列长度的60%以上。 70%左右的功能基因的起始部位都有CpG岛存在； 游离的CpG序列总是处于甲基化状态，而聚成岛屿的CpG通常是没有甲基化的。甲基化后的CpG岛就无法结合转录因子(DNA链上伸出来的甲基就像刺刀一样阻止转录因子的靠近) nonallelic gene: 两个(或两个以上)相同基因存在于同一染色体上，这称为非等位基因; 功能基因: 即protein-coding gene, 那些首先被转录成RNA,而后被翻译为多肽的基因。 无功能基因指不能编码相应蛋白质的基因，它们被称为假基因，其失活的原因有多种，可能是转录或翻译的缺陷（或两者均有）所致。 它们不能产生携带原有功能的多肽产物; 它们可以是非功能性的，或产生了变异的功能，以及可具有调节功能的RNA产物。 processed pseudogene: 来自成熟mRNA转录物反转录而成的gcoreA拷贝，并被整合入基因组中； 当活性反转录酶存在于细胞中，如在活性反转录病毒感染时或反转座子具有活性时，这种事件可能会发生。或转录物进行过加工，其结果是已加工的假基因通常缺乏正常表达所需的调节区，故而失活。 nonprocessed pseudogene ：来自多重拷贝或单一拷贝基因的其中一份拷贝的失活突变，或一个活性基因的不完全重复。 如果一个基因整体重复，包括调节区，那么此时即存在两个活性基因的拷贝，而一份拷贝上的失活突变不易受到负选择的影响。从而产生未加工的假基因； 一个活性基因的不完全重复，产生失去了调节区和（或）编码序列的拷贝，将会是“到达即死”形式，即它马上会形成假基因。 霍利迪连接体：https://upload.wikimedia.org/wikipedia/commons/8/8e/НеподвижнаяструктураХоллидея_%28англ.%29.svg.svg) Key concepts 支原体基因组大小0.6*10^6^，人类3.3*10^9^，植物的更大； 原核生物85%-90%的序列都编码RNA或者多肽。 基因组小于1.5Mb的原核生物必定都是细胞内寄生的。也由此鉴定出一个细胞所需的最少基因数，约为1500个； 酵母中有6000个基因；线虫有21700个基因；果蝇有17000个基因；小型植物拟南芥有25000个基因；哺乳动物中的基因数可能有20000~25000个基因。 人类基因组中只有1%由外显子组成。 外显子只占每个基因DNA序列的约5%，因此基因组中只有约25%的序列是来自基因的外显子加内含子。 人类基因组约有20000个基因。 约60%的人类基因是可变剪接的。多达80%的可变剪接改变了蛋白质序列，因此蛋白质组约由50000~60000种蛋白质成员组成。 重复序列占据了人类基因组的50%以上, 主要分为5类 转座子(transposon)(活性或非活性的)占了重复序列的绝大部分(基因组的45%)。所有转座子都是多拷贝的。 转座子具有自我复制和插入到新位点的能力。它们也许只以DNA元件的形式在起作用，或者部分以RNA这种活性方式在起作用 一些现存的基因来源于转座子，在失去转座能力后进化成它们现在的状态 已加工的假基因(总共约3000个，约占总DNA的0.1%。这些序列是mRNA的反转录DNA拷贝插入到基因组而形成的)。 简单重复(高度重复的DNA如CA重复)占基因组的约3%。 区段重复(长度为10~300kb的区段模块在新的区域被重复)占了基因组的约5%。这种重复序列只有一小部分位于相同染色体上，换句话说，大部分重复区段位于不同染色体上。 串联重复形成了一种类型的序列模块(特别是在着丝粒和端粒处)。 当两个或更多的基因存在冗余时，在其中一个基因上进行突变也许不会检测到效应。 在任何给定的细胞中，大部分基因是低水平表达的。 只有一小部分基因的产物是细胞类型所特有的，所以是高水平表达的。 当复制错误，或化学品对核苷酸的改变损害了DNA,或当电磁辐射打断或形成化学键时，而在下一次复制事件中这些损伤没有修复，那么突变就会发生。 转换transition mutation发生的频率是颠换transversion mutation的两倍; 原因可能如下: 自发转换错误比自发颠换发生得更加频繁; 颠换错误更加容易被检测到，并被DNA修复机制校对; 在种间同源基因中，通过计数同义(K~s~)和非同义(K~a~)氨基酸替换，以及计算KK的比值就可研究基因的进化历史。 K~a~/K~s~=1说明这些基因呈中性进化，其氨基酸变化不偏向任何一方; K~a~/K~s~&lt;1提示负选择，此时氨基酸替换是不利的，因为它影响了多肽活性，这样就存在自然选择压力，要在那个位置保留原来功能的氨基酸序列以维持适当的蛋白质功能。 当K~a~/K~s~&gt;1时就会发生正选择。这提示氨基酸改变是有利的，可能在群体中保留下来。 正的K~a~/K~s~值可能是很少的，部分原因是在一长串的序列中，其平均值必须超过1。如果某基因中的单一替换正在被正选择，而两侧区域处于负选择，那么，横跨序列的平均比值实际上是负的。 降低DNA序列多态性的因素：负选择，遗传漂变(drift)，遗传搭车(hitchhiking)； 在RNA世界，由核酸介导的许多功能在基因组空间内相互竞争。可以看成压力pressure; AG压力(外显子中嘌岭富集区的压力) GC压力[全基因组范围内的、两组沃森-克里克(Watson-Crick)配对碱基之间、独特平衡的压力] 单链均等压力(全基因组范围内、在单链核酸中A和T碱基之间及G和C碱基之间的压力) 可能它也与后者相关，即折叠压力(全基因组范围内单链核酸的压力，不管它是以游离形式或从双链体中外突的形式获得二级或更高级茎·环结构)。 基因组大小与遗传复杂性之间没有必然联系。 生物体越复杂，它所需要的最小基因组也越大。 许多在分类上属于一个分类阶元的生物，它们的基因组大小却变化很大。 重复基因可以趋异而产生不同的基因，或其一份拷贝可能会变成失活假基因。重复基因产生差异可能有以下情况： case 1 : 两个基因都将变成有机体所需的。 两个基因编码的蛋白质产生了不同的功能 它们在不同时间或不同细胞类型中表达。 case 2 : 如果上个事件不发生，那么其中一个基因很可能会变成假基因; 因为如果它获得了有害突变后，由于缺乏纯化选择使它消亡，所以由于随机的遗传漂变，出现突变体的频率可能提高，并固定在某一物种中。 在小群体中，遗传漂变是一种更大的力量。在这样一种情况下，两份拷贝中哪一份失活往往是一个随机事件(如果不同拷贝在不同群体中失活，那么这可能造成不同个体之间的不相容性，或最终引起种间差异)。 当被导入到基因组时，转座因子往往增加拷贝数，但它处于负选择和转座调节机制的检测之中。 突变偏爱性可能引起有机体基因组的高A·T含量： 从胞嘧啶到尿嘧啶，或从5-甲基胞嘧啶到胸腺嘧啶的自发脱氨基作用是常见的突变来源，这促进了从G·C到T·A的转换突变。 DNA中的尿嘧啶比胸腺嘧啶更易于修复； 甲基化胞嘧啶(常见于C·G二联体)不仅是突变热点，而且特别偏向于产生T·A对。 鸟嘌呤氧化成8-氧鸟嘌呤能导致从C·G到A·T的颠换，因为8-氧鸟嘌呤与腺嘌呤配对比与胞嘧啶配对更加稳定。 基因转变偏爱性往往增高G·C含量，可能引起部分对抗突变偏爱性。 在重组或双链断裂修复过程中，会产生霍利迪连接体，它能形成含有非匹配碱基对的异源双链DNA,而它会以突变链为模板进行修复，这样就产生了基因转变； 高重组活性的染色体区域显示了偏向G·C的更多突变，而低重组活性的染色体区域往往显示为A·T富集区。 密码子偏爱可能源自偏好特殊序列的适应性机制或基因转变偏爱性。 解释1：一种特定密码子在募集某种丰富的RNA时可能更有效率，如翻译速率或准确度比使用其他密码子更高。** Inexplicable points 为什么要设置不完全匹配的挂核苷酸序列？不会导致误匹配吗？ 预测基因突变 不会，24个都匹配的话误匹配概率低； 是说这个有害突变不致死，或者相对不那么有害吗？ 成簇与重复(看不懂，先跳过)Terminology cluster ：通过某一祖先基因的重复(duplication)和变异(variation)而传递下来的一组基因称为一个基因家族(gene family), 它的成员可以成簇(cluster)排列在一起或散布在不同染色体上（或兼而有之）。 tandem duplication: 一些序列发生了拷贝的同时仍在一起； translocation: 将DNA片段从一条染色体转移到另一条染色体上； unequal crossing over: 也称nonreciprocal recombination, 出现在相似或者一样的两个位点之间的重组事件，但是这一重组并不对称，导致一条染色体上的重复拷贝转移到了另一条上； Key points 核糖体RNA(rRNA)是由大量完全相同的基因编码的，这些基因串联重复形成一个或多个基因簇; 每一个核糖体DNA(rDNA)簇的组成都是有规律的，转录单位和非转录间隔区交互排列，而每个转录单位主要由rRNA和连接前体组成。 Inexplicable points 同源重组的机理是什么? ChromosomeTerminology 包装率(packing ratio): 即DNA的长度除以包装后的长度。 nucleoid-associated protein: NAP,类似于真核生物染色体蛋白； Key concepts 病毒capsid包装： 蛋白质外壳沿着核酸组装，在组装过程中利用蛋白质-核酸之间的相互作用来浓缩DNA或RNA。 烟草花叶病毒TMV组装起始于RNA的两双链发夹结构，为成核中心； 每加一层蛋白质亚基，就抓住一段RNA； 衣壳可以被组建成一个中空外壳，核酸在被装进去时，或者在进入的过程中被浓缩。多球状capsid； λ噬菌体成熟过程中，capsid随DNA进入而改变； 将DNA包装进入噬菌体头部包括两类反应：移位和凝聚，这两个过程从能量的角度上讲都是不利的。 移位：进行滚环复制后产生长DNA，末端酶(terminase)对其cos site切割产生粘性末端，末端酶接着将其转移到capsid； HU蛋白可非特异性地结合与多个位点，但对扭曲的DNA区域具有一定偏爱性； Inexplicable pointsThe DNA replication related to Cell circleTerminologyKey concepts:** 细胞周期的起始： 假设1：起始子蛋白不断合成，达到一定浓度后，就出发其实反映； 假设2：抑制蛋白随着细胞体积的增大浓度稀释到有效浓度以下； 细菌一次复制完成(分裂启动)前，另一个复制周期又开始了，从而造成多复制叉染色体(复制得到的子链又形成复制叉)； Inexplicable pointsThe Transpooson and RetrovirusTerminology Insertion sequence: 插入序列，后加数字代表他们被分离的先后顺序。 细菌操纵子的自发插入物，其插入阻止了被插入基因的转录和（或）翻译。 以末端反向重复序列结尾。两序列密切相关但并非完全一致； 这一区域的存在意味着不管朝哪一侧移动，都能遇到相同序列。 转座时，插入位点处宿主DNA被复制。 该靶序列为复制为同向重复(direct repeat)，分布于IS两侧； 这一重复序列产生的原因是靶DNA的交错断裂产生粘性末端； 末端的顺式作用突变可以阻止转座，这一突变可被负责转座的蛋白，转座酶(transposase)所识别; 含有单一长编码区，从一侧反向重复内侧到另一侧之前或其中，负责编码转座酶。 II类因子：或称DNA型因子。直接操作DNA，并在基因组内自我繁殖。 I类因子：反转录因子。基于自身的RNA转录物制备出DNA拷贝，再整合进基因组中新位点。 long terminal repeat(LTR) retrotransposon: 长末端重复反转录转座子，在总体结构和转座机制上，他们和反转录原病毒很相似。 也称retrotransposon； retroposon：反转录子，同样利用反转录酶，但是没有LTR，有独特转座模式。称为非LTR反转录转座子。 replicative transposition : 复制型转座, 转座子被重复，转座的实体是原来序列的拷贝； 转座酶：在原转座子的末端起作用； 解离酶(resolvase)：对倍增拷贝起作用； precise excision : 转座子发生重组后，细菌酶去掉转座子和重复序列的一份拷贝。 imprecise excision: 留下转座子的残余序列，阻止靶基因的重新激活； 这一切除的频率高于准确切除； cointegrate : 共整合。复制性转座中出现的结构： 链转移复合体的3’端作为复制的引物，产生一个称为共整合(cointegrate)的结构，它由两个原始分子融合而成。 共整合结构含有转座子的两份拷贝，每一份拷贝位于两个原始复制子之间的一个连接处，为同向重复序列(不管从哪个方向都是同向)。而转座酶则可使之产生交换反应。它转变成共整合还需要宿主的复制功能。 解离过程需要解离酶； 链转移复合体：也称交换复合体： 交错末端的单链区，是拟复制叉(pseudoreplication fork); 自主转座子(autonomous transposon)具有切除和转座能力。 非自主转座子(nonautonomous transposon)是稳定的；正常情况下，它们不转座或不允许其他的自发改变。只有在基因组内存在同一家族的自主转座子才能发生转座; Key concepts Ten things you should know about transposable elements 必须要RNA中间体参与的转座是真核生物独有的。 这一转座必须要运用某些形式的反转录酶。 转座基本反应: 转座子的两末端通过酶切反应从供体DNA上分离出来，产生3’羟基(3OH)端。 通过转移反应，暴露末端与靶DNA相连接，这个过程涉及转酯作用(transesterification),使3’-OH端直接攻击靶DNA。 这些反应发生在一个核酸蛋白复合体内，该复合体包含必需的酶和转座子的两个末端。 不同转座子的差别在于靶DNA被转座子识别的时间是否处于其自身被切割的之前或之后，以及转座子的两个末端中一条链或两条链是否在整合前被切割。 当转座子将其另一份拷贝插入原来位点附近的第二个位置时，可能会导致宿主DNA重排，宿主系统可能造成该转座子的两份拷贝之间发生交互重组，其结果取决于其重复序列是同向的还是反向的。 两份同向重复序列交互重组会把两者之间的序列切除(以环状DNA形式)，包括一份重复序列。 反向重复序列：两个重复序列之间的区域被倒位：重复序列自身还可进一步产生倒位。一个反向的复合转座子是基因组稳定的组件，尽管中心区的方向可能因重组而倒位。 两重复序列之间区域可能反向； 非复制转座的原理：链的断裂和重接 靶序列通过插入转座子而重建，供体链仍处于断开状态，不形成共整合结构； 非复制转座：两种形式： 转座子切割过程： 切开一条DNA链 释放3-OH端攻击另一条链，切割位点5‘侧序列被释放 转座子的两条链形成发夹结构 激活的H~2~O分子攻击发夹结构 T10复合转座子:Tn10复合转座子的两条链依次被切断，接着转座子与已切断的靶位点连接起来; T5转座子: Inexplicable pointsProkaryote transcriptionTerminology transcription unit: 从启动子到终止子的一段序列； 最先转录成RNA的第一个碱基对为转录起点； 启动子5‘端序列为上游，3’端序列为下游； transcription bubble：转录泡，RNA聚合酶将DNA分开，形成两条暂时的单链。 转录泡随着合成，逐渐迁移，其后的DNA重新形成双链； unwinding point：解链点，RNA聚合酶在转录泡前端解开双链； rewinding point: 再螺旋点，在泡的后端重新聚合； abortive initiation: 流产起始，任何一个碱基插入后，聚合酶都有释放RNA链的可能性，导致流产起始(abortive initiation)产物的产生。 在释放出流产起始产物后，聚合酶又从+1开始合成第一个碱基。 流产起始的往复循环常常产生长度为几个碱基的寡核苷酸，有时可多达20nt,直到酶真正成功地离开启动子。 down mutation:大多数细菌启动子的突变可造成相关基因转录物的丢失或是大幅度减少； 启动子突变使得转录水平增加的则为上调突变(up mutation); Key concepts 转录发生速度约为40-50bp/s，翻译速度大致相同,约为15 aa/s, 但比DNA复制速度慢得多，约为800bp/s。 转录泡长度约为12-14bp，但是RNA-DNA杂合链长度只有8-9bp； 在转录的任一时刻，正在生长的RNA链上的最后约14个核苷酸与DNA和（或）酶以复合体的形式存在。 转录起始过程： RNA聚合酶结合于启动子序列，DNA维持双链，形成closed complex； 将DNA双链解开，形成open complex； 在细菌中，m/r/tRNA由单一的RNA聚合酶合成，在真核生物中则分别有I/II/III合成； 细菌中RNA聚合酶各亚基的功能： 两α亚基：负责酶的装配，启动子识别，激活因子识别； ββ’亚基：催化中心； σ亚基：改变RNA聚合酶与DNA结合的特性，使得对普通DNA序列亲和性降低，对启动子亲和性增高； 核心酶对DNA有均等的亲和力，全酶中结合常数被降低为1/10^4^,与启动子结合常数为10^3^; σ亚基在聚合酶合成了近10nt时被释放； RNA寻找启动子序列方式： 这一假设作用方式为：RNA聚合酶形成和破坏一系列闭合复合体，直至遇到启动子形成开放复合体； 这一随机过程，收到速度常数的限制速度过慢，不符合实际，故有其他加速的方式； 第一，酶可能以一维随机步移的方式沿DNA迁移，这称为“滑动(sliding)”。 第二，在细菌拟核中存在染色体错综复杂的折叠形式，当酶结合于染色体的某一序列时，酶可能与其他位点靠得很近，这样降低了解离并与另一个位点重新结合的时间，这称为“区段内转移或跳跃(intersegment transfer or hopping)”。 第三，当RNA聚合酶非特异性地结合于某一位点时，它能交换DNA位点直到启动子被发现，这称为“直接转移(direct transfer)”。 RNA聚合酶与DNA结合过程中出现的变化： 注意-35区位置。 三元复合体指RNA，DNA，聚合酶； DNA出现约90°的弯曲，这使得模板能接近于聚合酶的活性位点； 在转录起点中，-11到+3之间的启动子DNA的链被打开； 将启动子DNA挤入活性通道，形成转录泡； 聚合酶的“颌”结构闭合以包围转录起始位点下游的启动子部分。这样，在开放复合体上的启动子接触面就可向外延伸，从-55到+20。 启动子复合体到延伸复合体的转变： 一个启动子是根据在特定位置存在的共有短序列来定义的。 对于细菌来说，能够提供足够信号最小长度为12bp，这12bp可以不相邻； 随着基因组长度增加，特异性识别所需最小长度也增加； 如果碱基数恒定的短序列被某一特定数目的碱基对所隔开，它们若组合到一起，长度可短于12bp,因为所形成的碱基之间的距离本身也提供了部分信息（即使中间序列本身是不相关的）。 在大肠杆菌中，启动子序列缺乏广泛的序列保守性。 有一些小段是保守的，只存在很短的共有序列是调节位点的典型特征； 细菌中，启动子最重要的两元件为两6bp元件，-10区和-35区；其次则为-10区，-35区上下游元件； -10区元件 ：别名Pribnow Box，TATA Box(该名称主要用于真核生物中的相似序列)；以-10bp处为中心； $T{80}A{95}T{45}A{60}A{50}T{96}$, 下标为碱基出现最大频率，对应于其结合重要性； 认为-10区中前端高度保守的TA和末尾一个几乎完全保守的T是启动子识别中最重要的碱基； 在闭合复合体中为双链，在开放复合体为单链； -35区元件：以-35处为中心； 在闭合和开放复合体中是相似的； $T{82}T{84}G{78}A{65}C{54}A{45}$; 间隔区序列：长度约为16-18bp； 真实序列不重要，但是距离很重要； 因为DNA螺旋的本性是与生俱来的，所以它不仅决定了RNA聚合酶中相互作用的两个区域的恰当分开，而且还决定了两个位点彼此之间的空间定向。 转录起点：90%都为嘌呤，典型为腺嘌呤； 以CAT序列为中心？ extended -10 elements: 在启动子缺乏-35区但接近共有序列时，其TGN序列能够弥补这一弱匹配； discriminator：-10区下游，在-10与起点之间，能够识别σ因子； 大小为碱基对； UP元件：-35区上游的10-20bp序列。与两个α亚基的CTD区域作用，在一些高表达的基因的序列中，它能够极大地增加转录； 只有当它与共有序列非常匹配时才将其称作UP元件； 上调突变大多是增大了-35区和-10区与共有序列的相似性，或使两个保守六联体之间的距离更接近17bp: 而下调突变大多降低了它们与共有序列的相似性，或是使间隔距离大于17bp,而且下调突变倾向于集中在有最高保守度的启动子位置上。 与共有序列(12 bp)完美匹配的启动子弱于存在至少一处错配的启动子，这是因为结合过于紧密影响了启动子逃逸； Inexplicable pointsKaryote transcriptionTerminology 转录因子: 转录起始过程必需的蛋白质中非RNA聚合酶成分的部分; 转录因子可以结合DNA,也可以识别别的因子,或者识别RNA聚合酶; 核心启动子: 含有所有RNA聚合酶的结合与功能发挥必需的结合位点; 双向启动子: 位于两个相邻且转录方向相反的基因之间的一段DNA序列 TBP: TATA-binding protein, TATA结合蛋白. 三种RNA聚合酶起始转录的必需因子; Key concepts 真核与原核生物转录的差别: 原核:发生在DNA模板上;真核:发生在染色质模板上; 原核:RNA pol通过σ因子解读DNA序列;真核:不能解读DNA; 不同RNA聚合酶功能; mRNA是三种主要RNA中丰度最低的一个,约占2-5%; RNA聚合酶I: 含有一个双向启动子, 且除核心启动子外,还有一个UPE; SL1复合体: 与核心启动子结合,含两TBP; Inexplicable pointsGene expression regulation:Terminology: 顺式作用:顺式作用的概念适用于只以DNA形式起作用的DNA序列，只影响与其直接相连的DNA序列。 反式作用:基因是编码可扩散产物的DNA序列，这种产物可以是蛋白质，也可以是RNA。任何基因产物自由扩散至其作用靶标的过程称为反式作用 negative control:通过阻遏物来抑制基因表达; operator:操纵基因, 阻遏物的结合位点; positive control:通过正调节物来开启基因表达; induction:在特殊的代谢物或化合物的作用下,由关闭变为工作状态; repression:特殊代谢或者化合物的积累作用下,由工作转变为关闭状态; 阻遏不是完全关闭转录,而是将其降低至1/5 or 1/100; corepressor:如果某种物质能够阻止细菌产生合成这种物质的酶， 这种物质就是辅阻遏物; constitutive expression:表达速率保持恒定的基因表达; constitutive mutation:生成可持续表达的基因,也即组成型表达; interalletic complementation: 等位基因间互补,阻遏物往往能形成多聚物,从而阻遏物亚基能够随机结合,不论是哪个基因 分解代谢物阻遏(catabolite repression):大肠杆菌lac操纵子是负可诱导的。 乳糖的存在可以除去lac阻遏物，这样转录就开启了。 然而，这一操纵子也受到第二层控制，即细菌如果存在足够的葡萄糖供给，那么乳糖也不能开启这一系统。 这一现象的基础是：葡萄糖是一种比乳糖更好的能量来源，所以如果可以获得葡萄糖，那么就没有必要开启lac操纵子。 autoregulated: 自体调节; trpR调节基因受其自身产物tp阻遏物的阻遏。这种阻遏物的作用可降低其合成; Key concepts: 负控制与正控制、可诱导控制与可阻遏控制可以分别组合在一起，形成不同类型的可能调节回路 负控制+诱导(正控+阻遏):诱导实际上暗示了基因的状态为关闭,负控制说明这一关闭是由于激活的阻遏物引起的,而非失活的激活物引起的; 负控+阻遏(正控+诱导):负控和阻遏是一致作用,而负控需要阻遏也即是说原来的阻遏物失活,需要辅阻遏物; 元件: 负控制元件:阻遏物; 诱导元件:诱导物; 正控制元件:激活物; 阻遏元件:辅阻遏物; 原核生物以负调控为主，真核生物以正调控为主。 lac操纵子: 由三个基因lacZ、lacY和lacA组成; lacZ:编码β-半乳糖苷酶,催化β-半乳糖苷分解单糖; lacY:编码β-半乳糖苷通透酶,转运β-半乳糖苷入细胞 lacA:编码β-半乳糖转乙酰基酶,将乙酰从乙酰辅酶A(Acetyl-CoA)转移到β-半乳糖苷上;(可能是用于排出有害的β-半乳糖苷类似物) lacI:编码可扩散产物,阻遏物(蛋白质); 其启动子与RNA聚合酶结合效率低,同时由于缺少5’-UTR,起始翻译的能力较低,导致该阻遏物的丰度较低; 操纵基因:阻遏物可以与之结合阻止转录,含有反向重复序列(转座子?); 阻遏物-操纵基因结合的另个关键元件一铰链螺旋插入到操纵基因DNA的小沟中，这使DNA弯折45°。这种弯曲使大沟可定向用于HTH结合。 诱导物和辅阻遏物:往往与底物或产物结构高度相似; 对于lac系统来说一个经典的诱导剂就是IPTG,能诱导酶的合成但是不被酶解的分子,也称为安慰诱导物(gratuitous inducer) lac阻遏物: 诱导物与阻遏物结合,阻遏物形变,失去功能: IPTG改变lacI编码的阻遏物的空间结构,破坏了铰链螺旋,从而使得阻遏物与DNA结合亲和力下降; 操纵子的排列:越重要的酶排列越靠前; 三种酶的相对数量保持相对恒定; 操纵子存在一个基础表达,以相当低的速度转录,从而保证体内存在通透酶,能够将诱导物吸收进体内; 操纵基因的鉴定: 组成型表达的根源实质上是缺少表达的抑制,从而一直表达; 故而组成型表达可分为两类:反式作用(调节基因突变),顺式作用(操纵基因,启动子突变) 顺式显性作用:假设操纵基因突变,另外有别的启动子无法替代; 调节基因: 反式隐性:$lacI^-$突变,无法结合操纵基因,但只要有别的lac基因能正常表达,即可正常调控操纵子; 反式显性:$lacI^{-d}$突变,DNA结合区域受损; 反式显性:$lac^{-s}$突变使得阻遏物无法结合或者应答诱导物,产生不可诱导型突变体; 阻遏物: 末端的螺旋-转角-螺旋是常见的DNA结合基序, 所有阻遏物都结合于DNA! 阻遏物可以结合非特异性位点,即低亲和力位点,所有碱基对都可以是低亲和力位点; lac的分解代谢物阻遏系统: CRP:部分启动子转录需要辅助蛋白的参与,即依赖性启动子所必需的,又CRP需要结合cAMP才有活性,形成正控诱导体系; 又高水平葡萄糖可以阻遏腺苷酸环化酶活性,减少cAMP,使得转录无法激活; CRP结构:相同亚基形成的二聚体,被单个cAMP激活,从弱结合变为强结合,且识别特异序列,两个反向五联体序列(两个亚基中心对称); CRP能够使得DNA在中心对称处将DNA弯曲90°以上,可能对转录直接作用,也可能只是便于RNA聚合酶结合; trp操纵子自身处于负可阻遏控制。这意味着trpR基因产物—阻遏物是以失活负调节物形式制备出来；而阻遏是指rp操纵子产物色氨酸是p阻遏物的辅调节物。 inexplicable points: 阻遏物加速诱导? 阻遏物与DNA的结合实际上能增强RNA聚合酶结合DNA的能力，只是结合的RNA聚合酶不能起始转录。 阻遏物实际上将RNA聚合酶储存于启动子上。加入诱导物后，阻遏物释放，RNA聚合酶能马上起始转录。 真核生物的转录调节:TerminologyKey concept 真核生物中基因表达大多是在转录起始时受开放染色质控制的。 许多基因拥有多个启动子，而对启动子的选择可改变调节模式，能影响mRNA的利用，因为会改变5’-UTR; 基因表达控制可分为五个节点: 转录起始控制 RNA修饰和加工 转运控制 翻译过程 降解调节 基因存在着两种结构状态。 第一种是闭合染色质中的非活性基因； 第二种是只有在基因表达或潜在表达的细胞里，此时基因处于“活性”状态，或位于开放染色质中。其结构的改变发生在转录开始之前，这表明基因可以被转录的; 在单倍体配子中,染色体以高度凝聚,经修饰的染色质状态存在; 基因的启动: 一些转录因子可能在复制叉之后与组蛋白竞争结合DNA。 封闭染色质可能通过暂时性置换组蛋白八聚体从而打开染色质结构 如果有机体含有足够高浓度的转录因子，那么染色质可被打开； 而如果转录因子浓度较低，那么随后核小体就会结合和凝聚这一区域。 一些转录因子可识别“封闭”染色质中的靶标以起始转录。 这些转录因子能募集组蛋白修饰蛋白和染色质重塑子; 可以开启基因区段,或者是移除启动子结合的障碍物; 基因组被边界元件（绝缘子）分成多个结构域。 绝缘子可阻断染色质修饰从一个结构域向另一个结构域扩散。 真核生物的正控制: 真激活物(true activator): 转录因子, 与启动子上基础转录装置发生直接接触发挥功能; 该激活物的调控模式如下:a. 组织特异性转录因子只在特定细胞类型中合成; 调节发育的因子, 同源异形蛋白(homeoprotein或homeodomainprotein);b. 转录因子活性可由修饰直接控制(如磷酸化激活);c. 转录因子可通过配体的结合被激活或失活d. 转录因子的有效性可能存在差异e. 二聚体转录因子可存在不同的配偶体。一种配偶体可使之失活，而活性配偶体的合成可取代失活形式;尤其在螺旋-环-螺旋(helix-loop-helix,HLH)蛋白中f. 转录因子可从非活性前体中被切割出来 抗阻遏物(antirepressor):在这些激活物中，当其中一种结合于增强子时，它会募集组蛋白修饰酶和（或）染色质重塑复合体，将染色质从封闭状态转变成开放状态。a. 阻遏物将激活物隔离于细胞质中b. 阻遏物结合与激活物从而使其活性失效c. 或者阻遏物被掩盖且固定于细胞质, 直到被释放后进入细胞核, 结合激活物d. 阻遏物与激活物竞争结合位点; 构筑蛋白(architectural protein,如阴阳（Yin-Yang)蛋白。这些蛋白质的作用是使DNA弯曲，将结合的蛋白质聚集在一起，并形成协同复合体；或使DNA往相反方向弯曲而阻止复合体的形成; Inexplicable points","categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"}],"tags":[{"name":"biology","slug":"biology","permalink":"https://github.com/Molaison/Molaison.github.io/tags/biology/"}]},{"title":"Bash学习笔记","slug":"Bash学习笔记","date":"2021-12-17T07:05:18.000Z","updated":"2023-06-09T12:15:50.044Z","comments":true,"path":"2021/12/17/Bash学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2021/12/17/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本语法echo-n ：取消echo输出文本末尾的回车符 -e：解释单双引号的特殊字符，否则默认直接输出 空格空格和tab符被用于分割不同的参数，如有多个，也只识别成一个 分号命令的结束符； 可以使一行多个命令 从左到右执行，前面的命令失败与否不影响第二个命令执行 &amp;&amp;和||cmd1&amp;&amp;cmd2: 如果第一个cmd执行成功则运行第二个 cmd1||cmd2：如果第一个失败则运行第二个 type命令判断命令为内置命令（shellbuiltin）还是外部程序（hashed） -a参数：查看一个命令的所有定义； 因为同一个命令可以有多个程序实现，内部的或者外部的 -t参数：返回一个命令的类型 alias keyword function builtin 快捷键Ctr+L：清屏 Ctr+C：中止命令 Shift+Pageup/down：上/下滚动 Ctr+U：从当前位置删除到行首 Ctr+K：从当前位置删除到行尾 Ctr+W：删除光标位置前一个单词 Ctr+D：关闭Shell对话 Tab：自动补全，双击获得全部备选项 模式拓展Shopt命令调节Bash行为的命令 shopt -s [opt]打开选项 shopt -u [opt]关闭选项 shopt [opt]查询打开或者关闭 参数; dotglob : 意为”.”开头的文件,也即包括隐藏文件与否 nullglob : 让通配符匹配失败时返回空字符, 而非通配符对应字符串 failglob : 当匹配失败时,直接返回错误, 避免命令处理该字符串 extglob : 支持量词语法 nocaseglob : 让通配符不区分大小写 globstar : 支持 “**“拓展,可以匹配任意多级目录 波浪线拓展自动拓展成当前用户主目录 ~user拓展成当前用户主目录 ~foo: /home/foo ~root: /root ~+: 拓展成当前目录,等于pwd ? 字符拓展匹配任意单字符 可以多个连用 *字符拓展匹配任意数量的任意字符 可以匹配零个字符 特殊用法 匹配隐藏文件 通配符: “.*“ 匹配子目录文件 *只能匹配当前目录 “*/“再加上通配符可以匹配子目录,有几层子目录就写几层 “**/“可以匹配零个或者多个子目录 方括号拓展匹配[~]内包含的单个字符 \\^!否定： [!~]或者[\\^~]都可以表示否定 匹配不在方括号中的字符 “-“字符： [start-end]型用法,匹配一个连续的区间 [a-z]:字母表 [0-9]:数字 由于会造成误识别为链接用法, 需要匹配”-“时需要将其放到末尾或者开头 大括号拓展拓展成括号内的所有值 值可以没有,表示空 值之间用逗号分隔 逗号前后不能有空格,否则拓展失效 不是文件拓展,不管文件存在与否都拓展成给定值 优先级高,总是先被运行(相较于其他拓展 可以嵌套拓展 {A{1,2},B{1,2}} 等于A1 A2 B1 B2 {Start..End} 与方括号类似,不过用”..”连接 {Start..End..Step} 指定步长 变量拓展“$“:取变量值 可以与前面的拓展连用,取多个变量值 子命令拓展$(~): ~表示命令,该式将~的输出作为返回值 `~`:同样表示子命令 算术拓展$((~)):将~拓展为整数运算 let 命令使赋值可以直接执行算术表达式 字符类[[:class:]] alnum : 字母和数字 alpha : 字母 blank : 空格和tab键 cntrl : ASCII 0-31的非打印字符 digit : 数字 graph : 字母,数字,标点 lower : 小写字母 upper : 大写字母 print : 32-127 的可打印字符 punct : 标点(除了字母,数字之外的可打印字符) space : 空格,tab, ASCII 10-13(LF,VT,FF,CR) xdigit : 16进制字符 拓展量词?(~): 0,1 *(~): 0-infinity +(~): 1-infinity @(~): 1 !(~): 除外 引号和转义转义符: 反斜杠\\特殊字符失效化: 表示不可打印字符 \\a : alarm,响铃 \\b: backspace, 退格 \\n; 换行 \\r: 回车 \\t: table,制表符 特殊用法,命令分行 本质上是转移 \\n,使之被当作空格处理 引号’ or \\”同样有无效化特殊字符的作用, 在引号内的特殊字符被当作普通字符处理 双引号中,大部分字符失效 $ ` \\ 单引号中, 全部字符意义失效 双引号可以保存命令的输出格式 如多个空格 here文档输入多行字符串 格式 起始: \\&lt;\\&lt; token 结束: token 支持变量拓展，反斜杠拓展，不支持通配符拓展 可以将\\”\\&lt;&lt;token&quot;，放在单引号中，可以使变量拓展失效&gt;{=html} here字符串 \\&lt;\\&lt;&lt;string&gt;{=html} 将命令通过标准输入传递给命令 等同于 echo string | command 优点在于有的命令只能接受标准输入作为参数 # cat# MD5sum变量环境变量自带定义,已经定义好的 printenv env 常见环境变量 BASHPID BASH的进程ID BASHOPTS 当前shell的参数, 可以用`shopt`修改 DISPLAY 图形环境的显示器名字 HOME 用户主目录 HOST 主机名称 IFS 词分割符,默认空格 LANG 字符集和语言编码 PATH 目录列表,可执行程序的搜索路径,包含由冒号分开的目录列表 PS1 Shell提示符 PS2 输入多行命令时,次shell提示符 PWD 工作目录 RANDOM 产生0~(2\\^15-1)之间的一个随机整数 SHELL shell的名字 SHELLOPTS 启动当前shell的set命令参数 TERM 终端类型名 UID 用户ID编号 USER 当前用户用户名 自定义变量用户在当前shell中设立的变量,仅当前shell可用 set命令可查看所有自定义变量和环境变量和所有bash函数 创建变量变量规则 字母+数字+下划线 以字母或者下划线开头 没有空格或者标点符号 读取变量 $,或者${~}读取 变量不存在则返回空字符 ${!varname} 一个变量的值是另一个变量的名字 该公式将其自动展开到最终值 删除变量unset name 将变量值设为空 输出变量exprot NAME 将一个变量设置为环境变量(对于本SHELL和随后创建的 可以同时进行赋值 子shell修改继承值，不影响父shell 特殊变量$?: 上一个命令的退出码,返回为0则成功,否则失败 $$: 当前shell的进程ID $_: 上一个命令的最后一个参数 $!: 最近的一个后台运行的进程的ID $0: 当前shell的名称或者脚本名 $-: 当前shell的启动参数 $@和$# 参数值和参数数量 变量默认值${varname : -word} 如果varname存在且不为空,则返回word ${varname:=word} 不存在时返回word并将该var设为word ${varname:+word} 存在且不为空,返回word,否则空值 ${varname: ?message} 存在且不为空,则返回varvalue,否则打印出message,并中断脚本 Declare命令声明变量,为变量设置限制 -i参数: 声明整数变量 可以直接进行数学运算 一个被解释为整数后,其他的变量自动解释 -x参数:等同于export -r参数: 设置仅可读 无法改变也不能`unset` readonly 命令： 与declare -r等价 -f 变量为函数名 -p 打印所有只读变量 -a 生命的变量为数组 -u参数: 声明变量为大写字母,upper -p参数:输出变量信息,print -f参数: 输出当前环境所有函数,及其定义 -F参数: 同上,单不包括定义 字符串操作字符串长度$#{varname} $#在脚本中表示脚本的参数个数,故大括号是必要的 子字符串${varname:offset:length} 表示截取varname变量中offset位置开始的length长度子串 忽略length则取到末尾 只能操作变量,不能操作字符串 若offset可以为负值, 同样表示对应位置 负号和冒号间必须有空格 否则会和设置变量默认值的语法混淆 此时length可以为负值,表示排除从末尾开始的length个字符 搜索与替换头部识别(从开头开始匹配) ${var#pattern} 删除最短匹配部分,返回剩余 ${var##pattern} 删除最长匹配部分,返回剩余 ${var/#pattern/string} 替换匹配部分 尾部识别 ${var%pattern} 删除最短匹配部分,返回剩余 ${var\\%\\%pattern} 删除最长匹配部分,返回剩余 ${var/%pattern/string} 替换匹配部分 任意位置识别 ${var/pattern/string} 最长匹配部分,仅替换第一个匹配 ${var//pattern/string} 最长匹配部分,但替换所有最长匹配 改变大小写${varname\\^\\^} 转为大写 ${varname,,} 转为小写 算术运算算术表达式((~)); 整数的算术运算 使用$?可以获取算术表达式运行情况 算数结果为0就算执行失败,为1 否则就算成功,为0 支持的运算符 +,-,* /: 整除 %: 余数 **指数 ++:自增 —自减 表达式中可以引用变量,且不需要加$取值符号 若变量为字符串则将其作为空值处理, 为0 也可以使用 let let x=2+3 expr expr $foo+3 进制number: 十进制 0number: 八进制 0xnumber: 十六进制 base#number: base进制 二进制操作\\&lt;\\&lt;/>> digit,位左移/右移运算 乘2**digit &amp;: 二元操作符,对两个数字的所有位执行AND操作 |: 与操作 \\^: 异或操作 逻辑运算\\&lt; > \\&lt;= >= == != &amp;&amp;:与 ||:或 !:否 expr?expr1:expr2 若真则1,若假则2 赋值+= -= *= /= %= \\&lt;\\&lt;= >>= &amp;= |= 求值运算((expr1 , expr2)) 执行两个表达式,返回后面一个的值 行操作快捷键elseCtrl + j：等同于回车键（LINEFEED）。 Ctrl + m：等同于回车键（CARRIAGE RETURN）。 Ctrl + o：等同于回车键，并展示操作历史的下一个命令。 Ctrl + v：将下一个输入的特殊字符变成字面量，比如回车变成\\^M。 Ctrl + [：等同于 ESC。 Alt + .：插入上一个命令的最后一个词。 Alt + _：等同于Alt + .。 快捷键模式Vi快捷键 emacs快捷键 set -o vi/emacs 设置 光标移动Ctrl+A 行首 Ctrl+B 左移一个字符 Ctrl+E 行尾 Ctrl+f 右移一个字符 Alt+f 单词词尾 Alt+b 单词词首 Ctrl+L 清屏 编辑Ctrl+d 删除光标所在位置字符 Ctrl+W 删除删除光标前的字符 Ctrl+t 光标位置的字符与前面一位的字符交换位置 Alt+t 光标位置的词与前面一位的词交换位置 Alt+I 从光标位置到词尾转为小写 Alt+u 将光标位置至词尾转为大写 复制粘贴Ctrl+k 剪切光标位置到行尾的文本 Ctrl+u 剪切光标位置到行首的文本 Alt+d 剪切光标位置到词尾的文本 Alt+Backspace 剪切光标位置到词首的文本 Ctrl+y 粘贴 自动补全Tab: 自动补全 Alt+?: 列出可能的补全 Alt+/:文件路径补全 Alt+I：命令补全 Alt+~：用户名补全 Alt+$: 变量名补全 Alt+@: 主机名补全 Alt+*:一次性插入所有可能的补全 Alt+tab: 尝试用以前的命令的进行补全 操作历史$HISTFILE: 指向/home/me/.bash_history history: 直接输出所有历史,默认储存500条命令 Ctrl+r : 搜索操作历史,选择以前使用过的命令 !~: 表示查找以~开头的、最近的命令 只会匹配命令，不能匹配参数 history环境变量设置 export HISTTIMEFORMAT = ‘%F %T’ 保留执行命令的时间戳 export HISTSIZE=num 设置保存历史操作记录数 export HISTIGNORE=”com1:com2:com3” 设置不保留某些命令的历史 history | grep pattern 模式搜搜 ！number：直接执行对应索引的命令 history -c 清除搜索历史 快捷键 Ctrl+p/n: previous/next 上一条/下一条命令 Alt+ \\&lt;/>; 显示第一条/最后一条命令 Ctrl+ o: 执行历史纪录里的当前条目,并自动显示下一个命令 !快捷键 !!：执行上一个命令。 !n：n为数字，执行历史文件里面行号为n的命令。 !-n：执行当前命令之前n条的命令。 !string：执行最近一个以指定字符串string开头的命令。 !?string：执行最近一条包含字符串string的命令。 !$：代表上一个命令的最后一个参数。 !*：代表上一个命令的所有参数，即除了命令以外的所有部分。 \\^string1\\^string2：执行最近一条包含string1的命令，将其替换成string2。","categories":[{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"Git命令学习笔记","slug":"Git命令学习笔记","date":"2021-10-05T04:17:09.000Z","updated":"2023-06-09T12:13:21.499Z","comments":true,"path":"2021/10/05/Git命令学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2021/10/05/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本命令1234567891011121314151617181920212223242526272829303132333435363738394041424344# 安装Git$ sudo apt install git# 配置个人信息$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;# 切换目录初始化$ git init# 文件添加到仓库$ git add -p &lt;file&gt;# 把文件提交到仓库$ git commit -m &quot;add LICENSE&quot;# 查看仓库当前状态$ git status# 查看difference$ git diff# 显示从最近到最远的提交日志$ git log --pretty=oneline # 格式化输出信息# 版本退回$ git reset --hard HEAD^ # 当前版本HEAD,上一个版本HEAD^,上上个版本HEAD^^$ git reset --hard 130f10a # 或HEAD~100# 查看命令记录$ git reflog# 丢弃工作区的修改，回到最近一次git commit或git add时的状态：$ git checkout -- README.md# 把暂存区的修改撤销掉（unstage）$ git reset HEAD READER.md# 从版本库中删除该文件$ git rm README.md$ git commit -m &quot;remove READER.md&quot;# 把误删的文件恢复到最新版本，checkout其实用版本库里的版本替换工作区的版本$ git checkout -- README.md 远程仓库123456789101112131415$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;# 测试是否成功$ ssh -T git@github.com# 把一个已有的本地仓库与之关联$ git remote add origin git@github.com:Windrivder/Windrivder.git# 把本地库的所有内容推送到远程库上（推送master分支的内容）$ git push -u origin master# 向远程库推送更新$ git push origin master# 从远程库克隆$ git clone git@github.com:michaelliao/gitskills.git 分支管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# 创建+切换dev分支$ git checkout -b dev# 相当于$ git branch dev # 创建分支$ git checkout dev# 查看当前分支，当前分支前面标有×号$ git branch# 切换回master分支$ git checkout master# 合并指定分支到当前分支$ git merge dev# 删除dev分支$ git branch -d dev# 查看分支合并情况$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test# 删除feature1分支$ git branch -d feature1# 创建并切换dev分支$ git checkout -b dev# 修改readme.txt文件，并提交一个新的commit$ git add readme.txt$ git commit -m &quot;add merge&quot;# 切换回master$ git checkout master# 合并dev分支，请注意--no-ff参数，表示禁用Fast forward$ git merge --no-ff -m &quot;merge with no-ff&quot; dev# 看看分支历史$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\\| * 6224937 add merge|/* 59bc1cb conflict fixed# 如果需要临时修复Bug，可以把当前工作现场“储藏”起来，等Bug修复后恢复现场后继续工作$ git stash# 此时查看工作区是干净# 切换到需要修复Bug的分支，创建临时分支来修复$ git checkout master$ git checkout -b issue-101# 修复完成后切换到master分支，完成合并，删除临时分支$ git checkout master$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101$ git branch -d issue-101# Bug修复后，切换回dev分支继续干活$ git checkout dev# 查看工作现场列表$ git stash list# 恢复工作现场$ git stash pop # 恢复的同时把stash内容也删了$ git stash apply # 恢复，不删除stash的内容，使用git stash drop# 再次查看工作现场列表，干净$ git stash list# 可以多次stash，恢复时指定恢复$ git stash apply stash@&#123;0&#125;# 强行删除一个没有合并过的分支$ git branch -D &lt;name&gt;# 要查看远程库的信息$ git remote$ git remote -v# 推送其他分支$ git push origin dev# 从远程库clone，默认情况只能看到master分支，需要在dev分支，必须创建远程origin的dev分支到本地$ git checkout -b dev origin/dev$ git checkout -b branch-name origin/branch-name$ git branch --set-upstream branch-name origin/branch-name # 关联# 向远程库推送dev有冲突$ git pull # 抓取到本地合并解决冲突，再向远程推送$ git push origin dev 标签管理1234567891011121314151617181920212223242526272829303132# 切换到需要打标签的分支$ git branch$ git checkout master# 创建标签$ git tag v1.0# 查看所有标签$ git tag# 给历史提高的commit id打标签$ git log --pretty=oneline --abbrev-commit # 查看commit id$ git tag v0.9 6224937# 查看标签信息$ git show v0.9# 创建带有说明的标签$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164# 用PGP签名标签$ git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;# 推送某个标签到远程$ git push origin v1.0# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags# 删除远程标签$ git tag -d v0.9 # 删除本地$ git push origin :refs/tags/v0.9 # 删除远程 自定义git12345678910111213141516171819# 显示颜色，会让命令输出看起来更醒目$ git config --global color.ui true# 忽略某些文件时，需要编写.gitignore，然后将.gitignore放到版本库中# st就表示status$ git config --global alias.st status# 配置一个unstage别名$ git config --global alias.unstage &#x27;reset HEAD&#x27;$ git unstage test.py # 等价于$ git reset HEAD test.py# 显示最后一次提交信息$ git config --global alias.last &#x27;log -1&#x27;# loggit config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;# 每个仓库的配置文件放在.git/config# 当前用户的配置文件放在用户主目录下的一个隐藏文件.gitconfig中 遇到的问题PROBLEM 1 ~ HEAD detached from 72e863c这个问题的起因是我直接使用了命令checkout到了远程分支, 从而导致HEAD指向了匿名分支; 12345git checkout origin/maingit add .git commit -m &quot;refrac[readme]:add shiny app url&quot;git pushgit push origin HEAD:main 匿名分支 解决办法查看: 解决办法 fatal: refusing to merge unrelated histories12345678$ git statusOn branch masterYour branch and &#x27;origin/master&#x27; have diverged,and have 13 and 1 different commits each, respectively. (use &quot;git pull&quot; to merge the remote branch into yours)$ git pullfatal: refusing to merge unrelated histories 解决办法: 1git pull --allow-unrelated-histories 多余分支 由于本地的分支名默认为master, 而bitbucket上显示的为main, 故而git push默认将本地修改上传到了master分支而非main分支; 因此我们需要删除远程分支orgin/master,将本地分支重命名为main, 参照这里; 重命名本地分支: 在当前分支时git branch -m new_branch_name; 当不在当前分支时git branch -m old_branch_name new_branch_name; 重命名远端分支（假设是在当前分支，并且远端分支与本地分支名是一致的）: 重命名本地分支:git branch -m new_branch_name 删除远程分支git push --delete origin old_branch_name 上传新命名的本地分支:git push origin new_branch_name 关联修改后的本地分支与远程分支git branch --set-upstream-to origin/new_branch_name","categories":[{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"}],"tags":[{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"}]},{"title":"RstudioServer环境配置","slug":"RstudioServer环境配置","date":"2021-09-15T03:18:24.000Z","updated":"2023-06-09T12:10:16.904Z","comments":true,"path":"2021/09/15/RstudioServer环境配置/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2021/09/15/RstudioServer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1. Rstudio-Server的安装：12345sudo apt install -y r-basesudo apt install -y gdebi-core wget https://download2.rstudio.org/rstudio-server-1.1.383-amd64.debsudo gdebi rstudio-server-1.1.383-amd64.debrstudio-server start 使用自己的账户和密码即可在 ip+:+port(8787)登录 2. 布置内网穿透: 登录Sunny-Ngrok Sunny-Ngrok内网转发内网穿透 - 国内内网映射服务器： 开通隧道： 下载sunny linux 64 bit：Sunny-Ngrok内网转发 解压 unzip linux_amd64.zip ./sunny clientid 171556355325打开 Forwarding对应网址即可直接打开； 3. SSH+Xming图形化界面打开： 下载putty putty-64bit-0.76-installer.msi 点击安装，一路确认； PuTTYgen生成新的密钥 红圈为公钥，复制；蓝圈为私钥，保存； 在默认的 /home/.ssh/目录下创建 authorized_keys文件，将上一步复制好的公钥复制到该文件中； 设置 .ssh authorized_keys权限 12chmod 600 authorized_keys[root@host .ssh]$ chmod 700 ~/.ssh 设置 SSH，打开密钥登录功能 12345sudo vim /etc/ssh/sshd_config ###/etc/ssh/sshd_config RSAAuthentication yesPubkeyAuthentication yesPermitRootLogin yes 重启服务 1[root@host .ssh]$ service sshd restart 此时使用如下代码应当可以直接成功,如果不行则重启虚拟机和主机再试. 1ssh host_name@host_ip 安装xwindows组件 1sudo apt-get install x-window-system-core 主机内下载xmingXming X Server for Windows download | SourceForge.net 安装之后打开，进入ssh，输入firefox &amp;即可打开浏览器，并直接用Ip：port进入Rstudio-server(因为实际上用的是host的浏览器) 4. TightvncViewer5. 可能出现的错误：1. 密钥登录Server refused our key12chmod 600 authorized_keys chmod 700 /root/.ssh 首先第一步需要确保权限设置正确； 1sudo chown $USER:$USER ~/.ssh -R home、end、pgup、pgdn为什么都会变成小键盘的数字82467193。切换输入法，回到微软的自带的英文输入","categories":[{"name":"problem solving","slug":"problem-solving","permalink":"https://github.com/Molaison/Molaison.github.io/categories/problem-solving/"}],"tags":[{"name":"data analysis","slug":"data-analysis","permalink":"https://github.com/Molaison/Molaison.github.io/tags/data-analysis/"}]},{"title":"R语言学习笔记","slug":"R语言学习笔记","date":"2021-02-05T04:17:09.000Z","updated":"2023-06-09T12:11:32.066Z","comments":true,"path":"2021/02/05/R语言学习笔记/","link":"","permalink":"https://github.com/Molaison/Molaison.github.io/2021/02/05/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Tidyversedplyr包: 数据转换数据和包载入123library(nycflights13)library(tidyverse)nycflights13::flights 基础函数以下5个函数参数相同: 第一个参数为数据框; 随后参数使用变量名称(不带引号)描述操作; 返回一个新的数据框; filter(): 按值筛选基于筛选条件筛选出观测子集: 1234subset &lt;- filter(parentset, colname_1 == x_1, colname_2 == x_2)#筛选出第一列中值为x_1,和第二列中值为x_2的行(subset &lt;- filter(parentset, colname_1 == x_1, colname_2 == x_2))#在console中直接显示结果同时将值储存进subset 基于比较符123456789101112subset &lt;- filter(parentset, colname_1 &gt;= x_1, colname_2 &lt;= x_2)#比较运算符有: &gt;,&lt;,&lt;=,&gt;=,!=,==#对于浮点数sqrt(2)^2 == 2 #FALSE1/49*49 == 1 #FALSE#通常使用near()函数near(sqrt(2)^2,2) #TRUE#对于区间subset &lt;- filter(parentset, between(colname_1,3,9))#选出位于区间(3,9)之间的colname值 基于逻辑符1234subset &lt;- filter(parentset, colname_1 &gt;= x_1|colname_1 &gt;= x_3)#或subset &lt;- filter(parentset, colname_1 &gt;= x_1&amp;colname_1 &gt;= x_3)#与subset &lt;- filter(parentset, !(colname_1 &gt;= x_1))#非subset &lt;- filter(parentset, colname_1 %in% c(x_1,x_2)) 缺失值 缺失值 : 称为NA（Not available，不可用） 对于缺失值的操作也都是缺失值（大多数情况）； 12345NA == NA# 值为NAx = NA;is.na(x)#TRUE 在筛选器中,为NA值得行和条件为FALSE的行会被过滤,如果需要保留; 1subset &lt;- filter(parentset,is.na(colname_1)|colname_1 &gt;= x_3) 其他NA特殊操作的值: 123NA^0 #=0NA|TRUE #TRUENA*0 #=NA arrange(): 对行排序12345subset &lt;- arrange(parentset, col_1, col_2, col_3)#首先根据列1排序,再对列2排序,表示如果数据在“变量1”的值相同时按照“变量2”排序subset &lt;- arrange(parentset, desc(col_1), col_2, col_3)#desc()函数使之降序排列,即descend#缺失值无论降序还是升序,总是在最后 select(): 按名称选取123456subset &lt;- select(parentset, col_1, col_2, col_3)#选取第1,2,3列subset &lt;- select(parentset, col_1:col_3)#也是选取1:3列subset &lt;- select(parentset, -(col_1:col_3))#选取不在1:3列间的列 辅助函数12345678910starts_with(str): #以str开头的名称end_with(str): #以str结尾的名称contains(str):#包含str的名称matches(pattern):#匹配正则pattern的名称num_range(&quot;X&quot;,1:4):#匹配 &#123;X1, X2, X3, X4 &#125;,神技#会默认忽略大小写,如果要区分大小写，可以设置任意帮助函数的参数ignore.case = FALSE select可以重命名变量,但是会丢失其他变量: 12subset &lt;- select(parentset, newname=oldname) 使用select的变体可以保留其他变量 1rename(parentset, newname=oldname) 也可以使用everything()函数进行列排序: 12subset &lt;- select(parentset, col5,col3,everything())#原顺序为1,2,3,4,5,现在为5,3,1,2,4 one_of(character_1,···,character_n):如果某个列的名字出现在序列里，则选出它 mutate(): 使用函数创建新变量1subset &lt;- mutate(parentset, newcol1=col1/col2,newcol2=new1/col1) 上述代码产生了两个新列, 总是加在数据框最后 新列按顺序产生, 列一经产生即可使用(new2使用了new1) 运算法则: 加减乘除 “+”, “-”,”*”,”/”,”^” 模运算:”%/%”整除,”%%”求余 对数:log(),log2(),log10(); 偏移函数:lead(),lag(),前移或者后移一位 累加,滚动聚合: 累加和,积,最小值,最大值:cumsum(), cumprod(), cummin(),cummax() 1transmute(parentset, newcol1=col1/col2,newcol2=new1/col1) 只保留新的变量; summarize(): 摘要统计量summarize()，它可以将数据框折叠成一行： 12345summarize(flights, delay = mean(dep_delay, na.rm = TRUE))#&gt; # A tibble: 1 × 1#&gt; delay#&gt; &lt;dbl&gt;#&gt; 1 12.6 group_by() 可以将分析单位从整个数据集更改为单个分组. 12345678910111213by_day &lt;- group_by(flights, year, month, day)summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))#&gt; Source: local data frame [365 x 4]#&gt; Groups: year, month [?]#&gt;#&gt; year month day delay#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;#&gt; 1 2013 1 1 11.55#&gt; 2 2013 1 2 13.86#&gt; 3 2013 1 3 10.99#&gt; 4 2013 1 4 8.95#&gt; 5 2013 1 5 5.73#&gt; 6 2013 1 6 7.15 管道操作符即: “%&gt;%”, 将返回值传递给管道符后的操作函数作为输入,通常可读作然后: 12345678delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarize( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) 缺失值忽略参数na.rm=TRUE参数可以在计算前除去缺失值; 计数参数即n(), 它的值是操作单位中值的个数; 常见摘要函数位置: median()和mean()12345678not_cancelled %&gt;%group_by(year, month, day) %&gt;%summarize(# 平均延误时间：avg_delay1 = mean(arr_delay),# 50%的x大于它，同时50%的x小于它。avg_delay2 = median(arr_delay)) 分散程度: sd(x)、IQR(x) 和mad(x)分别是标准差, 四分位距, 绝对中位差; 123not_cancelled %&gt;%group_by(dest) %&gt;%summarize(distance_sd = sd(distance)) 秩: min(x)、quantile(x, 0.25) 和max(x)123456not_cancelled %&gt;%group_by(year, month, day) %&gt;%summarize(first = min(dep_time),last = max(dep_time)) 定位度量：first(x)、nth(x, 2) 和last(x)和索引取值的区别在于,当定位不存在时取默认值位置; 12345not_cancelled %&gt;%group_by(year, month, day) %&gt;%summarize(first_dep = first(dep_time),last_dep = last(dep_time)) 计数:count()唯一值计数: 1n_distinct(); 加权计数: 1count(df , wt= weight)#weight可以是其他列或者别的权重 逻辑值计数: sum(x&gt;a)和mean(x==0)sum()使用逻辑表达式计数可以计算true值的个数; 而mean则可以直接获得比例,因为true值为1,FALSE为0; 按多个变量分组当使用多个变量进行分组时，每次的摘要统计会==用掉一个分组变量==。 123456789101112131415161718192021222324252627282930daily &lt;- group_by(flights, year, month, day)(per_day &lt;- summarize(daily, flights = n()))#&gt; Source: local data frame [365 x 4]#&gt; Groups: year, month [?]#&gt;#&gt; year month day flights#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;#&gt; 1 2013 1 1 842#&gt; 2 2013 1 2 943#&gt; 3 2013 1 3 914#&gt; 4 2013 1 4 915#&gt; 5 2013 1 5 720#&gt; 6 2013 1 6 832#&gt; # ... with 359 more rows(per_month &lt;- summarize(per_day, flights = sum(flights)))#&gt; Source: local data frame [12 x 3]#&gt; Groups: year [?]#&gt;#&gt; year month flights#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;#&gt; 1 2013 1 27004#&gt; 2 2013 2 24951#&gt; 3 2013 3 28834#&gt; 4 2013 4 28330#&gt; 5 2013 5 28796(per_year &lt;- summarize(per_month, flights = sum(flights)))#&gt; # A tibble: 1 × 2#&gt; year flights#&gt; &lt;int&gt; &lt;int&gt;#&gt; 1 2013 336776 但是取加权平均或者方差或者中位数时,很容易出错,因为对整体取中位数和分组取中位数在取中位数完全不同; 可以用ungroup()取消分组 tibble数据框创建tibble数据框123as_tibble(df)#从普通数据框转换tibble(x=vector,y=vector,z=vector)#直接创建 tibble相比较data.frame: 不能改变输入的类型（例如，不能将字符串转换为因子）、变量的名称，也不能创建行名称。 可以在tibble 中使用在R 中无效的变量名称（即不符合语法的名称)作为列名,需要使用反引号` 将它们括起来 12345tb &lt;- tibble(`:)` = &quot;smile&quot;,` ` = &quot;space&quot;,`2000` = &quot;number&quot;) transposed tibble: 列标题由公式（以~ 开头）定义，数据条目以逗号分隔，对少量数据进行布局 12345678910tribble( ~x, ~y, ~z, #--|--|---- &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5)#&gt; # A tibble: 2 × 3#&gt; x y z#&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;#&gt; 1 a 2 3.6#&gt; 2 b 1 8.5 打印tibble()123456789101112131415161718192021tibble(a = lubridate::now() + runif(1e3) * 86400,b = lubridate::today() + runif(1e3) * 30,c = 1:1e3,d = runif(1e3),e = sample(letters, 1e3, replace = TRUE))#&gt; # A tibble: 1,000 × 5#&gt; a b c d e#&gt; &lt;dttm&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;#&gt; 1 2016-10-10 17:14:14 2016-10-17 1 0.368 h#&gt; 2 2016-10-11 11:19:24 2016-10-22 2 0.612 n#&gt; 3 2016-10-11 05:43:03 2016-11-01 3 0.415 l#&gt; 4 2016-10-10 19:04:20 2016-10-31 4 0.212 x#&gt; 5 2016-10-10 15:28:37 2016-10-28 5 0.733 a#&gt; 6 2016-10-11 02:29:34 2016-10-24 6 0.460 v#&gt; # ... with 994 more rowsnycflights13::flights %&gt;% print(n = 10, width = Inf)#width显示宽度,n为行数#可通过设置选项(option)控制默认打印方式options(tibble.print_max = n, tibble.print_min = m) 取子集12345678910111213df &lt;- tibble( x = runif(5), y = rnorm(5) )df$x #$只能通过名字提取df[[&quot;x&quot;]]df[[1]]# 双中括号既可以按名称也可以按位置#与管道符结合df %&gt;% .$x #.为占位符,功能如其名#&gt; [1] 0.434 0.395 0.548 0.762 0.254df %&gt;% .[[&quot;x&quot;]]#&gt; [1] 0.434 0.395 0.548 0.762 0.254 readr读取文件 csv文件: read_csv()读取逗号分隔文件、read_csv2() 读取分号分隔文件（这在用, 表示小数位的国家非常普遍）、read_tsv() 读取制表符分隔文件、read_delim() 可以读取使用任意分隔符的文件。 read_fwf() 读取固定宽度的文件。既可以使用fwf_widths() 函数按照宽度来设定域，也可以使用fwf_positions() 函数按照位置来设定域。read_table() 读取固定宽度文件的一种常用变体，其中使用空白字符来分隔各列。 参数direction: 绝对or相对路径 1234heights &lt;- read_csv(&quot;data/heights.csv&quot;)read_csv(&quot;a,b,c1,2,34,5,6&quot;)#也可以读取行内CSV文件,换行不能省! skip = n:跳过前N行: comment = char: 丢弃所有以char开头的行,即将其注释掉 col_names = FALSE: 不使用数据的第一行作为列名称(默认为TRUE. 标注为X1 X2 X3 ….;或者使用向量为其命名; 1read_csv(&quot;1,2,3\\n4,5,6&quot;, col_names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)) 解析向量 parse_*() 函数族: 接受一个字符向量，并返回一个特定向量，如逻辑、整数或日期向量： 1parse_integer(c(&quot;1&quot;, &quot;231&quot;, &quot;.&quot;, &quot;456&quot;), na = &quot;.&quot;)#&quot;na=&quot;哪些字符串应该当作缺失值来处理 解析失败的值在输出中是以缺失值的形式存在的 problems() 函数来获取完整的失败信息集合(tibble) parse_double()解析浮点数,，parse_number() 则是灵活的数值型解析函数。 12345parse_double(&quot;1,23&quot;, locale = locale(decimal_mark = &quot;,&quot;))#“地区&quot;根据地区设置解析选项parse_number(&quot;123.456.789&quot;,locale = locale(grouping_mark = &quot;.&quot;)) 1234567#parse_number()忽略数值前后的非数值型字符parse_number(&quot;$100&quot;)#&gt; [1] 100parse_number(&quot;20%&quot;)#&gt; [1] 20parse_number(&quot;It cost $123.45&quot;)#&gt; [1] 123 parse_character(): charToRaw()获得字符串ASCII编码 设定编码方式 1234parse_character(x1, locale = locale(encoding = &quot;Latin1&quot;))#&gt; [1] &quot;El Niño was particularly bad this year&quot;parse_character(x2, locale = locale(encoding = &quot;Shift-JIS&quot;))#&gt; [1] &quot;こんにちは&quot; 未知编码方式: 1234567guess_encoding(charToRaw(x1))#&gt; encoding confidence#&gt; 1 ISO-8859-1 0.46#&gt; 2 ISO-8859-9 0.23guess_encoding(charToRaw(x2))#&gt; encoding confidence#&gt; 1 KOI8-R 0.42 parse_factor(): R 使用因子表示取值范围是已知集合的分类变量。 12345678910111213fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;)parse_factor(c(&quot;apple&quot;, &quot;banana&quot;, &quot;bananana&quot;), levels = fruit)#&gt; Warning: 1 parsing failure.#&gt; row col expected actual#&gt; 3 -- value in level set bananana#&gt; [1] apple banana &lt;NA&gt;#&gt; attr(,&quot;problems&quot;)#&gt; # A tibble: 1 × 4#&gt; row col expected actual#&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;#&gt; 1 3 NA value in level set bananana#&gt; Levels: apple banana#存在向量中没有的值，生成一条警告 时间解析: parse_datetime(): 12parse_datetime(&quot;2010-10-01T2010&quot;)#&gt; [1] &quot;2010-10-01 20:10:00 UTC&quot; parse_date(): 12parse_date(&quot;2010-10-01&quot;)#&gt; [1] &quot;2010-10-01&quot; parse_time(): 123library(hms)parse_time(&quot;20:10:01&quot;)#&gt; 20:10:01 自定义格式 12345678910111213141516171819202122232425parse_date(&quot;01/02/15&quot;, &quot;%m/%d/%y&quot;)年#%Y（4 位数）。#%y（2 位数；00-69 → 2000-2069、70-99 → 1970-1999）。月#%m（2 位数）。#%b（简写名称，如Jan）。#%B（完整名称，如January）。日#%d（1 位或2 位数）。#%e（2 位数）时间#%H（0-23 小时）。#%I（0-12 小时，必须和%p 一起使用）。#%p（表示a.m./p.m.）。#%M（分钟）。#%S（整数秒）。#%OS（实数秒）。#%Z（时区，America/Chicage 这样的名称）。注意，要当心缩写。如果你是美国人，注意#EST 是加拿大没有夏时制的一个时区。它表#示东部标准时间！我们还会在12.5 节中继#续讨论这个话题。#%z（与国际标准时间的时差，如+0800）。#非数值字符#%.（跳过一个非数值字符）。#%*（跳过所有非数值字符）。 解析文件ggplot2基础图画绘制数据（Data）和映射（Mapping）数据要求用于绘制图形的data frame或者tibble. 映射aes()函数是ggplot2中的映射函数, 所谓的映射即为数据集中的数据关联到相应的图形属性过程中一种对应关系, 图形的颜色，形状，分组等都可以通过通过数据集中的变量映射。 将钻石数据集中克拉和价格映射为X,Y轴变量: 1p &lt;- ggplot(data = diamond, mapping = aes(x = carat, y = price)) #将钻石的颜色（color）映射颜色属性： 12p &lt;- ggplot(data=diamond, mapping=aes(x=carat, y=price, shape=cut, colour=color))p+geom_point() #绘制点图 #将钻石的切工（cut）映射到形状属性： 12p &lt;- ggplot(data=diamond, mapping=aes(x=carat, y=price, shape=cut))p+geom_point() #绘制点图 #将钻石的切工（cut）映射到分组属性： 1234#默认分组设置, 即group=1p + geom_boxplot()#分组(group)也是ggplot2种映射关系的一种, 如果需要把观测点按额外的离散变量进行分组处理, 必须修改默认的分组设置。p1 &lt;- ggplot(data=diamond, mapping=aes(x=carat, y=price, group=factor(cut)))p1 + geom_boxplot() 几何对象（Geometric）直方图单变量连续变量：可绘制直方图展示，提供一个连续变量，画出数据的分布。 12ggplot(diamond)+geom_histogram(aes(x=price, fill=cut))#以价格（price）变量为例，且按照不同的切工填充颜色(即一个直方内有不同颜色的切工块) 12ggplot(diamond)+geom_histogram(aes(x=price, fill=cut), position=&quot;dodge&quot;)#dodge选项使得原本纵向分布的&quot;切工&quot;块变为并列显示 12ggplot(diamond)+geom_histogram(aes(x=price, fill=cut), position=&quot;fill&quot;)#设置使用position=&quot;fill&quot;，按相对比例画直方图,可以显示不同价格时,各切工所占比例 柱状图单变量分类变量：可使用柱状图展示，提供一个x分类变量，画出数据的分布。 123ggplot(diamond)+geom_bar(aes(x=clarity, fill=cut))#以透明度（clarity）变量为分类，且按照不同的切工填充颜色#ggplot自动计算分类数 箱式图箱线图: 通过绘制观测数据的五数总括，即最小值、下四分位数、中位数、上四分位数以及最大值，描述了变量值的分布情况。 12ggplot(diamond)+geom_boxplot(aes(x=cut, y=price,fill=color))#按切工(cut)分类，对价格(price)变量画箱式图，再按照color变量分别填充颜色。 标尺（Scale）在对图形属性进行映射之后，使用标尺可以控制这些属性的显示方式，比如坐标刻度，颜色属性等。 scale函数命名通式: 一般使用三个单词用”_”连接: 第一个都是scale 第二个是color fill x y linetype shape size等可更改的参数 第三个是具体的类型. 颜色标尺第二个参数对于颜色scale函数,第二个有两个参数, 一个是fill,主要是指填充颜色;另一个是color,指点或者线的颜色; 第三个参数根据数据为离散型还是连续性决定; 1）离散型：在颜色变量是离散变量的时候使用，比如分类时每一类对应一种颜色 manual 直接指定分组使用的颜色 hue 通过改变色相（hue）饱和度（chroma）亮度（luminosity）来调整颜色 brewer 使用ColorBrewer的颜色 grey 使用不同程度的灰色 manual 参数: 123p+scale_fill_manual(values=c(&quot;red&quot;, &quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;orange&quot;))p+scale_fill_manual(values=c(&quot;Fair&quot;=&quot;red&quot;,&quot;Good&quot; = &quot;blue&quot;, &quot;Very Good&quot; = &quot;green&quot;, Premium = &quot;orange&quot;, Ideal = &quot;yellow&quot;))p + scale_fill_manual(&quot;class&quot;, values=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;yellow&quot;,&quot;orange&quot;),breaks = c(&quot;Fair&quot;, &quot;Good&quot;, &quot;Very Good&quot;,&quot;Premium&quot;,&quot;Ideal&quot;),labels = c(&quot;一般&quot;, &quot;好&quot;, &quot;很好&quot;, &quot;高级&quot;, &quot;理想&quot;)) brewer 使用ColorBrewer的颜色: 1234567library(RColorBrewer)#主要是palette参数调用色板p + scale_fill_brewer() # 默认使用Blues调色板中的颜色p + scale_fill_brewer(palette = &quot;Greens&quot;) #使用Greens调色板中的颜色p + scale_fill_brewer(palette = &quot;Greens&quot;,direction = -1) direction参数决定颜色顺序, 为-1则反着来; grey 使用不同程度的灰色: 通过start end 两个参数指定，0为黑，1为白，都在0-1范围内 1234p + scale_fill_grey() #设定灰度范围p + scale_fill_grey(start=1, end=0) p + scale_fill_grey(start=1, end=0.5) 2）连续型：颜色变量是连续变量的时候使用，比如0-100的数，数值越大颜色越深这样 gradient 创建渐变色 distiller 使用ColorBrewer的颜色 identity 使用color变量对应的颜色，对离散型和连续型都有效 12df &lt;- data.frame(x = runif(100),y = runif(100),z1 = rnorm(100))p &lt;- ggplot(df, aes(x, y)) + geom_point(aes(colour = z1)) gradient 创建渐变色#参数设定节点颜色: 123456789#设置两端颜色p + scale_color_gradient(low = &quot;white&quot;, high = &quot;black&quot;)#设置中间过渡色p + scale_color_gradient2(low = &quot;red&quot;, mid = &quot;white&quot;, high = &quot;blue&quot;)#使用R预设调色板p + scale_color_gradientn(colours =rainbow(10))#legeng展示指定标签p + scale_color_gradient(low = &quot;white&quot;, high = &quot;black&quot;, breaks=c(1,2,0.5), labels=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))#legend名称p + scale_color_gradient(&quot;black&quot;, low = &quot;white&quot;, high = &quot;black&quot;, limits=c(0.5,2)) distiller 使用ColorBrewer的颜色: 12p + scale_color_distiller(palette = &quot;Spectral&quot;)p + scale_color_distiller(palette = &quot;Greens&quot;) 坐标轴尺度修改参数与上类似,第一个参数为scale, 然后是x,y表明对哪个轴操作,最后是详细操作; 更改坐标轴名称 更改x轴上标数的位置和内容 显示对一个轴做统计变换 只展示一个区域内的点 更改刻度标签的位置 12345678# 横坐标是离散变量，纵坐标是连续变量p &lt;- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_point()# 更改坐标轴名称p + scale_x_discrete(&quot;cyl&quot;)# 更改横轴标度p + scale_x_discrete(labels = c(&quot;4&quot;=&quot;a&quot;,&quot;6&quot;=&quot;b&quot;,&quot;8&quot;=&quot;c&quot;))# 指定横轴顺序以及展示部分p + scale_x_discrete(limits=c(&quot;6&quot;,&quot;4&quot;)) 123456789101112# 连续变量可以更改标度（图与上相似，略）p + scale_y_continuous(&quot;ylab_mpg&quot;)p + scale_y_continuous(breaks = c(10,20,30))p + scale_y_continuous(breaks = c(10,20,30), labels=scales::dollar)p + scale_y_continuous(limits = c(10,30))# 连续变量可以更改标度，还可以进行统计变换p + scale_y_reverse() # 纵坐标翻转，小数在上面，大数在下面p + scale_y_log10()p + scale_y_continuous(trans = &quot;log10&quot;)p + scale_y_sqrt()# 更改刻度标签的位置p + scale_x_discrete(position = &quot;top&quot;) + scale_y_continuous(position = &quot;right&quot;)","categories":[{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"}],"tags":[{"name":"data analysis","slug":"data-analysis","permalink":"https://github.com/Molaison/Molaison.github.io/tags/data-analysis/"}]}],"categories":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"https://github.com/Molaison/Molaison.github.io/categories/basic-knowledge/"},{"name":"skill learning","slug":"skill-learning","permalink":"https://github.com/Molaison/Molaison.github.io/categories/skill-learning/"},{"name":"problem solving","slug":"problem-solving","permalink":"https://github.com/Molaison/Molaison.github.io/categories/problem-solving/"}],"tags":[{"name":"biology","slug":"biology","permalink":"https://github.com/Molaison/Molaison.github.io/tags/biology/"},{"name":"computer science","slug":"computer-science","permalink":"https://github.com/Molaison/Molaison.github.io/tags/computer-science/"},{"name":"machine learning","slug":"machine-learning","permalink":"https://github.com/Molaison/Molaison.github.io/tags/machine-learning/"},{"name":"data analysis","slug":"data-analysis","permalink":"https://github.com/Molaison/Molaison.github.io/tags/data-analysis/"}]}