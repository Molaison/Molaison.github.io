<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash学习笔记</title>
    <url>/2021/12/17/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>-n ：取消echo输出文本末尾的回车符</p>
<p>-e：解释单双引号的特殊字符，否则默认直接输出</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>空格和tab符被用于分割不同的参数，如有多个，也只识别成一个</p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>命令的结束符；</p>
<p>可以使一行多个命令</p>
<p>从左到右执行，前面的命令失败与否不影响第二个命令执行</p>
<h3 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h3><p>cmd1&amp;&amp;cmd2: 如果第一个cmd执行成功则运行第二个</p>
<p>cmd1||cmd2：如果第一个失败则运行第二个</p>
<h3 id="type命令"><a href="#type命令" class="headerlink" title="type命令"></a>type命令</h3><p>判断命令为内置命令（shellbuiltin）还是外部程序（hashed）</p>
<p>-a参数：查看一个命令的所有定义；</p>
<ul>
<li>因为同一个命令可以有多个程序实现，内部的或者外部的</li>
</ul>
<p>-t参数：返回一个命令的类型</p>
<ul>
<li><p>alias</p>
</li>
<li><p>keyword</p>
</li>
<li><p>function</p>
</li>
<li><p>builtin</p>
</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>Ctr+L：清屏</p>
<p>Ctr+C：中止命令</p>
<p>Shift+Pageup/down：上/下滚动</p>
<p>Ctr+U：从当前位置删除到行首</p>
<p>Ctr+K：从当前位置删除到行尾</p>
<p>Ctr+W：删除光标位置前一个单词</p>
<p>Ctr+D：关闭Shell对话</p>
<p>Tab：自动补全，双击获得全部备选项</p>
<h2 id="模式拓展"><a href="#模式拓展" class="headerlink" title="模式拓展"></a>模式拓展</h2><h3 id="Shopt命令"><a href="#Shopt命令" class="headerlink" title="Shopt命令"></a>Shopt命令</h3><p>调节Bash行为的命令</p>
<ul>
<li><p>shopt -s [opt]打开选项</p>
</li>
<li><p>shopt -u [opt]关闭选项</p>
</li>
<li><p>shopt [opt]查询打开或者关闭</p>
</li>
</ul>
<p>参数;</p>
<ul>
<li><p>dotglob : 意为”.”开头的文件,也即包括隐藏文件与否</p>
</li>
<li><p>nullglob : 让通配符匹配失败时返回空字符, 而非通配符对应字符串</p>
</li>
<li><p>failglob : 当匹配失败时,直接返回错误, 避免命令处理该字符串</p>
</li>
<li><p>extglob : 支持量词语法</p>
</li>
<li><p>nocaseglob : 让通配符不区分大小写</p>
</li>
<li><p>globstar : 支持 “**“拓展,可以匹配任意多级目录</p>
</li>
</ul>
<h3 id="波浪线拓展"><a href="#波浪线拓展" class="headerlink" title="波浪线拓展"></a>波浪线拓展</h3><p>自动拓展成当前用户主目录</p>
<p>~user拓展成当前用户主目录</p>
<ul>
<li><p>~foo: /home/foo</p>
</li>
<li><p>~root: /root</p>
</li>
</ul>
<p>~+: 拓展成当前目录,等于pwd</p>
<h3 id="字符拓展"><a href="#字符拓展" class="headerlink" title="? 字符拓展"></a>? 字符拓展</h3><p>匹配任意单字符</p>
<p>可以多个连用</p>
<h3 id="字符拓展-1"><a href="#字符拓展-1" class="headerlink" title="*字符拓展"></a>*字符拓展</h3><p>匹配任意数量的任意字符</p>
<p>可以匹配零个字符</p>
<p>特殊用法</p>
<ul>
<li><p>匹配隐藏文件</p>
</li>
<li><p>通配符: “.*“</p>
</li>
<li><p>匹配子目录文件</p>
</li>
<li><p>*只能匹配当前目录</p>
</li>
<li><p>“*/“再加上通配符可以匹配子目录,有几层子目录就写几层</p>
</li>
<li><p>“**/“可以匹配零个或者多个子目录</p>
</li>
</ul>
<h3 id="方括号拓展"><a href="#方括号拓展" class="headerlink" title="方括号拓展"></a>方括号拓展</h3><p>匹配[~]内包含的单个字符</p>
<p>\^!否定：</p>
<ul>
<li><p>[!~]或者[\^~]都可以表示否定</p>
</li>
<li><p>匹配不在方括号中的字符</p>
</li>
</ul>
<p>“-“字符：</p>
<ul>
<li><p>[start-end]型用法,匹配一个连续的区间</p>
</li>
<li><p>[a-z]:字母表</p>
</li>
<li><p>[0-9]:数字</p>
</li>
<li><p>由于会造成误识别为链接用法, 需要匹配”-“时需要将其放到末尾或者开头</p>
</li>
</ul>
<h3 id="大括号拓展"><a href="#大括号拓展" class="headerlink" title="大括号拓展"></a>大括号拓展</h3><p>拓展成括号内的所有值</p>
<ul>
<li><p>值可以没有,表示空</p>
</li>
<li><p>值之间用逗号分隔</p>
</li>
<li><p>逗号前后不能有空格,否则拓展失效</p>
</li>
<li><p>不是文件拓展,不管文件存在与否都拓展成给定值</p>
</li>
<li><p>优先级高,总是先被运行(相较于其他拓展</p>
</li>
<li><p>可以嵌套拓展</p>
<ul>
<li>{A{1,2},B{1,2}}</li>
<li>等于A1 A2 B1 B2</li>
</ul>
</li>
<li><p>{Start..End}</p>
<ul>
<li>与方括号类似,不过用”..”连接</li>
</ul>
</li>
</ul>
<ul>
<li>{Start..End..Step}<ul>
<li>指定步长</li>
</ul>
</li>
</ul>
<h3 id="变量拓展"><a href="#变量拓展" class="headerlink" title="变量拓展"></a>变量拓展</h3><p>“$“:取变量值</p>
<p>可以与前面的拓展连用,取多个变量值</p>
<h3 id="子命令拓展"><a href="#子命令拓展" class="headerlink" title="子命令拓展"></a>子命令拓展</h3><p>$(~): ~表示命令,该式将~的输出作为返回值</p>
<p>`~`:同样表示子命令</p>
<h3 id="算术拓展"><a href="#算术拓展" class="headerlink" title="算术拓展"></a>算术拓展</h3><p>$((~)):将~拓展为整数运算</p>
<ul>
<li>let 命令使赋值可以直接执行算术表达式</li>
</ul>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>[[:class:]]</p>
<ul>
<li><p>alnum : 字母和数字</p>
</li>
<li><p>alpha : 字母</p>
</li>
<li><p>blank : 空格和tab键</p>
</li>
<li><p>cntrl : ASCII 0-31的非打印字符</p>
</li>
<li><p>digit : 数字</p>
</li>
<li><p>graph : 字母,数字,标点</p>
</li>
<li><p>lower : 小写字母</p>
</li>
<li><p>upper : 大写字母</p>
</li>
<li><p>print : 32-127 的可打印字符</p>
</li>
<li><p>punct : 标点(除了字母,数字之外的可打印字符)</p>
</li>
<li><p>space : 空格,tab, ASCII 10-13(LF,VT,FF,CR)</p>
</li>
<li><p>xdigit : 16进制字符</p>
</li>
</ul>
<h3 id="拓展量词"><a href="#拓展量词" class="headerlink" title="拓展量词"></a>拓展量词</h3><p>?(~): 0,1</p>
<p>*(~): 0-infinity</p>
<p>+(~): 1-infinity</p>
<p>@(~): 1</p>
<p>!(~): 除外</p>
<h2 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h2><h3 id="转义符-反斜杠"><a href="#转义符-反斜杠" class="headerlink" title="转义符: 反斜杠\"></a>转义符: 反斜杠\</h3><p>特殊字符失效化:</p>
<p>表示不可打印字符</p>
<ul>
<li><p>\a : alarm,响铃</p>
</li>
<li><p>\b: backspace, 退格</p>
</li>
<li><p>\n; 换行</p>
</li>
<li><p>\r: 回车</p>
</li>
<li><p>\t: table,制表符</p>
</li>
</ul>
<p>特殊用法,命令分行</p>
<ul>
<li>本质上是转移 \n,使之被当作空格处理</li>
</ul>
<h3 id="引号’-or-”"><a href="#引号’-or-”" class="headerlink" title="引号’ or \”"></a>引号’ or \”</h3><p>同样有无效化特殊字符的作用, 在引号内的特殊字符被当作普通字符处理</p>
<p>双引号中,大部分字符失效</p>
<ul>
<li><p>$</p>
</li>
<li><p>`</p>
</li>
<li><p>\</p>
</li>
</ul>
<p>单引号中, 全部字符意义失效</p>
<p>双引号可以保存命令的输出格式</p>
<ul>
<li>如多个空格</li>
</ul>
<h3 id="here文档"><a href="#here文档" class="headerlink" title="here文档"></a>here文档</h3><p>输入多行字符串</p>
<p>格式</p>
<ul>
<li><p>起始: \&lt;\&lt; token</p>
</li>
<li><p>结束: token</p>
</li>
</ul>
<p>支持变量拓展，反斜杠拓展，不支持通配符拓展</p>
<ul>
<li>可以将\”\&lt;<code>&lt;token&quot;，放在单引号中，可以使变量拓展失效&gt;</code>{=html}</li>
</ul>
<p>here字符串</p>
<ul>
<li><p>\&lt;\&lt;<code>&lt;string&gt;</code>{=html}</p>
</li>
<li><p>将命令通过标准输入传递给命令</p>
</li>
<li><p>等同于 echo string | command</p>
</li>
<li><p>优点在于有的命令只能接受标准输入作为参数</p>
</li>
</ul>
<h6 id="cat"><a href="#cat" class="headerlink" title="# cat"></a># cat</h6><h6 id="MD5sum"><a href="#MD5sum" class="headerlink" title="# MD5sum"></a># MD5sum</h6><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>自带定义,已经定义好的</p>
<ul>
<li><p>printenv</p>
</li>
<li><p>env</p>
</li>
</ul>
<p>常见环境变量</p>
<ul>
<li><p>BASHPID</p>
</li>
<li><p>BASH的进程ID</p>
</li>
<li><p>BASHOPTS</p>
</li>
<li><p>当前shell的参数, 可以用`shopt`修改</p>
</li>
<li><p>DISPLAY</p>
</li>
<li><p>图形环境的显示器名字</p>
</li>
<li><p>HOME</p>
</li>
<li><p>用户主目录</p>
</li>
<li><p>HOST</p>
</li>
<li><p>主机名称</p>
</li>
<li><p>IFS</p>
</li>
<li><p>词分割符,默认空格</p>
</li>
<li><p>LANG</p>
</li>
<li><p>字符集和语言编码</p>
</li>
<li><p>PATH</p>
</li>
<li><p>目录列表,可执行程序的搜索路径,包含由冒号分开的目录列表</p>
</li>
<li><p>PS1</p>
</li>
<li><p>Shell提示符</p>
</li>
<li><p>PS2</p>
</li>
<li><p>输入多行命令时,次shell提示符</p>
</li>
<li><p>PWD</p>
</li>
<li><p>工作目录</p>
</li>
<li><p>RANDOM</p>
</li>
<li><p>产生0~(2\^15-1)之间的一个随机整数</p>
</li>
<li><p>SHELL</p>
</li>
<li><p>shell的名字</p>
</li>
<li><p>SHELLOPTS</p>
</li>
<li><p>启动当前shell的set命令参数</p>
</li>
<li><p>TERM</p>
</li>
<li><p>终端类型名</p>
</li>
<li><p>UID</p>
</li>
<li><p>用户ID编号</p>
</li>
<li><p>USER</p>
</li>
<li><p>当前用户用户名</p>
</li>
</ul>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>用户在当前shell中设立的变量,仅当前shell可用</p>
<p>set命令可查看所有自定义变量和环境变量和所有bash函数</p>
<h3 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h3><p>变量规则</p>
<ul>
<li><p>字母+数字+下划线</p>
</li>
<li><p>以字母或者下划线开头</p>
</li>
<li><p>没有空格或者标点符号</p>
</li>
</ul>
<p>读取变量</p>
<ul>
<li><p>$,或者${~}读取</p>
</li>
<li><p>变量不存在则返回空字符</p>
</li>
<li><p>${!varname}</p>
</li>
<li><p>一个变量的值是另一个变量的名字</p>
</li>
<li><p>该公式将其自动展开到最终值</p>
</li>
</ul>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>unset name</p>
<p>将变量值设为空</p>
<h3 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h3><p>exprot NAME</p>
<p>将一个变量设置为环境变量(对于本SHELL和随后创建的</p>
<p>可以同时进行赋值</p>
<p>子shell修改继承值，不影响父shell</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>$?: 上一个命令的退出码,返回为0则成功,否则失败</p>
<p>$$: 当前shell的进程ID</p>
<p>$_: 上一个命令的最后一个参数</p>
<p>$!: 最近的一个后台运行的进程的ID</p>
<p>$0: 当前shell的名称或者脚本名</p>
<p>$-: 当前shell的启动参数</p>
<p>$@和$# 参数值和参数数量</p>
<h3 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h3><p>${varname : -word}</p>
<ul>
<li>如果varname存在且不为空,则返回word</li>
</ul>
<p>${varname:=word}</p>
<ul>
<li>不存在时返回word并将该var设为word</li>
</ul>
<p>${varname:+word}</p>
<ul>
<li>存在且不为空,返回word,否则空值</li>
</ul>
<p>${varname: ?message}</p>
<ul>
<li>存在且不为空,则返回varvalue,否则打印出message,并中断脚本</li>
</ul>
<h3 id="Declare命令"><a href="#Declare命令" class="headerlink" title="Declare命令"></a>Declare命令</h3><p>声明变量,为变量设置限制</p>
<p>-i参数: 声明整数变量</p>
<ul>
<li><p>可以直接进行数学运算</p>
</li>
<li><p>一个被解释为整数后,其他的变量自动解释</p>
</li>
</ul>
<p>-x参数:等同于export</p>
<p>-r参数: 设置仅可读</p>
<ul>
<li><p>无法改变也不能`unset`</p>
</li>
<li><p>readonly 命令： 与declare -r等价</p>
</li>
<li><p>-f 变量为函数名</p>
</li>
<li><p>-p 打印所有只读变量</p>
</li>
<li><p>-a 生命的变量为数组</p>
</li>
</ul>
<p>-u参数: 声明变量为大写字母,upper</p>
<p>-p参数:输出变量信息,print</p>
<p>-f参数: 输出当前环境所有函数,及其定义</p>
<p>-F参数: 同上,单不包括定义</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>$#{varname}</p>
<p>$#在脚本中表示脚本的参数个数,故大括号是必要的</p>
<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>${varname:offset:length}</p>
<p>表示截取varname变量中offset位置开始的length长度子串</p>
<ul>
<li>忽略length则取到末尾</li>
</ul>
<p>只能操作变量,不能操作字符串</p>
<p>若offset可以为负值, 同样表示对应位置</p>
<ul>
<li><p>负号和冒号间必须有空格</p>
</li>
<li><p>否则会和设置变量默认值的语法混淆</p>
</li>
<li><p>此时length可以为负值,表示排除从末尾开始的length个字符</p>
</li>
</ul>
<h3 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h3><p>头部识别(从开头开始匹配)</p>
<ul>
<li><p>${var#pattern}</p>
</li>
<li><p>删除最短匹配部分,返回剩余</p>
</li>
<li><p>${var##pattern}</p>
</li>
<li><p>删除最长匹配部分,返回剩余</p>
</li>
<li><p>${var/#pattern/string}</p>
</li>
<li><p>替换匹配部分</p>
</li>
</ul>
<p>尾部识别</p>
<ul>
<li><p>${var%pattern}</p>
</li>
<li><p>删除最短匹配部分,返回剩余</p>
</li>
<li><p>${var\%\%pattern}</p>
</li>
<li><p>删除最长匹配部分,返回剩余</p>
</li>
<li><p>${var/%pattern/string}</p>
</li>
<li><p>替换匹配部分</p>
</li>
</ul>
<p>任意位置识别</p>
<ul>
<li><p>${var/pattern/string}</p>
</li>
<li><p>最长匹配部分,仅替换第一个匹配</p>
</li>
<li><p>${var//pattern/string}</p>
</li>
<li><p>最长匹配部分,但替换所有最长匹配</p>
</li>
</ul>
<h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><p>${varname\^\^}</p>
<ul>
<li>转为大写</li>
</ul>
<p>${varname,,}</p>
<ul>
<li>转为小写</li>
</ul>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h3><p>((~)); 整数的算术运算</p>
<p>使用$?可以获取算术表达式运行情况</p>
<ul>
<li><p>算数结果为0就算执行失败,为1</p>
</li>
<li><p>否则就算成功,为0</p>
</li>
</ul>
<p>支持的运算符</p>
<ul>
<li><p>+,-,*</p>
</li>
<li><p>/: 整除</p>
</li>
<li><p>%: 余数</p>
</li>
<li><p>**指数</p>
</li>
<li><p>++:自增</p>
</li>
<li><p>—自减</p>
</li>
</ul>
<p>表达式中可以引用变量,且不需要加$取值符号</p>
<p>若变量为字符串则将其作为空值处理, 为0</p>
<p>也可以使用</p>
<ul>
<li><p>let</p>
</li>
<li><p>let x=2+3</p>
</li>
<li><p>expr</p>
</li>
<li><p>expr $foo+3</p>
</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>number: 十进制</p>
<p>0number: 八进制</p>
<p>0xnumber: 十六进制</p>
<p>base#number: base进制</p>
<h3 id="二进制操作"><a href="#二进制操作" class="headerlink" title="二进制操作"></a>二进制操作</h3><p>\&lt;\&lt;/>> digit,位左移/右移运算</p>
<ul>
<li>乘2**digit</li>
</ul>
<p>&amp;: 二元操作符,对两个数字的所有位执行AND操作</p>
<p>|: 与操作</p>
<p>\^: 异或操作</p>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>\&lt;</p>
<p>></p>
<p>\&lt;=</p>
<p>>=</p>
<p>==</p>
<p>!=</p>
<p>&amp;&amp;:与</p>
<p>||:或</p>
<p>!:否</p>
<p>expr?expr1:expr2</p>
<ul>
<li>若真则1,若假则2</li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>+=</p>
<p>-=</p>
<p>*=</p>
<p>/=</p>
<p>%=</p>
<p>\&lt;\&lt;=</p>
<p>>>=</p>
<p>&amp;=</p>
<p>|=</p>
<h3 id="求值运算"><a href="#求值运算" class="headerlink" title="求值运算"></a>求值运算</h3><p>((expr1 , expr2))</p>
<p>执行两个表达式,返回后面一个的值</p>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><h3 id="快捷键else"><a href="#快捷键else" class="headerlink" title="快捷键else"></a>快捷键else</h3><p>Ctrl + j：等同于回车键（LINEFEED）。</p>
<p>Ctrl + m：等同于回车键（CARRIAGE RETURN）。</p>
<p>Ctrl + o：等同于回车键，并展示操作历史的下一个命令。</p>
<p>Ctrl + v：将下一个输入的特殊字符变成字面量，比如回车变成\^M。</p>
<p>Ctrl + [：等同于 ESC。</p>
<p>Alt + .：插入上一个命令的最后一个词。</p>
<p>Alt + _：等同于Alt + .。</p>
<h3 id="快捷键模式"><a href="#快捷键模式" class="headerlink" title="快捷键模式"></a>快捷键模式</h3><p>Vi快捷键</p>
<p>emacs快捷键</p>
<p>set -o vi/emacs 设置</p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>Ctrl+A</p>
<ul>
<li>行首</li>
</ul>
<p>Ctrl+B</p>
<ul>
<li>左移一个字符</li>
</ul>
<p>Ctrl+E</p>
<ul>
<li>行尾</li>
</ul>
<p>Ctrl+f</p>
<ul>
<li>右移一个字符</li>
</ul>
<p>Alt+f</p>
<ul>
<li>单词词尾</li>
</ul>
<p>Alt+b</p>
<ul>
<li>单词词首</li>
</ul>
<p>Ctrl+L</p>
<ul>
<li>清屏</li>
</ul>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>Ctrl+d</p>
<ul>
<li>删除光标所在位置字符</li>
</ul>
<p>Ctrl+W</p>
<ul>
<li>删除删除光标前的字符</li>
</ul>
<p>Ctrl+t</p>
<ul>
<li>光标位置的字符与前面一位的字符交换位置</li>
</ul>
<p>Alt+t</p>
<ul>
<li>光标位置的词与前面一位的词交换位置</li>
</ul>
<p>Alt+I</p>
<ul>
<li>从光标位置到词尾转为小写</li>
</ul>
<p>Alt+u</p>
<ul>
<li>将光标位置至词尾转为大写</li>
</ul>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>Ctrl+k</p>
<ul>
<li>剪切光标位置到行尾的文本</li>
</ul>
<p>Ctrl+u</p>
<ul>
<li>剪切光标位置到行首的文本</li>
</ul>
<p>Alt+d</p>
<ul>
<li>剪切光标位置到词尾的文本</li>
</ul>
<p>Alt+Backspace</p>
<ul>
<li>剪切光标位置到词首的文本</li>
</ul>
<p>Ctrl+y</p>
<ul>
<li>粘贴</li>
</ul>
<h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>Tab: 自动补全</p>
<p>Alt+?: 列出可能的补全</p>
<p>Alt+/:文件路径补全</p>
<p>Alt+I：命令补全</p>
<p>Alt+~：用户名补全</p>
<p>Alt+$: 变量名补全</p>
<p>Alt+@: 主机名补全</p>
<p>Alt+*:一次性插入所有可能的补全</p>
<p>Alt+tab: 尝试用以前的命令的进行补全</p>
<h3 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h3><p>$HISTFILE: 指向/home/me/.bash_history</p>
<p>history: 直接输出所有历史,默认储存500条命令</p>
<p>Ctrl+r : 搜索操作历史,选择以前使用过的命令</p>
<ul>
<li><p>!~: 表示查找以~开头的、最近的命令</p>
</li>
<li><p>只会匹配命令，不能匹配参数</p>
</li>
</ul>
<p>history环境变量设置</p>
<ul>
<li><p>export HISTTIMEFORMAT = ‘%F %T’</p>
</li>
<li><p>保留执行命令的时间戳</p>
</li>
<li><p>export HISTSIZE=num</p>
</li>
<li><p>设置保存历史操作记录数</p>
</li>
<li><p>export HISTIGNORE=”com1:com2:com3”</p>
</li>
<li><p>设置不保留某些命令的历史</p>
</li>
</ul>
<p>history | grep pattern</p>
<ul>
<li>模式搜搜</li>
</ul>
<p>！number：直接执行对应索引的命令</p>
<p>history -c 清除搜索历史</p>
<p>快捷键</p>
<ul>
<li><p>Ctrl+p/n: previous/next 上一条/下一条命令</p>
</li>
<li><p>Alt+ \&lt;/>; 显示第一条/最后一条命令</p>
</li>
<li><p>Ctrl+ o: 执行历史纪录里的当前条目,并自动显示下一个命令</p>
</li>
</ul>
<p>!快捷键</p>
<ul>
<li><p>!!：执行上一个命令。</p>
</li>
<li><p>!n：n为数字，执行历史文件里面行号为n的命令。</p>
</li>
<li><p>!-n：执行当前命令之前n条的命令。</p>
</li>
<li><p>!string：执行最近一个以指定字符串string开头的命令。</p>
</li>
<li><p>!?string：执行最近一条包含字符串string的命令。</p>
</li>
<li><p>!$：代表上一个命令的最后一个参数。</p>
</li>
<li><p>!*：代表上一个命令的所有参数，即除了命令以外的所有部分。</p>
</li>
<li><p>\^string1\^string2：执行最近一条包含string1的命令，将其替换成string2。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>GENEXII学习笔记</title>
    <url>/2022/09/03/GENEXII%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="The-First-Section-Gene-is-DNA-that-encodes-RNA-and-polypeptides"><a href="#The-First-Section-Gene-is-DNA-that-encodes-RNA-and-polypeptides" class="headerlink" title="The First Section: Gene is DNA that encodes RNA and polypeptides"></a>The First Section: Gene is DNA that encodes RNA and polypeptides</h3><h4 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>Genome/基因组: 脱氧核糖核酸(deoxyribonucleic acid,DNA)链提供了有机体，以及它的每一个细胞所携带的全部遗传信息。它包括染色体DNA、质粒DNA,以及(真核细胞中)存在于线粒体和叶绿体的细胞器DNA。</li>
<li>protein—coding gene、结构基因(structural gene)：编码的RNA依次编码多肽。</li>
<li>gene locus: 每一条染色体由线性排列的基因组成，每个基因位于染色体的特殊位点上。</li>
<li>allele : 基因座上所发现的不同形式。</li>
<li>linkaage : 一条染色体上的等位基因表现出连锁遗传。</li>
<li>transfection: 转染，指纯化的DNA加入到动物细胞中产生特殊的蛋白质。</li>
<li>nucleotide：在C-5与磷酸基团相连的核苷称为核苷酸。</li>
<li>supercoiling : DNA双螺旋结构自身相互缠绕从而改变DNA分子空间构象。同向扭转(顺时针)正超(positive),反之负超。</li>
<li>lingking number(L) : DNA一条链绕另一条链的环绕圈数。不同L的NDA分子称为拓扑异构体。<ul>
<li>writhing number(W) : DNA双链的轴所绕圈数，无量化值，W=0则为松散分子。</li>
<li>twisting number(T) : 一条链相对于另外一条的旋转情况。由每圈多少个碱基决定。</li>
<li>L~0~为松散状态L, L/L~0~可视为超螺旋密度。</li>
</ul>
</li>
<li>bent DNA:一条链上出现8~10个连续腺嘌呤(A)导致双螺旋弯曲。</li>
<li>melting temperature: 使DNA双链分开的温度范围的中点。</li>
<li>hybrization : 两条不同来源的互补核酸序列退火形成双链结构。<ul>
<li>滤膜上吸附有变性DNA，置于含有其他变性DNA的溶液中，即可检测是否含有互补序列。检测紫外吸收峰值测定杂交程度或是通过放射性强度决定。</li>
</ul>
</li>
<li>mutation rate: 贯穿全基因组的突变(突变率以每个基因组每代发生多少来表示)：基因内的突变(突变率以每个基因座每代发生多少来表示)：特殊核苷酸位点的突变(突变率以每个碱基每代发生多少来表示)。</li>
<li>transposable element: 具有可从一个位置移动到另一个位置的DNA序列。这一插入往往导致基因活性消失造成移码突变(frameshift mutation)。<ul>
<li>插入发生时往往会删除部分或者全部插入序列，邻近区域也可能被删除。</li>
</ul>
</li>
<li>forward mutation:正向突变，使基因失活的突变。相对应的是back mutation，回复突变。<ul>
<li>true reversion:真实回复。原始突变的严格逆转。</li>
<li>second-site reversion:第二位点回复。第二次突变弥补了第一次的功能。</li>
<li>suppression mutation: 一个基因座上的突变能够抑制另一个的突变效应。该locus称为抑制基因(suppressor)<ul>
<li>点突变可能导致多肽的氨基酸替换，而tRNA基因上的一种突变使得它能识别突变的密码子，那么在翻译中就会插入原来的氨基酸残基(请注意：这抑制了原来的突变，但在其他mRNA的翻译中会引入错误)。</li>
</ul>
</li>
</ul>
</li>
<li>cistron: 处于顺式构型或是反式构型的基因是指两个突变是否在同一条链上。</li>
<li>null mutation: 基因功能被完全消除。<ul>
<li>loss-of-function mutation: 阻止基因功能的突变。</li>
<li>leaky mutation: 突变不完全消除蛋白质活性，保留一定活性。</li>
<li>silent mutation: 无明显效应的突变。</li>
<li>synonymous mutation: 碱基改变但是氨基酸残基不变。</li>
<li>neutral substitution: 碱基改变，氨基酸残基也改变，但多肽活性不变。 </li>
<li>中性突变(neutralmutation) : 它对有机体表型没有影响。<ul>
<li>一些中性突变是同义突变，但不是所有的同义突变都是中性的。具体运送特定氨基酸的单一RNA的浓度是不同的，一些同义tRNA(不同tRNA携带一样的氨基酸)比其他的丰富，一些特殊密码子可能缺少足够的tRNA；</li>
</ul>
</li>
<li>frameshift mutation移码突变：吖啶acridine引起，引进或者缺失一个碱基。(-)和(+)两种，分别表示缺失与增加。同时(+)(-)和(-)(+)两种方式可相互抑制，一个称为另一个的移码抑制基因(frameshift suppressor)。<ul>
<li>当构建三突变体时，只有(+++)和(—-)表现野生型表型，而其他组合都是突变型。</li>
</ul>
</li>
<li>错义突变(missense mutation): 产生编码不同氨基酸的密码子;</li>
<li>无义突变(nonsense mutation): 产生终止密码子。</li>
</ul>
</li>
<li>reading frame:阅读框，如果遗传密码是不重叠的三联体，根据起始位点的不同，那么会有3种可能的方式将核苷酸翻译成蛋白质。<ul>
<li>一个由能翻译成氨基酸的三联体构成的阅读框称为可读框(open reading frame,ORF)。</li>
<li>多肽序列有一个特殊的起始密码子(initiation codon)(AUG),从此延伸出一系列代表氨基酸的三联体，直到遇到3种类型的终止密码子(termination codon)(UAA、UAG或UGA)中的一个时才结束翻译。</li>
<li>如果终止密码子频繁出现，就会阻止<strong>阅读框被翻译成蛋白质</strong>，我们称之为关闭(closed)或阻断(blocked):如果一个序列的3个<strong>阅读框全部被阻断</strong>，那么它就<strong>失去编码蛋白质的功能</strong>。</li>
<li>在3种可能的阅读框中，只有一种阅读框是可翻译的，而其他两种会<strong>受到频繁的终止信号的阻断</strong>。</li>
</ul>
</li>
<li>colinear: 基因与蛋白质是否共线性。核苷酸序列与蛋白质中氨基酸序列是否恰好一致。如果一个多肽含有N个氨基酸残基，那么编码这一多肽的基因就包含3N个核苷酸残基。</li>
<li>gene expression : 用来自基因中的信息合成RNA或多肽的过程称为基因表达。<ul>
<li>mRNA还包括两边的附加序列，这些序列不编码蛋白质</li>
<li>5’端的非翻译区称为前导区(<strong>leader</strong>)或5’非翻译区(5’untraslatedregion,5’UTR).</li>
<li>3’端的非翻译区称为非翻译尾区(<strong>trailer</strong>)或3’非翻译区(3’untraslated region,3’UTR).</li>
</ul>
</li>
<li>cis-acting: 顺式作用。DNA序列包含两个部分，控制位点和编码区，<strong>控制位点的缺陷</strong>仅仅影响与其相连的编码区，而这不影响其他等位基因的表达能力，这种仅影响邻近DNA序列表达的性质称为顺式作用(cis-acting)。</li>
<li>trans-acting:反式作用，<strong>调节物突变</strong>。如果突变能发挥反式作用，我们就认为其作用是通过产生可扩散分子(通常是蛋白质或调节性RNA)进行的，它可作用于细胞内多个靶标；</li>
</ul>
<h4 id="Key-concepts"><a href="#Key-concepts" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li>碱基配对互补：<ul>
<li><strong>一条单链分子</strong>中<strong>两段互补序列</strong>通过碱基配对可以形成分子内的双链体。</li>
<li><strong>一条单链分子</strong>可以和<strong>另一条独立、互补的单链分子</strong>进行碱基配对，形成分子间的双链体。</li>
</ul>
</li>
<li>突变(自发或诱发)只需要在单链形成即可。<ul>
<li><img src="https://fastly.jsdelivr.net/gh/Molaison/IMages/IMG/image-2022090210582811888.png" alt="image-20220902105828888"></li>
</ul>
</li>
<li>突变热点的出现是多个突变事件在一个位点发生的结果。<ul>
<li>热点的存在是因为<strong>胞嘧啶</strong>发生了高频率的自发脱氨基，从而产生<strong>尿嘧啶</strong>，而<strong>甲基化的胞嘧啶</strong>脱氨基则产生<strong>胸腺嘧啶</strong>!</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005165031.png" alt="image-20220902120602343"></li>
<li>由于U不存在于DNA中，故而胞嘧啶脱氨基能够很快被识别。</li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points"><a href="#Inexplicable-points" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><ul>
<li>为什么处于解链温度DNA双链体是稳定的?(comes from GENE XII P16)</li>
</ul>
<h3 id="Interrupted-gene"><a href="#Interrupted-gene" class="headerlink" title="Interrupted gene"></a>Interrupted gene</h3><h4 id="Terminology-1"><a href="#Terminology-1" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>interrupted gene: 断裂基因，编码区和非编码区互相间隔开但又连续镶嵌而成<ul>
<li>外显子(exon)的序列包含在成熟RNA中，精确地说，一个成熟转录物(maturetranscript)起始于一个外显子的5’端，终止于另一个外显子的3’端。</li>
<li>内含子(intron)是插入序列，在初始转录物加工成成熟RNA时被除去。</li>
<li>反式剪切：不同mRNA的序列连接到一起</li>
</ul>
</li>
<li>First parity rule: 即碱基配对原则<ul>
<li>second parity rule: 在双链的每条单链中AT，CG几乎相等，也即碱基对不是偏向某一条链，而是相对均匀的散落在两条链中；<strong>更多地适用于内含子；</strong></li>
<li>cluster rule : DNA中嘌呤和嘧啶往往分别聚集在一起，AG，CT，<strong>更多适用于外显子；</strong></li>
<li>GC rule: 一个基因组中，GC的含量的总体比例具有物种特异性；在基因组内，单一基因往往具有独特的值；<ul>
<li>外显子GC含量高于内含子</li>
</ul>
</li>
</ul>
</li>
<li>negative selection: 也称纯化选择(purifying selection), 外显子序列是保守的，因为如果序列改变(不再保守)，就会导致表型的改变，这种改变会使物种难以生存和很难产生可繁殖的后代。</li>
<li>overlapping gene: 同一DNA序列编码两种非同源蛋白，使用了一次以上的阅读框。</li>
<li>nested gene: 一个基因被发现存在于另一个基因的大的、类似于“宿主”的内含子中<ul>
<li>重叠基因往往存在于“宿主”基因的另一条链上。</li>
</ul>
</li>
<li>alternative splicing: mRNA前体以多种方式将exon连接在一起的过程;</li>
<li>in series gene: equal to no allele;</li>
<li>gene family : 为一组源自基因复制事件的、编码相关或相同多肽的基因。在第一次复制事件后，两份拷贝完全一致，随后，当不同突变在序列上累积后，它们就开始趋异。</li>
<li>superfamily: 当我们发现基因相距较远，但还是认为它们具有共同的祖先, 称该组基因为超家族；</li>
<li>orthologous gene : 也称ortholog, 是物种进化后所形成的同源基因(homologous gene,homolog),换句话说，它们是不同物种的<strong>相关基因。</strong></li>
<li></li>
</ul>
<h4 id="Key-concepts-1"><a href="#Key-concepts-1" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li>只有外显子中的突变才会影响多肽链序列；但内含子中的突变会影响RNA的加工，从而可能影响序列和(或)多肽的产生。</li>
<li>DNA碱基组成的4条规则是：第一均等规则、第二均等规则、成簇规则和GC规则。<ul>
<li>我们能根据第一条之外的所有规则来区分外显子和内含子。</li>
<li>第二均等规则提示，来自双链体DNA、固定的茎-环区段的外突在内含子出现得更多。</li>
</ul>
</li>
<li>不同生物间内含子的位置通常是保守的，但是相应的内含子的长度变化可以很大。<ul>
<li>比较不同物种的相关基因发现，相应的外显子序列通常是保守的，而内含子序列的<strong>相似性则低得多</strong>。因为<strong>缺乏使用有用序列去产生多肽，所以没有选择压力</strong>，这样内含子比外显子进化要快得多。</li>
<li>相关性：编码序列和邻近外显子的内含子区域保持了相似性；而在更长的内含子与非编码序列两侧的区域则存在着很大的趋异。</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220907112657272.png" alt=""></li>
</ul>
</li>
<li>处于正选择下，相对于无突变的其他基因，碰巧产生有利突变的单一基因存活下来；<ul>
<li>此时外显子进化要比内含子快；</li>
<li>内含子保守：<ul>
<li>RNA剪接所需的内含子序列，如5’和3’剪接位点，以及分支位点是保守的；</li>
<li>碱基顺序也被进化以适应于增进这个区域中双链体DNA外突茎-环结构的潜能(折叠潜能)</li>
</ul>
</li>
</ul>
</li>
<li>外显子通常短小，典型的外显子编码小于100个氨基酸。一个基因的总长度主要由它的内含子所决定。</li>
<li>抗体特异性的产生：<a href="https://zhuanlan.zhihu.com/p/27467842">抗体结构 - 知乎 (zhihu.com)</a> 中关于超变区的描述;</li>
</ul>
<h4 id="Inexplicable-points-1"><a href="#Inexplicable-points-1" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><ul>
<li>pressure 具体指什么？为什么把它说成信息？<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-202209091425465321.png" alt="image-20220909142546532"><ul>
<li>选择压，就是自然选择淘汰一些表型的基因</li>
</ul>
</li>
</ul>
<h3 id="Overview-of-Genome"><a href="#Overview-of-Genome" class="headerlink" title="Overview of Genome"></a>Overview of Genome</h3><h4 id="Terminology-2"><a href="#Terminology-2" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>genome: 有机体的一整组完全地的基因，最终由DNA的全序列决定。</li>
<li>transcriptome: 在特定条件下表达的一组完整的基因，根据细胞中所存在的这一组RNA分子来决定</li>
<li>proteome: 一组完整的多肽，它可由全基因组编码，或者在某一种细胞或组织中产生。</li>
<li>interactome: 相互作用组，蛋白质可以独立地或者作为多蛋白组装物或多分子复合体的一部分而起作用，如全酶或代谢途径中这些酶簇拥在一起。如果我们能够鉴定出所有的蛋白质与蛋白质之间的相互作用，那么我们就能够确定独立的蛋白质组合体的数目。</li>
<li>reassociation kinetics: 真核生物基因组的总体特征可以通过变性DNA的复性动力学(reassociation kinetics)来估计。<ul>
<li>非重复DNA(nonrepetitive DNA)由单一序列组成，在单倍体基因组中只有一份拷贝。</li>
<li>重复DNA(repetitive DNA)是在每一单倍体基因组中含有两份以上的拷贝。重复DNA经常被分为两种类型。<ul>
<li>中度重复DNA(moderately repetitive DNA)由相对较短的序列组成，在基因组中，其重复次数一般在10~1000次。<ul>
<li>这些序列遍布整个基因组，并负责<strong>前mRNA剪接时二级结构的形成</strong>，此时<strong>内含子中的反向重复配对形成双链体区域</strong>。编码tRNA和rRNA的基因也是中等重复的。</li>
</ul>
</li>
<li>高度重复DNA(highly repetitive DNA)由基因组中非常短的序列(一般小于100bp)组成，重复次数达几千次，一般组成长的串联重复。</li>
</ul>
</li>
</ul>
</li>
<li>Linkage map: 根据基因座之间的重组率来确定距离;</li>
<li>restriction map:通过限制性内切核酸酶把DNA切成片段, 再测量切割位点的碱基对距离(电泳迁移)</li>
<li>genetic polymerphism: 一个基因座上存在多个等位基因;</li>
<li>transposon:转座子。有相当大一部分的<strong>中度重复DNA</strong>是由转座子(transposon)组成的，它们的序列比较短小(最多约5kb),能够<strong>移位到基因组中新的位置</strong>，或者进行<strong>自我拷贝</strong>。</li>
<li>synteny : 同线性，不同物种基因组在局部范围内，总体上基因的排列顺序是相同的：当成对的人类和小鼠染色体同源区域进行比较时，位于对应位置的基因通常是同源的。</li>
<li>expressed sequence tag: EST就是转录序列的一小部分，它通常来自于gcoreA文库中的克隆片段的一端或双末端测序。EST能证明一个所怀疑的基因确实是转录的，或有助于鉴定影响特殊疾病的基因。</li>
</ul>
<h4 id="Key-Concepts"><a href="#Key-Concepts" class="headerlink" title="Key Concepts"></a>Key Concepts</h4><ul>
<li>蛋白质编码的基因的最大数目：<ul>
<li>根据可读框来确定</li>
<li>根据转录物组(通过直接确定所有的mRNA)或蛋白质组(通过直接确定所有的蛋白质)来直接定义基因的数目，这种方法能保证我们处理的是真实基因，即它们是在已知环境下所表达的基因。    </li>
</ul>
</li>
<li>非重复DNA随着全基因组的增大趋向于更长。故基因组中的非重复DNA组分与有机体的相对复杂性有较好的相关性。<ul>
<li>多肽一般是由非重复DNA编码的。</li>
<li>在同一个分类群中，较大基因组并不一定含有更多基因，但包含有较多的重复DNA。</li>
<li>大部分重复DNA是由转座子组成。</li>
</ul>
</li>
<li>细胞器基因组:<ul>
<li>通常为环状DNA分子; 线粒体DNA — mtDNA, 叶绿体DNA — ctDNA or cpDNA;</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-2"><a href="#Inexplicable-points-2" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="Genome-sequence-and-evolution"><a href="#Genome-sequence-and-evolution" class="headerlink" title="Genome sequence and evolution"></a>Genome sequence and evolution</h3><h4 id="Terminology-3"><a href="#Terminology-3" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>tandem repeat :串联重复序列，<strong>以相对恒定的短序列为重复单位，首尾相接， 串联连接形成的重复序列</strong>，又称卫星DNA (satellite DNA)。</li>
<li>abundance:在每一个细胞中，每一种mRNA的平均数量被称为这个分子的丰度(abundance)。</li>
<li>scarce mRNA: 也称complex mRNA, 占总量约一半的mRNA组成了大部分不同的序列，约为上万种，每一种mRNA成分的量都不是很多，通常少于10份拷贝。稀有mRNA的表达是广泛重叠的。</li>
<li>constitutive gene: 约10%的mRNA序列在这个细胞中是独特的，大部分表达序列在许多、有时甚至所有细胞类型中都是相同的。这些基因是所有细胞类型所必须的。<ul>
<li>luxury gene: 特定细胞类型必需并只在其中表达的基因(如卵清蛋白或珠蛋白)</li>
</ul>
</li>
<li>microarray: 含有微陈列(microarray)的芯片，这些陈列包含一排排的、高密度的微量DNA寡核苷酸样品。这种装置是<strong>建立在全基因组序列已知的基础之上。</strong>在酵母的6181个ORF中，当我们对每一条进行分析时，我们将20条25-寡核苷酸(25-mer,它与mRNA是完全匹配的)和20条不完全匹配的<strong>等长</strong>的寡核苷酸(它们只在一个碱基位置上是不同的)用来代表同一个ORF,从完全匹配的模式中所得到的信号减去不匹配的信号，就能计算出每个基因的表达水平。<ul>
<li>这一技术非常敏感；</li>
<li>不完全匹配的寡核苷酸目的是检测突变；</li>
</ul>
</li>
<li>transversion mutation: 从嘧啶到嘌呤或者从嘌呤到嘧啶；</li>
<li>transition mutation：从嘌呤到嘌呤，嘧啶到嘧啶；</li>
<li>genetic drift: 群体中突变变异体频率的随机变化称为遗传漂变(genetic drift)这是某一种基因型的“抽样误差(sampling error)”<ul>
<li>可能一群特殊类型亲本的子代基因型不完全匹配孟德尔遗传定律所预测的数值;</li>
<li>在非常大的群体中，遗传漂变的随机效应往往被平均化了，所以每一种变异体的频率几乎不存在改变；</li>
<li>然而在小群体中，这些随机变化将会非常显著，遗传漂变对群体的遗传变异会产生显著的效应。</li>
</ul>
</li>
<li>genetic hitchhiking : 核苷酸序列以一定速率中性进化，在特定核苷酸中以这种速率进行的变异会影响杂合性(heterozygosity)(在某一基因座的杂合子的比例)。如果变异体序列是有利的，那么这个位点将显示核苷酸杂合性的降低，而变异体在频率上会增加，并最终固定于群体中;</li>
<li>divergence: 趋异度, 两基因的差异。可通过在每一个位点上获取最常见碱基，就可计算一个家族的祖先共有序列。每个现存成员的趋异度用它与祖先序列的差异碱基比例来计算；</li>
<li>unit evolutionary period: 单位进化时期，产生1%的趋异度所需的时间；百万年为单位；</li>
<li>C-value: 活体生物基因组的DNA总量；</li>
<li>C-value paradox: 基因组大小与遗传形态复杂性之间缺乏必然联系;</li>
<li>CpG岛：p指的是磷酸二酯键，不是pair!!<ul>
<li>哺乳动物的基因组里，CpG序列只占1%。其中70%-80%的CpG是零散分布的，但有一部分CpG会聚集成团，就像岛屿一样散布于基因的海洋里，因此得名CpG岛。CpG岛内的CpG可占据总序列长度的60%以上。</li>
<li>70%左右的功能基因的起始部位都有CpG岛存在；</li>
<li>游离的CpG序列总是处于甲基化状态，而聚成岛屿的CpG通常是没有甲基化的。甲基化后的CpG岛就无法结合转录因子(DNA链上伸出来的甲基就像刺刀一样阻止转录因子的靠近)</li>
</ul>
</li>
<li>nonallelic gene: 两个(或两个以上)相同基因存在于同一染色体上，这称为非等位基因;</li>
<li><p>功能基因: 即protein-coding gene, 那些首先被转录成RNA,而后被翻译为多肽的基因。</p>
<ul>
<li>无功能基因指不能编码相应蛋白质的基因，它们被称为假基因，其失活的原因有多种，可能是转录或翻译的缺陷（或两者均有）所致。</li>
<li>它们不能产生携带原有功能的多肽产物; </li>
<li>它们可以是非功能性的，或产生了变异的功能，以及可具有调节功能的RNA产物。</li>
</ul>
</li>
<li><p>processed pseudogene: 来自成熟mRNA转录物反转录而成的gcoreA拷贝，并被整合入基因组中；</p>
<ul>
<li>当活性反转录酶存在于细胞中，如在活性反转录病毒感染时或反转座子具有活性时，这种事件可能会发生。或转录物进行过加工，其结果是已加工的假基因通常缺乏正常表达所需的调节区，故而失活。</li>
</ul>
</li>
<li><p>nonprocessed pseudogene ：来自多重拷贝或单一拷贝基因的其中一份拷贝的失活突变，或一个活性基因的不完全重复。</p>
<ul>
<li>如果一个基因整体重复，包括调节区，那么此时即存在两个活性基因的拷贝，而一份拷贝上的失活突变不易受到负选择的影响。从而产生未加工的假基因；</li>
<li>一个活性基因的不完全重复，产生失去了调节区和（或）编码序列的拷贝，将会是“到达即死”形式，即它马上会形成假基因。</li>
</ul>
</li>
<li>霍利迪连接体：<a href="https://upload.wikimedia.org/wikipedia/commons/8/8e/Неподвижная_структура_Холлидея_(англ.">https://upload.wikimedia.org/wikipedia/commons/8/8e/Неподвижная<em>структура</em>Холлидея_%28англ.%29.svg</a>.svg)</li>
</ul>
<h4 id="Key-concepts-2"><a href="#Key-concepts-2" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li>支原体基因组大小0.6*10^6^，人类3.3*10^9^，植物的更大；</li>
<li>原核生物85%-90%的序列都编码RNA或者多肽。<ul>
<li>基因组小于1.5Mb的原核生物必定都是细胞内寄生的。也由此鉴定出一个细胞所需的最少基因数，约为1500个；</li>
<li>酵母中有6000个基因；线虫有21700个基因；果蝇有17000个基因；小型植物拟南芥有25000个基因；哺乳动物中的基因数可能有20000~25000个基因。</li>
</ul>
</li>
<li>人类基因组中只有1%由外显子组成。<ul>
<li>外显子只占每个基因DNA序列的约5%，因此基因组中只有约25%的序列是来自基因的外显子加内含子。</li>
<li>人类基因组约有20000个基因。</li>
<li>约60%的人类基因是可变剪接的。多达80%的可变剪接改变了蛋白质序列，因此蛋白质组约由50000~60000种蛋白质成员组成。</li>
</ul>
</li>
<li>重复序列占据了人类基因组的50%以上, 主要分为5类<ul>
<li>转座子(transposon)(活性或非活性的)占了重复序列的绝大部分(基因组的45%)。所有转座子都是多拷贝的。<ul>
<li>转座子具有自我复制和插入到新位点的能力。它们也许只以DNA元件的形式在起作用，或者部分以RNA这种活性方式在起作用</li>
<li>一些现存的基因来源于转座子，在失去转座能力后进化成它们现在的状态</li>
</ul>
</li>
<li>已加工的假基因(总共约3000个，约占总DNA的0.1%。这些序列是mRNA的反转录DNA拷贝插入到基因组而形成的)。</li>
<li>简单重复(高度重复的DNA如CA重复)占基因组的约3%。</li>
<li>区段重复(长度为10~300kb的区段模块在新的区域被重复)占了基因组的约5%。这种重复序列只有一小部分位于相同染色体上，换句话说，大部分重复区段位于不同染色体上。</li>
<li>串联重复形成了一种类型的序列模块(特别是在着丝粒和端粒处)。</li>
</ul>
</li>
<li>当两个或更多的基因存在冗余时，在其中一个基因上进行突变也许不会检测到效应。</li>
<li>在任何给定的细胞中，大部分基因是低水平表达的。<ul>
<li>只有一小部分基因的产物是细胞类型所特有的，所以是高水平表达的。</li>
</ul>
</li>
<li>当复制错误，或化学品对核苷酸的改变损害了DNA,或当电磁辐射打断或形成化学键时，而在下一次复制事件中这些损伤没有修复，那么<strong>突变就会发生</strong>。</li>
<li>转换transition mutation发生的频率是颠换transversion mutation的两倍; 原因<strong>可能</strong>如下:<ul>
<li>自发转换错误比自发颠换发生得更加频繁;</li>
<li>颠换错误更加容易被检测到，并被DNA修复机制校对;</li>
</ul>
</li>
<li>在种间同源基因中，通过计数同义(K~s~)和非同义(K~a~)氨基酸替换，以及计算KK的比值就可研究基因的进化历史。<ul>
<li>K~a~/K~s~=1说明这些基因呈中性进化，其氨基酸变化不偏向任何一方;</li>
<li>K~a~/K~s~&lt;1提示负选择，此时氨基酸替换是不利的，因为它影响了多肽活性，这样就存在自然选择压力，要在那个位置保留原来功能的氨基酸序列以维持适当的蛋白质功能。</li>
<li>当K~a~/K~s~&gt;1时就会发生正选择。这提示氨基酸改变是有利的，可能在群体中保留下来。</li>
<li>正的K~a~/K~s~值可能是很少的，部分原因是在一长串的序列中，其平均值必须超过1。如果某基因中的单一替换正在被<strong>正选择</strong>，而两侧区域处于<strong>负选择</strong>，那么，横跨序列的平均比值实际上是负的。</li>
</ul>
</li>
<li>降低DNA序列多态性的因素：负选择，遗传漂变(drift)，遗传搭车(hitchhiking)；</li>
<li>在RNA世界，由核酸介导的许多功能在基因组空间内相互竞争。可以看成压力pressure;<ul>
<li>AG压力(外显子中嘌岭富集区的压力)</li>
<li>GC压力[全基因组范围内的、两组沃森-克里克(Watson-Crick)配对碱基之间、独特平衡的压力]</li>
<li>单链均等压力(全基因组范围内、在单链核酸中A和T碱基之间及G和C碱基之间的压力)</li>
<li>可能它也与后者相关，即折叠压力(全基因组范围内单链核酸的压力，不管它是以游离形式或从双链体中外突的形式获得二级或更高级茎·环结构)。</li>
</ul>
</li>
<li>基因组大小与遗传复杂性之间没有必然联系。</li>
<li>生物体越复杂，它所需要的最小基因组也越大。</li>
<li>许多在分类上属于一个分类阶元的生物，它们的基因组大小却变化很大。</li>
<li>重复基因可以趋异而产生不同的基因，或其一份拷贝可能会变成失活假基因。重复基因产生差异可能有以下情况：<ul>
<li>case 1 : 两个基因都将变成有机体所需的。<ul>
<li>两个基因编码的蛋白质产生了不同的功能</li>
<li>它们在不同时间或不同细胞类型中表达。</li>
</ul>
</li>
<li>case 2 : 如果上个事件不发生，那么其中一个基因很可能会变成假基因;<ul>
<li>因为如果它获得了有害突变后，由于缺乏纯化选择使它消亡，所以由于随机的遗传漂变，出现突变体的频率可能提高，并固定在某一物种中。</li>
<li>在小群体中，遗传漂变是一种更大的力量。在这样一种情况下，两份拷贝中哪一份失活往往是一个随机事件(如果不同拷贝在不同群体中失活，那么这可能造成不同个体之间的不相容性，或最终引起种间差异)。</li>
</ul>
</li>
</ul>
</li>
<li>当被导入到基因组时，转座因子往往增加拷贝数，但它处于负选择和转座调节机制的检测之中。</li>
<li><p>突变偏爱性可能引起有机体基因组的高A·T含量：</p>
<ul>
<li><p>从胞嘧啶到尿嘧啶，或从5-甲基胞嘧啶到胸腺嘧啶的自发脱氨基作用是常见的突变来源，这促进了从G·C到T·A的转换突变。</p>
<ul>
<li>DNA中的尿嘧啶比胸腺嘧啶更易于修复；</li>
<li>甲基化胞嘧啶(常见于C·G二联体)不仅是突变热点，而且特别偏向于产生T·A对。</li>
</ul>
</li>
<li><p>鸟嘌呤氧化成8-氧鸟嘌呤能导致从C·G到A·T的颠换，因为8-氧鸟嘌呤与腺嘌呤配对比与胞嘧啶配对更加稳定。</p>
</li>
</ul>
</li>
<li>基因转变偏爱性往往增高G·C含量，可能引起部分对抗突变偏爱性。<ul>
<li>在<strong>重组</strong>或双链断裂修复过程中，会产生<strong>霍利迪连接体</strong>，它能形成含有非匹配碱基对的异源双链DNA,而它会以突变链为模板进行修复，这样就产生了基因转变；</li>
</ul>
</li>
<li>高重组活性的染色体区域显示了偏向G·C的更多突变，而低重组活性的染色体区域往往显示为A·T富集区。</li>
<li>密码子偏爱可能源自偏好特殊序列的适应性机制或基因转变偏爱性。<ul>
<li>解释1：一种特定密码子在募集某种丰富的RNA时可能更有效率，如翻译速率或准确度比使用其他密码子更高。<em>**</em></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-3"><a href="#Inexplicable-points-3" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220911094055152.png" alt="image-20220911094055152"><ul>
<li>为什么要设置不完全匹配的挂核苷酸序列？不会导致误匹配吗？<ul>
<li>预测基因突变</li>
<li>不会，24个都匹配的话误匹配概率低；</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220917162442097.png" alt="image-20220917162442097"><ul>
<li>是说这个有害突变不致死，或者相对不那么有害吗？</li>
</ul>
</li>
</ul>
<h3 id="成簇与重复-看不懂，先跳过"><a href="#成簇与重复-看不懂，先跳过" class="headerlink" title="成簇与重复(看不懂，先跳过)"></a>成簇与重复(看不懂，先跳过)</h3><h4 id="Terminology-4"><a href="#Terminology-4" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>cluster ：通过某一<strong>祖先基因</strong>的重复(duplication)和变异(variation)而传递下来的一组基因称为一个基因家族(gene family), 它的成员可以成簇(cluster)排列在一起或散布在不同染色体上（或兼而有之）。</li>
<li>tandem duplication: 一些序列发生了拷贝的同时仍在一起；</li>
<li>translocation: 将DNA片段从一条染色体转移到另一条染色体上；</li>
<li>unequal crossing over: 也称nonreciprocal recombination, 出现在<strong>相似或者一样</strong>的两个位点之间的重组事件，但是这一重组并不对称，导致一条染色体上的重复拷贝转移到了另一条上；<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220918205231345.png" alt="image-20220918205231345"></li>
</ul>
</li>
</ul>
<h4 id="Key-points"><a href="#Key-points" class="headerlink" title="Key points"></a>Key points</h4><ul>
<li>核糖体RNA(rRNA)是由大量完全相同的基因编码的，这些基因串联重复形成一个或多个基因簇;</li>
<li>每一个核糖体DNA(rDNA)簇的组成都是有规律的，转录单位和非转录间隔区交互排列，而每个转录单位主要由rRNA和连接前体组成。<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-202209182109276710.png" alt="image-20220918210927670"></li>
<li></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-4"><a href="#Inexplicable-points-4" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><ul>
<li>同源重组的机理是什么?<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/2620221026102047.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="Chromosome"><a href="#Chromosome" class="headerlink" title="Chromosome"></a>Chromosome</h3><h4 id="Terminology-5"><a href="#Terminology-5" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>包装率(packing ratio): 即DNA的长度除以包装后的长度。</li>
<li>nucleoid-associated protein: NAP,类似于真核生物染色体蛋白；</li>
</ul>
<h4 id="Key-concepts-3"><a href="#Key-concepts-3" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li><p>病毒capsid包装：</p>
<ul>
<li><p>蛋白质外壳沿着核酸组装，在组装过程中利用蛋白质-核酸之间的相互作用来浓缩DNA或RNA。</p>
<ul>
<li>烟草花叶病毒TMV组装起始于RNA的两双链发夹结构，为成核中心；</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220919080922105.png" alt="image-20220919080922105"></li>
<li>每加一层蛋白质亚基，就抓住一段RNA；</li>
</ul>
</li>
<li><p>衣壳可以被组建成一个中空外壳，核酸在被装进去时，或者在进入的过程中被浓缩。多球状capsid；</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220919081044456.png" alt="image-20220919081044456"></li>
<li>λ噬菌体成熟过程中，capsid随DNA进入而改变；</li>
</ul>
</li>
</ul>
</li>
<li><p>将DNA包装进入噬菌体头部包括两类反应：移位和凝聚，这两个过程从能量的角度上讲都是不利的。</p>
<ul>
<li>移位：进行滚环复制后产生长DNA，末端酶(terminase)对其cos site切割产生粘性末端，末端酶接着将其转移到capsid；<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220919082650076.png" alt="image-20220919082650076"></li>
</ul>
</li>
<li><p>HU蛋白可非特异性地结合与多个位点，但对扭曲的DNA区域具有一定偏爱性；</p>
</li>
</ul>
<h4 id="Inexplicable-points-5"><a href="#Inexplicable-points-5" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="The-DNA-replication-related-to-Cell-circle"><a href="#The-DNA-replication-related-to-Cell-circle" class="headerlink" title="The DNA replication related to Cell circle"></a>The DNA replication related to Cell circle</h3><h4 id="Terminology-6"><a href="#Terminology-6" class="headerlink" title="Terminology"></a>Terminology</h4><h4 id="Key-concepts-4"><a href="#Key-concepts-4" class="headerlink" title="Key concepts:**"></a>Key concepts:<em>**</em></h4><ul>
<li>细胞周期的起始：<ul>
<li>假设1：起始子蛋白不断合成，达到一定浓度后，就出发其实反映；</li>
<li>假设2：抑制蛋白随着细胞体积的增大浓度稀释到有效浓度以下；</li>
</ul>
</li>
<li>细菌一次复制完成(分裂启动)前，另一个复制周期又开始了，从而造成多复制叉染色体(复制得到的子链又形成复制叉)；<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220921103546173.png" alt="image-20220921103546173"></li>
</ul>
</li>
<li></li>
</ul>
<h4 id="Inexplicable-points-6"><a href="#Inexplicable-points-6" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="The-Transpooson-and-Retrovirus"><a href="#The-Transpooson-and-Retrovirus" class="headerlink" title="The Transpooson and Retrovirus"></a>The Transpooson and Retrovirus</h3><h4 id="Terminology-7"><a href="#Terminology-7" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>Insertion sequence: 插入序列，后加数字代表他们被分离的先后顺序。<ul>
<li>细菌操纵子的自发插入物，其插入阻止了被插入基因的转录和（或）翻译。</li>
<li>以末端反向重复序列结尾。两序列密切相关但并非<strong>完全一致</strong>；<ul>
<li>这一区域的存在意味着不管朝哪一侧移动，都能遇到相同序列。</li>
</ul>
</li>
<li>转座时，插入位点处宿主DNA被复制。<ul>
<li>该靶序列为复制为同向重复(direct repeat)，分布于IS两侧；</li>
<li>这一重复序列产生的原因是靶DNA的交错断裂产生粘性末端；<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220926091744110.png" alt="image-20220926091744110"></li>
</ul>
</li>
<li>末端的顺式作用突变可以阻止转座，这一突变可被负责转座的蛋白，转座酶(transposase)所识别;</li>
<li>含有单一长编码区，从一侧反向重复内侧到另一侧之前或其中，负责编码<strong>转座酶</strong>。</li>
</ul>
</li>
<li>II类因子：或称DNA型因子。直接操作DNA，并在基因组内自我繁殖。</li>
<li>I类因子：反转录因子。基于自身的RNA转录物制备出DNA拷贝，再整合进基因组中新位点。</li>
<li>long terminal repeat(LTR) retrotransposon: 长末端重复反转录转座子，在总体结构和转座机制上，他们和反转录原病毒很相似。<ul>
<li>也称retrotransposon；</li>
</ul>
</li>
<li>retroposon：反转录子，同样利用反转录酶，但是没有LTR，有独特转座模式。称为非LTR反转录转座子。</li>
<li>replicative transposition : 复制型转座, 转座子被重复，转座的实体是原来序列的拷贝；<ul>
<li>转座酶：在原转座子的末端起作用；</li>
<li>解离酶(resolvase)：对倍增拷贝起作用；</li>
</ul>
</li>
<li>precise excision : 转座子发生重组后，细菌酶去掉转座子和重复序列的一份拷贝。<ul>
<li>imprecise excision: 留下转座子的残余序列，阻止靶基因的重新激活；    <ul>
<li>这一切除的频率高于准确切除；</li>
</ul>
</li>
</ul>
</li>
<li>cointegrate : 共整合。复制性转座中出现的结构：<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928102325564.png" alt="image-20220928102325564"></li>
<li>链转移复合体的3’端作为复制的引物，产生一个称为共整合(cointegrate)的结构，它由两个原始分子融合而成。</li>
<li>共整合结构含有转座子的<strong>两份拷贝</strong>，每一份拷贝位于两个原始复制子之间的一个连接处，为<strong>同向重复序列</strong>(不管从哪个方向都是同向)。而转座酶则可使之产生交换反应。它转变成共整合还需要宿主的复制功能。</li>
<li>解离过程需要<strong>解离酶</strong>；</li>
</ul>
</li>
<li>链转移复合体：也称交换复合体：<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928102810568.png" alt="image-20220928102810568"></li>
<li>交错末端的<strong>单链区</strong>，是拟复制叉(pseudoreplication fork);</li>
</ul>
</li>
<li>自主转座子(autonomous transposon)具有切除和转座能力。</li>
<li>非自主转座子(nonautonomous transposon)是稳定的；正常情况下，它们不转座或不允许其他的自发改变。只有在基因组内存在同一家族的自主转座子才能发生转座;</li>
</ul>
<h4 id="Key-concepts-5"><a href="#Key-concepts-5" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li><a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1577-z">Ten things you should know about transposable elements</a></li>
<li>必须要RNA中间体参与的转座是真核生物独有的。<ul>
<li>这一转座必须要运用某些形式的反转录酶。</li>
</ul>
</li>
<li><p>转座基本反应:</p>
<ul>
<li>转座子的两末端通过酶切反应从供体DNA上分离出来，产生3’羟基(3OH)端。</li>
<li>通过转移反应，暴露末端与靶DNA相连接，这个过程涉及转酯作用(transesterification),使3’-OH端直接攻击靶DNA。</li>
<li>这些反应发生在一个<strong>核酸蛋白复合体</strong>内，该复合体包含必需的酶和转座子的<strong>两个末端</strong>。</li>
<li>不同转座子的差别在于靶DNA被转座子识别的时间是否处于其自身被切割的之前或之后，以及转座子的两个末端中一条链或两条链是否在整合前被切割。</li>
</ul>
</li>
<li><p>当转座子将其<strong>另一份拷贝</strong>插入原来位点附近的<strong>第二个位置时</strong>，可能会导致宿主DNA重排，宿主系统可能造成该转座子的两份拷贝之间发生交互重组，其结果取决于其重复序列是<strong>同向的</strong>还是<strong>反向的</strong>。</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-202209128100649540.png" alt="image-20220928100649540"></li>
<li>两份同向重复序列交互重组会把两者之间的序列切除(以环状DNA形式)，包括一份重复序列。</li>
</ul>
</li>
<li><p>反向重复序列：两个重复序列之间的区域被倒位：重复序列自身还可进一步产生倒位。一个反向的复合转座子是基因组稳定的组件，尽管中心区的方向可能因重组而倒位。</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928101322228.png" alt="image-20220928101322228"></li>
<li>两重复序列之间区域可能反向；</li>
</ul>
</li>
<li><p>非复制转座的原理：链的断裂和重接</p>
<ul>
<li>靶序列通过插入转座子而重建，供体链仍处于断开状态，不形成共整合结构；</li>
</ul>
</li>
<li><p>非复制转座：两种形式：</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928105604946.png" alt="image-20220928105604946"></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928105827342.png" alt="image-20220928105827342"></li>
</ul>
</li>
<li><p>转座子切割过程：<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220928110834962.png" alt="image-20220928110834962"></p>
<ol>
<li>切开一条DNA链</li>
<li>释放3-OH端攻击另一条链，切割位点5‘侧序列被释放</li>
<li>转座子的两条链形成发夹结构</li>
<li>激活的H~2~O分子攻击发夹结构</li>
</ol>
</li>
<li>T10复合转座子:Tn10复合转座子的两条链依次被切断，接着转座子与已切断的靶位点连接起来;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/1420221114110610.png" alt=""></li>
</ul>
</li>
<li>T5转座子:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/1420221114110637.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-7"><a href="#Inexplicable-points-7" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="Prokaryote-transcription"><a href="#Prokaryote-transcription" class="headerlink" title="Prokaryote transcription"></a>Prokaryote transcription</h3><h4 id="Terminology-8"><a href="#Terminology-8" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>transcription unit: 从启动子到终止子的一段序列；<ul>
<li>最先转录成RNA的第一个碱基对为转录起点；</li>
<li>启动子5‘端序列为上游，3’端序列为下游；</li>
</ul>
</li>
<li>transcription bubble：转录泡，RNA聚合酶将DNA分开，形成两条暂时的单链。<ul>
<li>转录泡随着合成，逐渐迁移，其后的DNA重新形成双链；</li>
</ul>
</li>
<li>unwinding point：解链点，RNA聚合酶在转录泡前端解开双链；<ul>
<li>rewinding point: 再螺旋点，在泡的后端重新聚合；</li>
</ul>
</li>
<li><p>abortive initiation: 流产起始，任何一个碱基插入后，聚合酶都有释放RNA链的可能性，导致流产起始(abortive initiation)产物的产生。</p>
<ul>
<li>在释放出流产起始产物后，聚合酶又从+1开始合成第一个碱基。</li>
<li>流产起始的往复循环常常产生长度为几个碱基的寡核苷酸，有时可多达<strong>20nt</strong>,直到酶<strong>真正成功地离开启动子</strong>。</li>
</ul>
</li>
<li><p>down mutation:大多数细菌启动子的突变可造成相关基因转录物的丢失或是大幅度减少；</p>
<ul>
<li>启动子突变使得转录水平增加的则为上调突变(up mutation);</li>
</ul>
</li>
</ul>
<h4 id="Key-concepts-6"><a href="#Key-concepts-6" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li>转录发生速度约为40-50bp/s，翻译速度大致相同,约为15 aa/s, 但比DNA复制速度慢得多，约为800bp/s。</li>
<li>转录泡长度约为12-14bp，但是RNA-DNA杂合链长度只有8-9bp；<ul>
<li>在转录的任一时刻，正在生长的RNA链上的最后约14个核苷酸与DNA和（或）酶以复合体的形式存在。</li>
</ul>
</li>
<li>转录起始过程：<ul>
<li>RNA聚合酶结合于启动子序列，DNA维持双链，形成closed complex；</li>
<li>将DNA双链解开，形成open complex；</li>
</ul>
</li>
<li>在细菌中，m/r/tRNA由单一的RNA聚合酶合成，在真核生物中则分别有I/II/III合成；</li>
<li>细菌中RNA聚合酶各亚基的功能：<ul>
<li>两α亚基：负责酶的装配，启动子识别，激活因子识别；</li>
<li>ββ’亚基：催化中心；</li>
<li>σ亚基：改变RNA聚合酶与DNA结合的特性，使得对普通DNA序列亲和性降低，对启动子亲和性增高；<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20220930100149146.png" alt="image-20220930100149146"></li>
<li>核心酶对DNA有均等的亲和力，全酶中结合常数被降低为1/10^4^,与启动子结合常数为10^3^;</li>
<li>σ亚基在聚合酶合成了近10nt时被释放；</li>
</ul>
</li>
</ul>
</li>
<li><p>RNA寻找启动子序列方式：</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20221003161739315.png" alt="image-20221003161739315"></li>
<li><p>这一假设作用方式为：RNA聚合酶形成和破坏一系列闭合复合体，直至遇到启动子形成开放复合体；</p>
<ul>
<li>这一随机过程，收到速度常数的限制速度过慢，不符合实际，故有其他加速的方式；</li>
</ul>
</li>
<li><p>第一，酶可能以一维随机步移的方式沿DNA迁移，这称为“滑动(sliding)”。</p>
</li>
<li>第二，在细菌拟核中存在染色体错综复杂的折叠形式，当酶结合于染色体的某一序列时，酶可能与其他位点靠得很近，这样降低了解离并与另一个位点重新结合的时间，这称为“区段内转移或跳跃(intersegment transfer or hopping)”。</li>
<li>第三，当RNA聚合酶非特异性地结合于某一位点时，它能交换DNA位点直到启动子被发现，这称为“直接转移(direct transfer)”。</li>
</ul>
</li>
<li><p>RNA聚合酶与DNA结合过程中出现的变化：</p>
<ul>
<li><p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20221003162740257.png" alt="image-20221003162740257"></p>
<ul>
<li>注意-35区位置。</li>
<li>三元复合体指RNA，DNA，聚合酶；</li>
</ul>
</li>
<li><p>DNA出现约90°的弯曲，这使得模板能接近于聚合酶的活性位点；</p>
</li>
<li>在转录起点中，-11到+3之间的启动子DNA的链被打开；</li>
<li>将启动子DNA挤入活性通道，形成转录泡；</li>
<li>聚合酶的“颌”结构闭合以包围转录起始位点下游的启动子部分。这样，在开放复合体上的启动子接触面就可向外延伸，从-55到+20。</li>
</ul>
</li>
<li><p>启动子复合体到延伸复合体的转变：</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20221003163709292.png" alt="image-20221003163709292"></li>
</ul>
</li>
<li><p>一个启动子是根据在特定位置存在的共有短序列来定义的。</p>
<ul>
<li>对于细菌来说，能够提供足够信号最小长度为12bp，这12bp可以不相邻；</li>
<li>随着基因组长度增加，特异性识别所需最小长度也增加；</li>
<li>如果碱基数恒定的短序列被<strong>某一特定数目的碱基对</strong>所隔开，它们若组合到一起，<strong>长度可短于12bp</strong>,因为所形成的碱基之间的距离本身也提供了部分信息（即使中间序列本身是不相关的）。</li>
</ul>
</li>
<li><p>在大肠杆菌中，启动子序列缺乏广泛的序列保守性。</p>
<ul>
<li>有一些小段是保守的，只存在很短的共有序列是调节位点的典型特征；</li>
</ul>
</li>
<li><p>细菌中，启动子最重要的两元件为两6bp元件，-10区和-35区；其次则为-10区，-35区上下游元件；<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/image-20221003165249112.png" alt="image-20221003165249112"></p>
<ul>
<li>-10区元件 ：别名Pribnow Box，TATA Box(该名称主要用于真核生物中的相似序列)；以-10bp处为中心；<ul>
<li>$T<em>{80}A</em>{95}T<em>{45}A</em>{60}A<em>{50}T</em>{96}$, 下标为碱基出现最大频率，对应于其结合重要性；</li>
<li>认为-10区<strong>中前端高度保守的TA</strong>和末尾一个<strong>几乎完全保守的T</strong>是启动子识别中最重要的碱基；</li>
<li>在闭合复合体中为双链，在开放复合体为单链；</li>
</ul>
</li>
<li>-35区元件：以-35处为中心；<ul>
<li>在闭合和开放复合体中是相似的；</li>
<li>$T<em>{82}T</em>{84}G<em>{78}A</em>{65}C<em>{54}A</em>{45}$;</li>
</ul>
</li>
<li>间隔区序列：长度约为16-18bp；<ul>
<li>真实序列不重要，但是距离很重要；</li>
<li>因为DNA螺旋的本性是与生俱来的，所以它不仅决定了RNA聚合酶中<strong>相互作用的两个区域的恰当分开</strong>，而且还决定了<strong>两个位点彼此之间的空间定向</strong>。</li>
</ul>
</li>
<li>转录起点：90%都为嘌呤，典型为腺嘌呤；<ul>
<li>以CAT序列为中心？</li>
</ul>
</li>
<li>extended -10 elements: 在启动子缺乏-35区但接近共有序列时，其TGN序列能够弥补这一弱匹配；</li>
<li>discriminator：-10区下游，在-10与起点之间，能够识别σ因子；<ul>
<li>大小为<strong>碱基对</strong>；</li>
</ul>
</li>
<li>UP元件：-35区上游的10-20bp序列。与两个α亚基的CTD区域作用，在一些高表达的基因的序列中，它能够极大地增加转录；<ul>
<li>只有当它与共有序列<strong>非常匹配</strong>时才将其称作<strong>UP元件</strong>；</li>
</ul>
</li>
</ul>
</li>
<li>上调突变大多是<strong>增大了-35区和-10区与共有序列的相似性</strong>，或使<strong>两个保守六联体之间的距离更接近17bp</strong>:<ul>
<li>而下调突变大多<strong>降低了它们与共有序列的相似性</strong>，或是使间隔距离大于17bp,而且下调突变倾向于集中在有最高保守度的启动子位置上。</li>
</ul>
</li>
<li>与共有序列(12 bp)完美匹配的启动子弱于存在至少一处错配的启动子，这是因为结合过于紧密影响了启动子逃逸；</li>
<li></li>
</ul>
<h4 id="Inexplicable-points-8"><a href="#Inexplicable-points-8" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="Karyote-transcription"><a href="#Karyote-transcription" class="headerlink" title="Karyote transcription"></a>Karyote transcription</h3><h4 id="Terminology-9"><a href="#Terminology-9" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>转录因子: 转录起始过程必需的<strong>蛋白质</strong>中非RNA聚合酶成分的部分;<ul>
<li>转录因子可以结合DNA,也可以识别别的因子,或者识别RNA聚合酶;  </li>
</ul>
</li>
<li>核心启动子: 含有所有RNA聚合酶的结合与功能发挥必需的结合位点;</li>
<li>双向启动子: 位于两个相邻且转录方向相反的基因之间的一段DNA序列</li>
<li>TBP: TATA-binding protein, TATA结合蛋白. 三种RNA聚合酶<strong>起始转录</strong>的必需因子; </li>
</ul>
<h4 id="Key-concepts-7"><a href="#Key-concepts-7" class="headerlink" title="Key concepts"></a>Key concepts</h4><ul>
<li>真核与原核生物转录的差别:<ul>
<li>原核:发生在DNA模板上;真核:发生在染色质模板上;</li>
<li>原核:RNA pol通过σ因子解读DNA序列;真核:不能解读DNA;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1020221010083937.png" alt=""><ul>
<li>不同RNA聚合酶功能;</li>
</ul>
</li>
<li>mRNA是三种主要RNA中丰度最低的一个,约占2-5%;</li>
<li>RNA聚合酶I:<ul>
<li>含有一个双向启动子, 且除核心启动子外,还有一个UPE;</li>
<li>SL1复合体: 与核心启动子结合,含两TBP;</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-9"><a href="#Inexplicable-points-9" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4><h3 id="Gene-expression-regulation"><a href="#Gene-expression-regulation" class="headerlink" title="Gene expression regulation:"></a>Gene expression regulation:</h3><h4 id="Terminology-10"><a href="#Terminology-10" class="headerlink" title="Terminology:"></a>Terminology:</h4><ul>
<li>顺式作用:顺式作用的概念适用于只以DNA形式起作用的DNA序列，只影响与其直接相连的DNA序列。<ul>
<li>反式作用:基因是编码可扩散产物的DNA序列，这种产物可以是蛋白质，也可以是RNA。任何基因产物自由扩散至其作用靶标的过程称为反式作用</li>
</ul>
</li>
<li>negative control:通过阻遏物来抑制基因表达;<ul>
<li>operator:操纵基因, 阻遏物的结合位点;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017085605.png" alt=""></li>
</ul>
</li>
<li>positive control:通过正调节物来开启基因表达;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017085801.png" alt=""></li>
</ul>
</li>
<li>induction:在特殊的代谢物或化合物的作用下,由关闭变为工作状态;</li>
<li>repression:特殊代谢或者化合物的积累作用下,由工作转变为关闭状态;<ul>
<li>阻遏不是完全关闭转录,而是将其降低至1/5 or 1/100;</li>
</ul>
</li>
<li>corepressor:如果某种物质能够阻止细菌产生合成这种物质的酶， 这种物质就是辅阻遏物; </li>
<li>constitutive expression:表达速率保持恒定的基因表达;<ul>
<li>constitutive mutation:生成可持续表达的基因,也即组成型表达;</li>
</ul>
</li>
<li>interalletic complementation: 等位基因间互补,阻遏物往往能形成多聚物,从而阻遏物亚基能够随机结合,不论是哪个基因</li>
<li>分解代谢物阻遏(catabolite repression):大肠杆菌lac操纵子是负可诱导的。<ul>
<li>乳糖的存在可以除去lac阻遏物，这样转录就开启了。</li>
<li>然而，这一操纵子也受到第二层控制，即细菌如果存在足够的葡萄糖供给，那么乳糖也不能开启这一系统。</li>
<li>这一现象的基础是：葡萄糖是一种比乳糖更好的能量来源，所以如果可以获得葡萄糖，那么就没有必要开启lac操纵子。</li>
</ul>
</li>
<li>autoregulated: 自体调节;<ul>
<li>trpR调节基因受其自身产物tp阻遏物的阻遏。这种阻遏物的作用可降低其合成;</li>
</ul>
</li>
</ul>
<h4 id="Key-concepts-8"><a href="#Key-concepts-8" class="headerlink" title="Key concepts:"></a>Key concepts:</h4><ul>
<li>负控制与正控制、可诱导控制与可阻遏控制可以分别组合在一起，形成不同类型的可能调节回路<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017090101.png" alt=""></li>
<li>负控制+诱导(正控+阻遏):诱导实际上暗示了基因的状态为关闭,负控制说明这一关闭是由于激活的阻遏物引起的,而非失活的激活物引起的;</li>
<li>负控+阻遏(正控+诱导):负控和阻遏是一致作用,而负控需要阻遏也即是说原来的阻遏物失活,需要辅阻遏物;</li>
<li>元件:<ul>
<li>负控制元件:阻遏物;</li>
<li>诱导元件:诱导物;</li>
<li>正控制元件:激活物;</li>
<li>阻遏元件:辅阻遏物;</li>
</ul>
</li>
</ul>
</li>
<li>原核生物以负调控为主，真核生物以正调控为主。</li>
<li><em>lac</em>操纵子:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017091849.png" alt=""></li>
<li>由三个基因lacZ、lacY和lacA组成;</li>
<li>lacZ:编码β-半乳糖苷酶,催化β-半乳糖苷分解单糖;</li>
<li>lacY:编码β-半乳糖苷通透酶,转运β-半乳糖苷入细胞</li>
<li>lacA:编码β-半乳糖转乙酰基酶,将乙酰从乙酰辅酶A(Acetyl-CoA)转移到β-半乳糖苷上;(可能是用于排出有害的β-<strong>半乳糖苷类似物</strong>)</li>
<li>lacI:编码可扩散产物,阻遏物(蛋白质);<ul>
<li>其启动子与RNA聚合酶结合效率低,同时由于缺少5’-UTR,起始翻译的能力较低,导致该阻遏物的丰度较低;</li>
</ul>
</li>
<li>操纵基因:阻遏物可以与之结合阻止转录,含有反向重复序列(转座子?);<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019103416.png" alt=""></li>
<li>阻遏物-操纵基因结合的另个关键元件一铰链螺旋插入到操纵基因DNA的小沟中，这使DNA弯折45°。这种弯曲使大沟可定向用于HTH结合。</li>
</ul>
</li>
<li>诱导物和辅阻遏物:往往与底物或产物结构高度相似;<ul>
<li>对于lac系统来说一个经典的诱导剂就是IPTG,能诱导酶的合成但是不被酶解的分子,也称为安慰诱导物(gratuitous inducer)</li>
<li>lac阻遏物:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018143459.png" alt=""></li>
<li>诱导物与阻遏物结合,阻遏物形变,失去功能:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018143546.png" alt=""><ul>
<li>IPTG改变lacI编码的阻遏物的空间结构,破坏了铰链螺旋,从而使得阻遏物与DNA结合亲和力下降;</li>
</ul>
</li>
</ul>
</li>
<li>操纵子的排列:越重要的酶排列越靠前;<ul>
<li>三种酶的相对数量保持相对恒定;</li>
</ul>
</li>
<li>操纵子存在一个基础表达,以相当低的速度转录,从而保证体内存在通透酶,能够将诱导物吸收进体内;</li>
</ul>
</li>
<li>操纵基因的鉴定:<ul>
<li>组成型表达的根源实质上是缺少表达的抑制,从而一直表达;</li>
<li>故而组成型表达可分为两类:反式作用(调节基因突变),顺式作用(操纵基因,启动子突变)</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018151659.png" alt=""><ul>
<li>顺式显性作用:假设操纵基因突变,另外有别的启动子无法替代;</li>
</ul>
</li>
</ul>
</li>
<li>调节基因:<ul>
<li>反式隐性:$lacI^-$突变,无法结合操纵基因,但只要有别的lac基因能正常表达,即可正常调控操纵子;<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018152847.png" alt=""></li>
<li>反式显性:$lacI^{-d}$突变,DNA结合区域受损;<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018153014.png" alt=""></li>
<li>反式显性:$lac^{-s}$突变使得阻遏物无法结合或者应答诱导物,产生不可诱导型突变体;</li>
</ul>
</li>
<li>阻遏物:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019101310.png" alt=""><ul>
<li>末端的螺旋-转角-螺旋是常见的<strong>DNA结合基序</strong>,</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019102342.png" alt=""></li>
</ul>
</li>
<li>所有阻遏物都结合于DNA!<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019104309.png" alt=""><ul>
<li>阻遏物可以结合非特异性位点,即低亲和力位点,所有碱基对都可以是低亲和力位点;</li>
</ul>
</li>
</ul>
</li>
<li>lac的分解代谢物<strong>阻遏</strong>系统:<ul>
<li>CRP:部分启动子转录需要辅助蛋白的参与,即依赖性启动子所必需的,又CRP需要结合cAMP才有活性,形成正控诱导体系;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/2420221024083153.png" alt=""></li>
<li>又高水平葡萄糖可以阻遏腺苷酸环化酶活性,减少cAMP,使得转录无法激活;</li>
<li>CRP结构:相同亚基形成的二聚体,被单个cAMP激活,从弱结合变为强结合,<strong>且识别特异序列</strong>,两个反向五联体序列(两个亚基中心对称);</li>
<li>CRP能够使得DNA在中心对称处将DNA弯曲90°以上,可能对转录直接作用,也可能只是便于RNA聚合酶结合;</li>
</ul>
</li>
<li>trp操纵子自身处于负可阻遏控制。这意味着trpR基因产物—阻遏物是以失活负调节物形式制备出来；而阻遏是指rp操纵子产物色氨酸是p阻遏物的辅调节物。</li>
</ul>
<h4 id="inexplicable-points"><a href="#inexplicable-points" class="headerlink" title="inexplicable points:"></a>inexplicable points:</h4><ul>
<li>阻遏物加速诱导?<ul>
<li>阻遏物与DNA的结合实际上能增强RNA聚合酶结合DNA的能力，只是结合的RNA聚合酶不能起始转录。</li>
<li>阻遏物实际上将RNA聚合酶储存于启动子上。加入诱导物后，阻遏物释放，RNA聚合酶能马上起始转录。</li>
</ul>
</li>
</ul>
<h3 id="真核生物的转录调节"><a href="#真核生物的转录调节" class="headerlink" title="真核生物的转录调节:"></a>真核生物的转录调节:</h3><h4 id="Terminology-11"><a href="#Terminology-11" class="headerlink" title="Terminology"></a>Terminology</h4><h4 id="Key-concept"><a href="#Key-concept" class="headerlink" title="Key concept"></a>Key concept</h4><ul>
<li>真核生物中基因表达大多是在转录起始时受开放染色质控制的。<ul>
<li>许多基因拥有多个启动子，而对启动子的选择可改变调节模式，能影响mRNA的利用，因为会改变5’-UTR;</li>
</ul>
</li>
<li>基因表达控制可分为五个节点:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/2620221026103059.png" alt=""><ul>
<li>转录起始控制</li>
<li>RNA修饰和加工</li>
<li>转运控制</li>
<li>翻译过程</li>
<li>降解调节</li>
</ul>
</li>
</ul>
</li>
<li>基因存在着两种结构状态。<ul>
<li>第一种是闭合染色质中的非活性基因；</li>
<li>第二种是只有在基因表达或潜在表达的细胞里，此时基因处于“活性”状态，或位于开放染色质中。其结构的改变发生在转录开始之前，这表明基因可以被转录的;</li>
</ul>
</li>
<li>在单倍体配子中,染色体以高度凝聚,经修饰的染色质状态存在;</li>
<li>基因的启动:<ul>
<li>一些转录因子可能在复制叉之后与组蛋白竞争结合DNA。<ul>
<li>封闭染色质可能通过暂时性置换组蛋白八聚体从而打开染色质结构</li>
<li>如果有机体含有足够高浓度的转录因子，那么染色质可被打开；</li>
<li>而如果转录因子浓度较低，那么随后核小体就会结合和凝聚这一区域。</li>
</ul>
</li>
<li>一些转录因子可识别“封闭”染色质中的靶标以起始转录。<ul>
<li>这些转录因子能募集组蛋白修饰蛋白和染色质重塑子;</li>
<li>可以开启基因区段,或者是移除启动子结合的障碍物;</li>
</ul>
</li>
<li>基因组被边界元件（绝缘子）分成多个结构域。</li>
<li>绝缘子可阻断染色质修饰从一个结构域向另一个结构域扩散。</li>
</ul>
</li>
<li>真核生物的正控制:<ul>
<li>真激活物(true activator): 转录因子, 与启动子上基础转录装置发生直接接触发挥功能; 该激活物的调控模式如下:<br>a. 组织特异性转录因子只在特定细胞类型中合成; 调节发育的因子, 同源异形蛋白(homeoprotein或homeodomainprotein);<br>b. 转录因子活性可由修饰直接控制(如磷酸化激活);<br>c. 转录因子可通过配体的结合被激活或失活<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/0920221109100843.png" alt=""><br>d. 转录因子的有效性可能存在差异<br>e. 二聚体转录因子可存在不同的配偶体。一种配偶体可使之失活，而活性配偶体的合成可取代失活形式;尤其在螺旋-环-螺旋(helix-loop-helix,HLH)蛋白中<br>f. 转录因子可从非活性前体中被切割出来<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/0920221109101004.png" alt=""></li>
<li>抗阻遏物(antirepressor):在这些激活物中，当其中一种结合于增强子时，它会募集组蛋白修饰酶和（或）染色质重塑复合体，将染色质从封闭状态转变成开放状态。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/0920221109104202.png" alt=""><br>a. 阻遏物将激活物隔离于细胞质中<br>b. 阻遏物结合与激活物从而使其活性失效<br>c. 或者阻遏物被掩盖且固定于细胞质, 直到被释放后进入细胞核, 结合激活物<br>d. 阻遏物与激活物竞争结合位点;</li>
<li>构筑蛋白(architectural protein,如阴阳（Yin-Yang)蛋白。这些蛋白质的作用是使DNA弯曲，将结合的蛋白质聚集在一起，并形成协同复合体；或使DNA往相反方向弯曲而阻止复合体的形成;<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/0920221109104244.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="Inexplicable-points-10"><a href="#Inexplicable-points-10" class="headerlink" title="Inexplicable points"></a>Inexplicable points</h4>]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>biology</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript学习笔记</title>
    <url>/2022/10/07/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Javascript简介"><a href="#Javascript简介" class="headerlink" title="Javascript简介"></a>Javascript简介</h2><h3 id="Javascript的特性"><a href="#Javascript的特性" class="headerlink" title="Javascript的特性"></a>Javascript的特性</h3><p>与其他语言的不同之处:</p>
<ol>
<li>在JavaScript 中，函数与其他对象共存，并且能够像任何其他对象一样地使用。函数可以通过字面量创建，可以赋值给变量，可以作为函数参数进行传递，甚至可以作为返回值从函数中返回。</li>
<li>函数闭包</li>
<li>JavaScript 还没有(类似C语言中的)块级作用域下的变量，取而代之则只能依赖函数级别的变量和全局变量.</li>
<li>不同于其他主流的面向对象语言(例如C#、Java、Ruby)使用基于类的面向对象，JavaScript 使用基于原型的面向对象</li>
</ol>
<p>特殊的功能, 特性:</p>
<ol>
<li>生成器, 一种可以基于一次请求生成多次值的函数,在不同请求之间也能挂起执行.</li>
<li>Promise，让我们更好地控制异步代码。</li>
<li>代理，让我们控制对特定对象的访问。 </li>
<li>高级数组方法，书写更优雅的数组处理函数。 </li>
<li>Map，用于创建字典集合；Set，处理仅包含不重复项目的集合。 </li>
<li>正则表达式，简化用代码书写起来很复杂的逻辑。</li>
<li>模块，把代码划分为较小的可以自包含的片段，使项目更易于管理。 </li>
</ol>
<p>转换编译器: </p>
<ul>
<li>当新的标准制定, 新的特性出现时, 部分用户往往仍然使用老旧的浏览器, 一种解决方法是使用转换编译器, 将较新的Js代码转化为等价的, 能在当前浏览器运行的代码. </li>
<li>Traceur 和 Babel是较为流行的两种</li>
</ul>
<h3 id="理解浏览器"><a href="#理解浏览器" class="headerlink" title="理解浏览器"></a>理解浏览器</h3><p>浏览器环境概念:</p>
<ol>
<li>文档对象模型(DOM): Web应用的结构化的UI表现形式, 最初由web应用的HTML代码构成;</li>
<li>事件: 大部分JavaScript 应用都是事件驱动的应用，这表示大部分代码执行在对某个特殊事件响应的上下文中。<ol>
<li>如网络事件、计时器、用户生成事件例如点击、鼠标移动、键盘按压事件等。</li>
</ol>
</li>
<li>浏览器 API: 获取设备的信息、存储本地数据或与远程浏览器交互的API。</li>
</ol>
<p>调试工具: 探索 DOM、调试 JavaScript、编辑 CSS 样式和跟踪网络事件等。</p>
<p>测试: assert(condition, message); 第一个参数是一个应为真值的条件，第二个参数是当断言为假时所展示的一句话。</p>
<p>性能分析: 把要被测量的代码放在两个计时器调用之间;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;My operation&quot;</span>); <span class="comment">//My operation是名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* codes to count*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;My operation&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>跨平台开发: 通过使用浏览器和 Node.js(源自于浏览器的环境)，你能够开发几乎你能想到的任何类型的应用。</p>
<ul>
<li>桌面应用，通过使用如<a href="http://nwjs.io/">NW.js</a>或<a href="http://electron.atom.io/">Electron</a>的库可以开发桌面应用。<ul>
<li>包装javascript和浏览器核心</li>
</ul>
</li>
<li>移动应用，使用类似<a href="https://cordova.apache.org/">Apache Cordova</a>的框架开发。</li>
<li>使用Node.js 开发服务器端应用和嵌入式应用，Node.js 是源自于浏览器的环境，使用了很多类似浏览器的底层原理。</li>
</ul>
<hr>
<h2 id="浏览器页面构造过程"><a href="#浏览器页面构造过程" class="headerlink" title="浏览器页面构造过程"></a>浏览器页面构造过程</h2><p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007182914.png" alt="FIG 1"></p>
<figure>Fig 1.1 web应用的生命周期</figure>

<p>主要由两个步骤构成: 页面构建和事件处理;</p>
<h3 id="页面构建"><a href="#页面构建" class="headerlink" title="页面构建"></a>页面构建</h3><p>又分为两个步骤, 在页面构建过程中交替进行;</p>
<ol>
<li>解析HTML代码并构建文档对象模型(DOM);</li>
<li>执行 JavaScript 代码. 当遇到脚本节点时执行;</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007185241.png" alt=""></p>
<figure> HTML 解析和 DOM 构建</figure>

<p>尽管 DOM 是根据 HTML 来创建的，两者紧密联系，但需要强调的是，它们两者并不相同。你可以把 HTML 代码看作浏览器页面 UI 构建初始DOM 的蓝图。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007185615.png" alt=""></p>
<figure>浏览器修正了错误的HTML代码</figure>

<p>当页面构建遇到脚本元素时, 会暂停构建DOM转而执行JavaScript代码;</p>
<p>DOM与脚本的关系: </p>
<ol>
<li>window 对象是获取所有其他全局对象、全局变量（甚至包含用户定义对象）和浏览器 API 的访问途径。</li>
<li>全局 window 对象最重要的属性是 document，它代表了当前页面的 DOM。<ul>
<li>通过使用这个对象，JavaScript 代码就能在任何程度上改变 DOM</li>
</ul>
</li>
</ol>
<p>全局代码与函数代码:</p>
<ol>
<li>函数代码指的是包含在函数中的代码,全局代码指的是位于函数之外的代码; </li>
<li>全局代码以一种直接的方式自动执行，每当遇到这样的代码就一行接一行地执行。</li>
<li>函数代码必须被调用才执行;</li>
</ol>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>浏览器处理代码特性: </p>
<ul>
<li>浏览器同一时刻只能执行一个代码片段，即所谓的单线程执行模型。</li>
<li>所有生成的事件都被放在同一个事件队列中(注册事件监听器), 从头部开始被处理;</li>
</ul>
<p>事件类型:</p>
<ul>
<li>浏览器事件，例如当页面加载完成后或无法加载时；</li>
<li>网络事件，例如来自服务器的响应（Ajax 事件和服务器端事件）； </li>
<li>用户事件，例如鼠标单击、鼠标移动和键盘事件；</li>
<li>计时器事件，当timeout 时间到期或又触发了一次时间间隔。</li>
</ul>
<p>注册事件监听器方式:</p>
<ul>
<li>通过把函数赋给某个特殊属性；<ul>
<li><code>window.onload = function()&#123;&#125;;</code>, 将函数赋值给<code>window</code>对象的<code>onload</code>属性;</li>
<li>这一方式的缺陷在于对于一个事件只能注册一个事件处理器, 创建新的处理器时会将上一个给改写掉;</li>
</ul>
</li>
<li>通过使用内置addEventListener方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">//#为mousemove事件注册处理器 </span></span><br><span class="line">        <span class="keyword">var</span> second = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="title function_">addMessage</span>(second, <span class="string">&quot;Event: mousemove&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;		   <span class="comment">//#为 click 事件注册处理器</span></span><br><span class="line">        <span class="keyword">var</span> second = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="title function_">addMessage</span>(second, <span class="string">&quot;Event: click&quot;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数与对象"><a href="#函数与对象" class="headerlink" title="函数与对象"></a>函数与对象</h3><p>函数中最重要的概念: 函数是第一类对(first-class objects),可以被视为其他任意类型的 JavaScript 对象。</p>
<ul>
<li>能被变量引用:</li>
<li>能以字面量形式声明:<ul>
<li><code>function ninjaFunction()&#123;&#125;</code></li>
<li><code>var ninja = &#123;&#125;;</code></li>
</ul>
</li>
<li>甚至能被作为函数参数进行传递。<ul>
<li><code>call(function()&#123;&#125;)</code></li>
</ul>
</li>
</ul>
<p>回调函数(callback): 将在随后调用的函数, <strong>也即作为参数被其它函数执行的函数</strong>;<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007195100.png" alt=""></p>
<figure>执行 useless(getText)调用后的执行流</figure>

<p>回调函数排序:我们提供一个函数用于比较, 返回值大于0需要调换,小于等于0不需要;在比较时调用回调来决定数组的顺序;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">values.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">value1,value2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> value1-value2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>储存函数: 存储元素唯一的函数集合;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = &#123;</span><br><span class="line">      <span class="attr">nextId</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">cache</span>: &#123;&#125;,<span class="comment">//使用一个对象作为缓存，我们可以在其中存储函数 </span></span><br><span class="line">      <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fn.<span class="property">id</span>) &#123;</span><br><span class="line">          fn.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="property">nextId</span>++;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cache</span>[fn.<span class="property">id</span>] = fn;<span class="comment">//仅当函数唯一时，将该函数加入缓存 </span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ninja</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//测试上面代码是否按预期工作</span></span><br><span class="line">    <span class="title function_">assert</span>(store.<span class="title function_">add</span>(ninja),</span><br><span class="line">           <span class="string">&quot;Function was safely added.&quot;</span>);</span><br><span class="line">    <span class="title function_">assert</span>(!store.<span class="title function_">add</span>(ninja),</span><br><span class="line">           <span class="string">&quot;But it was only added once.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>自记忆函数: 当函数计算得到结果时就将该结果<strong>按照参数</strong>存储起来,如果另外一个调用也使用相同的参数，我们则可以直接返回上次存储的结果;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isPrime.<span class="property">answers</span>) &#123;</span><br><span class="line">        isPrime.<span class="property">answers</span> = &#123;&#125;; <span class="comment">//创建缓存</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isPrime.<span class="property">answers</span>[value] !== <span class="literal">undefined</span>) &#123;<span class="comment">//检查缓存的值</span></span><br><span class="line">        <span class="keyword">return</span> isPrime.<span class="property">answers</span>[value];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> prime = value !== <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; value; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value % i === <span class="number">0</span>) &#123;</span><br><span class="line">          prime = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isPrime.<span class="property">answers</span>[value] = prime;<span class="comment">//存储计算的值 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">assert</span>(<span class="title function_">isPrime</span>(<span class="number">5</span>), <span class="string">&quot;5 is prime!&quot;</span> );</span><br><span class="line">    <span class="title function_">assert</span>(isPrime.<span class="property">answers</span>[<span class="number">5</span>], <span class="string">&quot;The answer was cached!&quot;</span> );<span class="comment">//测试该函数是否正常工作 </span></span><br></pre></td></tr></table></figure>
<h3 id="函数定义方式"><a href="#函数定义方式" class="headerlink" title="函数定义方式"></a>函数定义方式</h3><ul>
<li>函数声明: <code>function myFun() &#123; return 1;&#125;</code> <ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007204518.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007204819.png" alt=""><figure>函数声明与函数表达式的不同之处</figure></li>
<li>函数声明:作为独立表达式;函数表达式:作为其他语句的部分,作为右值/参数/返回值;</li>
<li>对于表达式, 函数名不是必须的,对于声明, 他们被引用的唯一方式是通过名字;</li>
<li>立即调用函数表达式IIFE):<code>(function()&#123;&#125;)(2)</code>,创建了一个新函数并调用;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007211707.png" alt=""></li>
<li>括号的作用: 不加括号时, 以function开头的语句会被解释为声明, 然而没有函数名, 故而会报错</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007212110.png" alt=""></li>
<li>上图四个语句都是立即函数,但是使用一元操作符指明处理的是表达式,而非语句;符号得到结果没有被储存,关键在于IIFE被调用了;</li>
</ul>
</li>
</ul>
</li>
<li>箭头函数(lambda函数): <code>param =&gt; expression</code><ul>
<li>省去function,大括号,return;</li>
<li>param: 参数, 单个参数省略括号, 多个参数与声明一致;</li>
<li>expression: 多行表达式需要<code>&#123;&#125;</code>;</li>
</ul>
</li>
<li>函数构造函数: 以字符串形式构造函数;<code>new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;)</code></li>
<li>生成器函数:在执行过程中,能够退出这个函数再重新进入,过程中保留函数内变量值;<code>function* myGen()&#123; yield 1; &#125;</code></li>
</ul>
<hr>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li>参数性质:<ul>
<li>实参多于形参: 按照顺序赋值, 多余的实参不会被赋值;</li>
<li>形参多于实参: 没有对应实参的形参则会被设为undefined;</li>
</ul>
</li>
<li>剩余参数:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007214447.png" alt=""></li>
<li>剩余参数以……做前缀, 且只能是最后一个参数, 被放到以去除…后的名称(reaminingNumbers)的数组中;</li>
</ul>
</li>
<li>默认参数:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007220041.png" alt=""><figure>原理是未被赋值的形参为undefined</figure></li>
<li>另一种方法是函数重载: 定义一个名字相同但参数不同的函数;<strong>但JavaScript不支持</strong>;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0720221007220345.png" alt=""><figure>直接在定义中为参数赋默认值</figure></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008084853.png" alt=""><figure>每次函数调用时都会从左到右求得参数的值,当对后面的默认参数赋值时可以引用前面的默认参数</figure></li>
</ul>
</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ul>
<li>arguments参数: 传递给函数的所有参数的集合;<ul>
<li>为实参的集合, 不论是否有对应形参;</li>
<li>通过数组下标方式访问参数, <code>arguments[i]</code>;</li>
<li>arguments.length获取实参个数,<strong>但它不是数组,只是与数组类似,在其上使用数组的方法会报错;</strong><ul>
<li>相比较之下, 剩余参数则是作为数组;</li>
</ul>
</li>
<li>arguments对象是<strong>函数参数的别名</strong>, 在函数内改变arguments对象的值也会改变对应形参,反之亦然;<ul>
<li>在JavaScript 提供的严格模式（strict mode）中无法再使用别名。<code>&quot;use strict&quot;;</code></li>
</ul>
</li>
</ul>
</li>
<li>this参数:函数调用相关联的对象(函数上下文)<ul>
<li>this 参数的指向不仅是由<strong>定义函数的方式和位置</strong>决定的，同时还严重受到<strong>函数调用方式</strong>的影响;</li>
<li>函数调用的四种方式:<ul>
<li>作为一个函数(function)直接被调用;<code>test()</code><ul>
<li>非严格模式下,this==window全局对象;严格模式下this==undefined;</li>
</ul>
</li>
<li>作为一个方法(method),关联在一个对象上,实现面向对象编程;<code>myobj.test()</code>, 此时this指向该对象;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008094325.png" alt=""></li>
</ul>
</li>
<li>作为一个构造函数(constructor),实例化一个新的对象;<code>new ObjName()</code><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008110328.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008110446.png" alt=""><ul>
<li>当使用关键字 new 调用函数时，会创建一个空的对象实例并将其设置构造函数的上下文</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008111047.png" alt=""><ul>
<li>当构造函数有非对象返回值时,用new调用则返回新建对象,直接调用则返回该值;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008221154.png" alt=""><ul>
<li>但当返回对象时, this对象将被舍弃;</li>
</ul>
</li>
<li>构造函数命名通常以大写字母开头,为描述对象的名词;函数方法则以小写字母开头,为描述行为的动词;</li>
</ul>
</li>
<li>通过函数的apply 或者call 方法;<code>obj.apply(...)</code> or <code>obj.call(...)</code><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008222012.png" alt=""><ul>
<li>Button函数中, 原本通过button.click调用this应该指向button,但是由于我们将其绑定到了按钮上,故而this指向了elem元素;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008222600.png" alt=""><ul>
<li>apply方法, 上下文对象和参数<strong>数组</strong>;</li>
<li>call方法, 上下文对象和参数, 无需使用数组传递参数;</li>
</ul>
</li>
<li>forEach方法(call|apply)迭代数组<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008223235.png" alt=""></li>
</ul>
</li>
<li>解决上下文问题的其他方法:<ul>
<li>箭头函数:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008223813.png" alt=""><ul>
<li>箭头函数从定义时的所在函数继承上下文,相比较函数表达式指向全局对象;</li>
<li><strong>与清单4.10比较:4.10中Button构造函数的click函数上下文被addEventListener绑定到了elem元素, 而箭头函数的click函数从Button函数处继承上下文,故仍然指向button.</strong></li>
<li>存在的问题:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008230325.png" alt=""><ul>
<li>click 箭头函数是作为对象字面量的属性定义的，对象字面量在全局代码中定义, 所以箭头函数this指向window;</li>
</ul>
</li>
</ul>
</li>
<li>bind方法:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0820221008230511.png" alt=""><ul>
<li>不管如何调用该函数，this 均被设置为对象本身。</li>
<li>被绑定的函数与原始函数行为一致，函数体一致。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="闭包与作用域"><a href="#闭包与作用域" class="headerlink" title="闭包与作用域"></a>闭包与作用域</h2><ul>
<li>闭包能够允许函数访问并操作函数外部变量;<ul>
<li>全局作用域实质上是一种闭包, 但是从未消失;</li>
</ul>
</li>
<li><p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009101828.png" alt=""></p>
<ul>
<li>通过outerFunction我们封装了一个innerFunction,并将该function赋给全局变量later,从而能够访问到inner*,并且该函数的作用域为全局+outerFunction;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009102253.png" alt=""><ul>
<li>这里ninja是outerfunction的局部变量,按理来说应当无法访问,但是声明inner*时,创建了一个闭包,不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。</li>
<li>也即是说,创建闭包不仅保存了函数,还有其作用域内的变量;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009102751.png" alt=""><ul>
<li>feints变量不是通过this.feints方式定义的,故而不能直接访问,但是其包含于Ninja的作用域中,能被this.feint()函数所访问;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009103750.png" alt=""><ul>
<li>这一功能有点类似于shiny的模块化,闭包被不同的参数调用,其内部变量互不影响;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009104226.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>全局<strong>执行</strong>上下文只有一个，当JavaScript程序开始执行时就已经创建了全局上下文；而函数<strong>执行</strong>上下文是在每次调用函数时，就会创建一个新的。 </p>
<ul>
<li>函数上下文是内部的, 而执行上下文是JS引擎追踪函数执行使用的;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009104836.png" alt=""><ul>
<li>基本和其他语言差异不大;</li>
</ul>
</li>
</ul>
</li>
<li>词法环境: 也即作用域(scopes);<ul>
<li>当使用变量时, 从内向外开始查找, 从调用栈从上往下一级一级查, 直至找到或者是全局作用域中都没有而报错;<ul>
<li>不是从定义函数的环境查找;</li>
</ul>
</li>
</ul>
</li>
<li>变量类型:<ul>
<li>const关键字: 声明的变量的值无法变更(指用新的值覆盖);<strong>compared with var and let(能多次覆盖)</strong><ul>
<li>用于定义无需重新赋值的变量, 或者是某个固定的值(通常用于描述性变量名替代单纯数值);</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009110451.png" alt=""><ul>
<li>不允许将全新的值赋值给const变量,但是可以修改;</li>
</ul>
</li>
</ul>
</li>
<li>var关键字:声明变量是在距离最近的函数内部或是在全局词法环境中定义的;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009111031.png" alt=""><ul>
<li>与C不同,js不关注块级作用域,var声明的变量在距离最近的函数或全局作用域中实现;</li>
<li>forLoop的块级作用域中声明的元素仍能被外部访问;</li>
</ul>
</li>
<li>与var不同, <strong>let和const在最近词法环境定义变量(块级,循环,函数,全局)</strong>;<ul>
<li>块级作用域: for(){}, if(){}, with(obj){}, try{}/catch{},even simple {};</li>
</ul>
</li>
</ul>
</li>
<li>标识符注册:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009112327.png" alt=""><ul>
<li><strong>定义在使用之后</strong>(谈恋爱要在世界拯救之后??);</li>
</ul>
</li>
<li>注册流程:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0920221009112917.png" alt=""></li>
</ul>
<ol>
<li>找到函数声明, 创建arguments和函数参数;</li>
<li>扫描当前代码进行函数声明（不会扫描其他函数的函数体),对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上.</li>
<li>扫描当前代码进行变量声明。<ol>
<li>在函数或全局环境中，查找所有当前函数以及其他函数之外通过 var 声明的变量，并查找所有通过 let 或 const 定义的变量。</li>
<li>在块级环境中，仅查找当前块中通过 let 或 const 定义的变量。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="generator和promise"><a href="#generator和promise" class="headerlink" title="generator和promise"></a>generator和promise</h2><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><ul>
<li>基于每次请求生成值, 从而生成一组序列;<ul>
<li>每次请求生成新的值 / 或者告诉我们不再生成新值;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1220221012211050.png" alt=""><ul>
<li>在关键字function前加<strong>星号*</strong>,从而在生成器内部使用<strong>yield</strong>生成独立值;</li>
<li>for-of循环: 新的循环方式;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1220221012211827.png" alt=""><ul>
<li>将值赋给const变量得到迭代器object;</li>
<li>iter.next()返回一个对象,包含<ul>
<li>result.value: 返回的值,如生成已结束则为undefined;</li>
<li>result.done: 是否生成器结束,如已结束则为true;</li>
<li>调用next方法 -&gt; 执行代码直到遇到yield -&gt; 返回中间值;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1220221012212746.png" alt=""><ul>
<li><code>yield* otherGenerator</code>将执行权交给另外的生成器;</li>
<li>整体执行逻辑不变,仍旧是遇到yield就返回值, 相当于生成了一个栈, 新加一个生成器就加一层栈;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>生成器用法:<ul>
<li>生成ID序列:定义一个无限循环的生成器,每次返回++ID;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017204116.png" alt=""></li>
</ul>
</li>
<li>遍历DOM树:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017204414.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017205405.jpg" alt=""></li>
<li>深度优先,优先往下访问;</li>
</ul>
</li>
</ul>
</li>
<li>向生成器发送值:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017214640.png" alt=""><ul>
<li>情况1:在初始状态调用并传入参数;</li>
<li>情况2:next方法传入参数;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017215123.png" alt=""><ul>
<li>用throw方法向迭代函数抛出一个错误,该错误会被catch()函数获取,传递给参数e;</li>
</ul>
</li>
</ul>
</li>
<li>生成器执行流程:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017215844.png" alt=""><ul>
<li>生成器比较特殊，它不会执行任何函数代码。而是生成一个新的迭代器再从中返回，通过在 代码中用 <strong>ninjaIterator</strong> 可以来引用这个迭代器。</li>
<li>由于迭代器是用来控制生成器的执行的，故而迭代器中保存着一个在它创建位置处的执行上下文。</li>
<li>每次调用next方法,不是像普通函数那样,生成新的上下文,而是把原有的上下文重新放入栈中;</li>
</ul>
</li>
<li>挂起开始 — 创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。</li>
<li>执行 — 生成器中的代码已执行。执行要么是刚开始，要么是从上次挂起的时候继续的。<ul>
<li>当生成器对应的迭代器调用了next方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。</li>
</ul>
</li>
<li>挂起让渡 — 当生成器在执行过程中遇到了一个yield表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。</li>
<li>完成 — 在生成器执行期间，如果代码执行到return语句或者全部代码执行完毕，生成器就进入该状态。</li>
</ul>
</li>
</ul>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017220520.png" alt=""><ul>
<li>promise实例化对象传入的是两个函数参数,第一个为resolve函数表成功,reject表失败;</li>
<li>当承诺成功兑现（在promise上调用了resolve),前一个回调就会被调用，而当出现错误就会调用后一个回调函数（可以是发生了一个未处理的异常，也可以是在promise上调用了reject）</li>
<li>promise 对象是对我们现在尚未得到但将来会得到值的占位符；</li>
<li>它是对我们最终能够得知异步计算结果的一种保证。如果我们兑现了我们的承诺，那结果会得到一个值。如果发生了问题，结果则是一个错误，一个为什么不能交付的借口。</li>
</ul>
</li>
<li><p>回调函数缺陷:</p>
<ul>
<li>错误难以处理:不是很理解这段话,学完再看;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018085723.png" alt=""></li>
</ul>
</li>
<li>执行连续步骤麻烦:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018085723.png" alt=""></li>
<li>一个长期任务结束后我们可能会用得到的数据开启另一项任务,就需要不停的缩进+嵌套;</li>
</ul>
</li>
<li>并列步骤需要书写多段类似代码:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018090155.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>promise执行逻辑:</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018090423.png" alt=""><ul>
<li>promise对象从pending开始,标记为未完成;</li>
<li>若promise对象resolve方法被调用,获取值,进入完成状态;</li>
<li>若reject方法被调用,则获取出错原因,进入完成状态;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018091005.jpg" alt=""><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018092952.png" alt=""></li>
<li>需要注意的是第二个Inmmediatepromise,为什么会在”at code end”后执行?</li>
</ul>
</li>
</ul>
</li>
<li>拒绝promise:  <ul>
<li>then中调用第二个回调函数<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1820221018093733.png" alt=""></li>
<li>then中只传入第一个回调函数, 错误通过catch获取<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019143414.png" alt=""><ul>
<li>then可以有很多步,从而完成任务流,而catch函数,只要前面有任何一个promise出错,就会将其捕捉;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019143946.png" alt=""><ul>
<li>不是主动调用,而是函数内部出错;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019153916.png" alt=""><ul>
<li>Promise.all函数接受的是一个promise对象的数组;</li>
<li>只有全部成功才会被解决, 只要有一个失败就被拒绝;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019154157.png" alt=""><ul>
<li>拒绝与接受取决于第一个成功的promise;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="生成器与promise结合"><a href="#生成器与promise结合" class="headerlink" title="生成器与promise结合"></a>生成器与promise结合</h3><ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1920221019185047.png" alt=""><ul>
<li>每个promise也即异步任务都被yield返回;</li>
<li>如果生成器的结果是一个被成功兑现的承诺，我们就是用迭代器的 next 方法把承诺的值返回给生成器并恢复执行<code>iteratorValue.then(res =&gt; handle(iterator.next(res)))</code>;</li>
<li>如果出现错误，承诺被违背，我们就使用迭代器的throw方法抛出一个异常<code>.catch(err =&gt; iterator.throw(err))</code></li>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript逆向Basics: 加密与安全</title>
    <url>/2023/06/16/JavaScript%E9%80%86%E5%90%91Basics-%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>当我们学习使用爬虫时，我们发现大多数网站的动态数据都采用了加密的方式。通过源代码中进行调试，我们可以“扣”出执行加密的JavaScript代码，再在python中调用JavaScript即可完成加密。尽管如此，了解加密算法，仍能够让我们迅速地反应过来加密函数所用编码，从而能让我们对JavaScript用Python进行改写，或是应对源代码中的僵尸代码。</p>
<p>本文包含的算法有编码算法，哈希算法，对称加密算法，口令加密算法，密钥交换算法，非对称加密算法，签名算法，数字证书。我会首先介绍基础知识，如用途，使用什么JavaScript函数完成等等。紧接着再介绍该算法的流程。话不多说，我们开始吧！</p>
<h3 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h3><p>编码算法事实上并不是一种加密算法，他仅仅是将数据使用某种编码进行表示，因而我们首先要了解什么是编码。</p>
<p>我们最常见的编码是ASCII编码，如下表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>\</td>
<td>124</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
</div>
<p>上表中，ASCII值为十进制，但我们通常用16进制表示编码，故字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code>，以此类推;</p>
<p>ASCII对常见的字符进行编码，但其仅仅只有128个字符，想要表示更多就需要使用<code>Unicode</code>编码。</p>
<p>Unicode编码是一种字符编码方案，用于表示世界上几乎所有字符的标准化编码。它为每个字符分配了一个唯一的数值，称为码点（Code Point），并以十六进制表示。最常见的表示方式是使用前缀”\u”加上四个十六进制数字来表示一个字符的 Unicode 码点。例如，字符 “A” 的 Unicode 码点是 U+0041，可以表示为 “\u0041”。</p>
<p>Unicode 编码有不同的编码方式，其中最常见的是 UTF-8 和 UTF-16。UTF-8 是一种变长编码，使用 1 到 4 个字节来表示不同的字符。在 UTF-8 编码中，常见的 ASCII 字符使用一个字节表示，而非 ASCII 字符使用多个字节表示。UTF-16 是一种定长编码，使用 2 个字节或 4 个字节来表示不同的字符。大部分常见字符使用两个字节表示，而一些较罕见的字符使用四个字节表示。</p>
<p>Python 中的 ASCII 和 Unicode 处理：</p>
<ol>
<li><p>ASCII 编码：</p>
<ul>
<li>使用 <code>ord()</code> 函数将字符转换为对应的 ASCII 码值。</li>
<li>使用 <code>chr()</code> 函数将 ASCII 码值转换为对应的字符。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">char = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">ascii_value = <span class="built_in">ord</span>(char)</span><br><span class="line"><span class="built_in">print</span>(ascii_value)  <span class="comment"># 输出：65</span></span><br><span class="line"></span><br><span class="line">char = <span class="built_in">chr</span>(<span class="number">65</span>)</span><br><span class="line"><span class="built_in">print</span>(char)  <span class="comment"># 输出：A</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Unicode 编码：</p>
<ul>
<li>使用 <code>encode()</code> 方法将字符串编码为指定的 Unicode 编码格式。</li>
<li>使用 <code>decode()</code> 方法将 Unicode 编码转换为字符串。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">unicode_string = string.encode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(unicode_string)  <span class="comment"># 输出：b&#x27;\\u4f60\\u597d&#x27;</span></span><br><span class="line"></span><br><span class="line">decoded_string = unicode_string.decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(decoded_string)  <span class="comment"># 输出：你好</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>JavaScript 中的 ASCII 和 Unicode 处理：</p>
<ol>
<li><p>ASCII 编码：</p>
<ul>
<li>使用 <code>charCodeAt()</code> 方法获取字符串中指定位置字符的 ASCII 码值。</li>
<li>使用 <code>String.fromCharCode()</code> 方法将 ASCII 码值转换为对应的字符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> char = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> asciiValue = char.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(asciiValue);  <span class="comment">// 输出：65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> char = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">65</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(char);  <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Unicode 编码：</p>
<ul>
<li>使用 <code>\u</code> 前缀将 Unicode 字符码直接插入字符串中。</li>
<li>使用 <code>String.fromCharCode()</code> 方法将 Unicode 字符码转换为对应的字符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;\u4F60\u597D&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string);  <span class="comment">// 输出：你好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> char = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x4F60</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(char);  <span class="comment">// 输出：你</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>另外一种常见但可能绝大多数人不明白的是URL编码，他通常出现在我们浏览器的URL栏中。譬如，当我使用Bing进行一次检索“必应”，URL会变成“<a href="https://www.bing.com/search?q=%E5%BF%85%E5%BA%94&amp;mkt=zh-CN">https://www.bing.com/search?q=%E5%BF%85%E5%BA%94&amp;mkt=zh-CN</a>”，如果你对爬虫比较熟悉的话应该知道<code>?</code>后是字符串参数，使用<code>&amp;</code>进行分隔，”q=%E5%BF%85%E5%BA%94”即是我们这次检索的内容，<code>q=</code>之后的即为URL编码后的“必应”。</p>
<p>URL的编码逻辑是：</p>
<ul>
<li>如果字符是<code>A</code>~<code>Z</code>，<code>a</code>~<code>z</code>，<code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li>
<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。<br>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码<strong>总是大写</strong>。也即“去0x，改大写，每字节加%”。<code>!</code>等特殊字符非<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，虽然是ASCII字符，也要对其编码。</li>
</ul>
<p>在 Python 中，可以使用 <code>urllib.parse</code> 模块中的 <code>quote()</code> 和 <code>quote_plus()</code> 函数来进行 URL 编码，以及使用 <code>unquote()</code> 和 <code>unquote_plus()</code> 函数来进行 URL 解码。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 编码</span></span><br><span class="line">url = <span class="string">&#x27;https://www.example.com/?q=hello world&#x27;</span></span><br><span class="line">encoded_url = urllib.parse.quote(url)</span><br><span class="line"><span class="built_in">print</span>(encoded_url)  <span class="comment"># 输出：https%3A//www.example.com/%3Fq%3Dhello%20world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 解码</span></span><br><span class="line">decoded_url = urllib.parse.unquote(encoded_url)</span><br><span class="line"><span class="built_in">print</span>(decoded_url)  <span class="comment"># 输出：https://www.example.com/?q=hello world</span></span><br></pre></td></tr></table></figure></p>
<p>在 JavaScript 中，可以使用 <code>encodeURIComponent()</code> 函数进行 URL 编码，以及使用 <code>decodeURIComponent()</code> 函数进行 URL 解码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URL 编码</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://www.example.com/?q=hello world&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> encodedUrl = <span class="built_in">encodeURIComponent</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedUrl);  <span class="comment">// 输出：https%3A%2F%2Fwww.example.com%2F%3Fq%3Dhello%20world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// URL 解码</span></span><br><span class="line"><span class="keyword">var</span> decodedUrl = <span class="built_in">decodeURIComponent</span>(encodedUrl);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decodedUrl);  <span class="comment">// 输出：https://www.example.com/?q=hello world</span></span><br></pre></td></tr></table></figure></p>
<p>URL编码是对字符进行编码，表示成<code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。它常用于在文本协议中传输或存储二进制数据，例如在电子邮件中传输附件或在网页中嵌入图像数据。</p>
<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code>~<code>Z</code>、<code>a</code>~<code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，Base64 编码后的数据会比原始数据略长，因为每 3 个字节的数据会被编码为 4 个字符。Base64 编码的结果是由 A-Z、a-z、0-9、+ 和 / 组成的字符序列。有时，由于特定环境的限制（其实就是为了在URL中使用），会将字符 “+” 和 “/“ 分别替换为 “-“ 和 “_“。</p>
<p>当输入的二进制数组字节长度不是3的整数倍时，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p>
<p>在 Python 中，可以使用 <code>base64</code> 模块来进行 Base64 编码和解码操作。该模块提供了 <code>b64encode()</code> 和 <code>b64decode()</code> 函数用于编码和解码操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base64 编码</span></span><br><span class="line">data = <span class="string">b&#x27;Hello, World!&#x27;</span></span><br><span class="line">encoded_data = base64.b64encode(data)</span><br><span class="line"><span class="built_in">print</span>(encoded_data)  <span class="comment"># 输出：b&#x27;SGVsbG8sIFdvcmxkIQ==&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Base64 解码</span></span><br><span class="line">decoded_data = base64.b64decode(encoded_data)</span><br><span class="line"><span class="built_in">print</span>(decoded_data)  <span class="comment"># 输出：b&#x27;Hello, World!&#x27;</span></span><br></pre></td></tr></table></figure><br>在 JavaScript 中，可以使用 <code>btoa()</code> 函数进行 Base64 编码，以及使用 <code>atob()</code> 函数进行 Base64 解码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base64 编码</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> encodedData = <span class="title function_">btoa</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedData);  <span class="comment">// 输出：SGVsbG8sIFdvcmxkIQ==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 解码</span></span><br><span class="line"><span class="keyword">var</span> decodedData = <span class="title function_">atob</span>(encodedData);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decodedData);  <span class="comment">// 输出：Hello, World!</span></span><br></pre></td></tr></table></figure></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>哈希算法（Hash Algorithm）是一种将任意长度的数据映射为固定长度哈希值（Hash Value）的算法。哈希值通常是一个较短的固定大小的字节数组，用于表示原始数据。</p>
<p>哈希算法的主要特点是：</p>
<ol>
<li>固定输出长度：不论输入数据的大小，哈希算法都会生成一个固定长度的哈希值。常见的哈希长度有128位、256位或更长。</li>
<li>独特性：对于不同的输入数据，哈希算法应该生成不同的哈希值。这意味着即使输入数据发生细微的改变，生成的哈希值也会有较大的差异。</li>
<li>不可逆性：从哈希值无法还原出原始数据。即使对于稍微不同的输入，其哈希值也应该是完全不同的。</li>
<li>高效性：计算哈希值的速度应该很快，即使对于大量的数据也应该在合理的时间内完成。</li>
</ol>
<p>哈希碰撞: 尽管哈希算法的目标是生成唯一的哈希值，但在实际应用中，由于<strong>输入数据的无限性</strong>和<strong>哈希值的有限性</strong>，哈希碰撞是可能发生的。哈希算法的输出空间是固定的，而输入空间则是无穷大的，因此存在多个不同的输入数据可能会映射到相同的哈希值上。</p>
<p>对于一个安全的哈希算法而言， 他必须要 1）碰撞概率低；2）不能推测出输出。碰撞概率高增需要加长输出字节，而不能推测输出指的是输出不能看出任何规律。</p>
<h4 id="常见的哈希算法"><a href="#常见的哈希算法" class="headerlink" title="常见的哈希算法"></a>常见的哈希算法</h4><h5 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h5><p>算法流程：</p>
<ol>
<li>填充数据：将输入数据进行填充，使其长度满足对512位（64字节）块的整数倍。填充方式是在数据末尾添加一个1比特，然后添加足够的零比特，以填充剩余的空间，并在最后添加一个64位的，表示原始数据长度的，值。即令其位长对512求余的结果等于448。</li>
<li>划分为块：将填充后的数据划分为多个512位（64字节）的数据块。</li>
<li>初始化变量：设置四个32位的初始变量A、B、C和D。这些变量作为中间计算结果的存储器。</li>
<li>处理每个块：对于每个512位的数据块，进行以下操作：<ul>
<li>将块分为16个32位的子块。</li>
<li>初始化四个临时变量：a、b、c和d，其初始值与A、B、C和D相同。</li>
<li>进行四轮循环，每轮循环包括16个操作步骤。在每个步骤中，根据一定的位操作、逻辑函数和非线性函数，更新临时变量的值。<ul>
<li>四个非线性函数：<ul>
<li>F( X ,Y ,Z ) = ( X &amp; Y ) | ( (~X) &amp; Z )</li>
<li>G( X ,Y ,Z ) = ( X &amp; Z ) | ( Y &amp; (~Z) )</li>
<li>H( X ,Y ,Z ) =X ^ Y ^ Z</li>
<li>I( X ,Y ,Z ) =Y ^ ( X | (~Z) )</li>
<li><code>&amp;</code>是与（And），<code>|</code>是或（Or），<code>~</code>是非（Not），<code>^</code>是异或（Xor））</li>
</ul>
</li>
<li>更新临时变量（）：<ul>
<li>FF(X ,Y ,Z ,V ,Mj ,s ,ti ) 操作为 X = Y + ( (X + F(Y,Z,V) + Mj + ti) &lt;&lt; s)</li>
<li>GG(X ,Y ,Z ,V ,Mj ,s ,ti ) 操作为 X = Y + ( (X + G(Y,Z,V) + Mj + ti) &lt;&lt; s)</li>
<li>HH(X ,Y ,Z ,V ,Mj ,s ,ti) 操作为 X = Y + ( (X + H(Y,Z,V) + Mj + ti) &lt;&lt; s)</li>
<li>II(X ,Y ,Z ,V ,Mj ,s ,ti) 操作为 X = Y + ( (X + I(Y,Z,V) + Mj + ti) &lt;&lt; s)</li>
<li><code>&lt;&lt;</code>表示循环左移位，将左侧溢出的值移到右边。</li>
</ul>
</li>
<li>每一轮中分别使用FF，GG，HH，II函数。</li>
<li>每次操作对a、b、c和d中的其中三个作一次<strong>非线性函数运算</strong>，然后将所得结果加上第四个<strong>变量</strong>，文本的一个<strong>子分组，即第i个子块Mj</strong>和一个<strong>常数ti</strong>。再将所得结果向左<strong>环移</strong>一个<strong>不定的数s</strong>，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。<ul>
<li>第一轮</li>
<li>FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )</li>
<li>FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )</li>
<li>FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )</li>
<li>FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )</li>
<li>FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf ) <strong>发现规律了吗？abcd循环！</strong></li>
<li>此后三轮不同之处在于<code>函数</code>和<code>s</code>。</li>
</ul>
</li>
</ul>
</li>
<li>将最终的临时变量的值与初始变量的值相加，得到新的A、B、C和D的值。</li>
</ul>
</li>
<li>输出结果：最后，将A、B、C和D的值按照小端序连接起来，形成一个128位（16字节）的哈希值。这就是MD5算法的输出结果。<blockquote>
<p>小端序（Little-endian）是一种字节序排列方式，用于表示多字节数据在存储器中的顺序。在小端序中，较低有效字节（低位字节）存储在内存的较低地址，而较高有效字节（高位字节）存储在内存的较高地址。</p>
</blockquote>
</li>
</ol>
<p>Python中，hashlib库完成：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要计算MD5哈希的数据</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建MD5哈希对象</span></span><br><span class="line">md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新哈希对象的数据</span></span><br><span class="line">md5_hash.update(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算哈希值</span></span><br><span class="line">hash_value = md5_hash.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印哈希值</span></span><br><span class="line"><span class="built_in">print</span>(hash_value)</span><br></pre></td></tr></table></figure></p>
<p>JavaScript中:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义要计算MD5哈希的数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建MD5哈希对象</span></span><br><span class="line"><span class="keyword">const</span> md5Hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新哈希对象的数据</span></span><br><span class="line">md5Hash.<span class="title function_">update</span>(data, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希值</span></span><br><span class="line"><span class="keyword">const</span> hashValue = md5Hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈希值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashValue);</span><br></pre></td></tr></table></figure></p>
<h5 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h5><p>算法流程：</p>
<ol>
<li>初始化变量：SHA-1使用一组初始变量，称为哈希值（也称为中间哈希结果），共有5个32位的字，分别记为<code>h0</code>、<code>h1</code>、<code>h2</code>、<code>h3</code>和<code>h4</code>。</li>
<li>填充数据：将输入数据进行填充，使其长度满足对512位（64字节）块的整数倍。填充方式是在数据末尾添加一个1比特，然后添加足够的零比特，以填充剩余的空间，并在最后添加一个64位的表示原始数据长度的值。</li>
<li>划分为块：将填充后的数据划分为多个512位（64字节）的数据块。</li>
<li>处理每个块：对于每个512位的数据块，进行以下操作：<ul>
<li>将块分为16个32位的子块。</li>
<li>初始化一个数组<code>w</code>，用于存储80个32位的字。</li>
<li>通过扩展机制，从子块中生成额外的64个字，填充到数组<code>w</code>中。<ul>
<li>将16个子块（32位）复制到数组<code>w</code>的前16个位置。</li>
<li>对于<code>i</code>从16到79的每个值，进行以下操作：<ul>
<li>通过进行位操作（如循环左移、异或等），从<code>w[i-3]</code>、<code>w[i-8]</code>、<code>w[i-14]</code>和<code>w[i-16]</code>生成新的字<code>w[i]</code>。</li>
<li><code>W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16))</code></li>
<li>这里的<code>t</code>表示当前的索引值（从0开始），<code>W(t)</code>表示在数组<code>w</code>中的第<code>t</code>个字，<code>XOR</code>表示按位异或操作，<code>S^1</code>表示循环左移1位。</li>
</ul>
</li>
</ul>
</li>
<li>进行80轮循环，每轮循环包括4个操作步骤，根据一定的位操作和非线性函数，更新<code>w</code>中的字。<ul>
<li>每轮循环：<ul>
<li>TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);</li>
<li>f(t;B,C,D)函数：<ul>
<li>f(t;B,C,D) = (B AND C) OR ((NOT B) AND D)         ( 0 &lt;= t &lt;= 19)</li>
<li>f(t;B,C,D) = B XOR C XOR D                        (20 &lt;= t &lt;= 39)</li>
<li>f(t;B,C,D) = (B AND C) OR (B AND D) OR (C AND D)  (40 &lt;= t &lt;= 59)</li>
<li>f(t;B,C,D) = B XOR C XOR D                        (60 &lt;= t &lt;= 79)</li>
</ul>
</li>
<li>W(t)定义如上；</li>
<li>K(t)函数：<ul>
<li>K(t) = 0x5A827999         ( 0 &lt;= t &lt;= 19)</li>
<li>K(t) = 0x6ED9EBA1         (20 &lt;= t &lt;= 39)</li>
<li>K(t) = 0x8F1BBCDC         (40 &lt;= t &lt;= 59)</li>
<li>K(t) = 0xCA62C1D6         (60 &lt;= t &lt;= 79)</li>
</ul>
</li>
<li>E = D;</li>
<li>D = C;</li>
<li>C = S^30(B);</li>
<li>B = A;</li>
<li>A = TEMP;<ul>
<li>根据<code>w</code>中的字和当前的哈希值，进行一系列的位操作和运算，更新哈希值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输出结果：最后，将最终的哈希值（<code>h0</code>、<code>h1</code>、<code>h2</code>、<code>h3</code>和<code>h4</code>）按照大端序（Big-endian）连接起来，形成一个160位（20字节）的哈希值。这就是SHA-1算法的输出结果。</li>
</ol>
<p>在python中：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_sha1</span>(<span class="params">data</span>):</span><br><span class="line">    sha1_hash = hashlib.sha1()</span><br><span class="line">    sha1_hash.update(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 将字符串编码为字节流并更新哈希对象</span></span><br><span class="line">    sha1_digest = sha1_hash.hexdigest()  <span class="comment"># 获取十六进制表示的哈希值</span></span><br><span class="line">    <span class="keyword">return</span> sha1_digest</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line">sha1 = calculate_sha1(data)</span><br><span class="line"><span class="built_in">print</span>(sha1)</span><br></pre></td></tr></table></figure><br>发现规律了吗？<code>hashlib</code>库在Python中提供了多种哈希算法的支持，除了SHA-1之外，以下是一些<code>hashlib</code>支持的其他常用哈希算法：</p>
<ul>
<li>SHA-224：SHA-224是SHA-2系列中的一种哈希算法，生成224位（28字节）的哈希值。</li>
<li>SHA-256：SHA-256是SHA-2系列中的一种哈希算法，生成256位（32字节）的哈希值。</li>
<li>SHA-384：SHA-384是SHA-2系列中的一种哈希算法，生成384位（48字节）的哈希值。</li>
<li>SHA-512：SHA-512是SHA-2系列中的一种哈希算法，生成512位（64字节）的哈希值。</li>
<li>SHA-3系列：<code>hashlib</code>库也支持SHA-3系列的哈希算法，如SHA3-224、SHA3-256、SHA3-384和SHA3-512等。</li>
<li>MD5：MD5是一种广泛使用的哈希算法，生成128位（16字节）的哈希值。然而，MD5已经不再被推荐在安全敏感的场景中使用。</li>
<li>BLAKE2系列：BLAKE2是一系列高性能哈希函数，包括BLAKE2b和BLAKE2s等变种。它们提供了不同的输出长度和速度/安全性权衡。<br>你可以使用<code>hashlib.new(algorithm)</code>方法来创建特定算法的哈希对象，其中<code>algorithm</code>参数指定算法名称（例如，”sha256”、”md5”等）。然后，使用<code>.update(data)</code>方法向哈希对象提供数据，并使用<code>.hexdigest()</code>方法获取十六进制表示的哈希值。</li>
</ul>
<p>在JavaScript中：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateSHA1</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sha1Hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha1&#x27;</span>);</span><br><span class="line">  sha1Hash.<span class="title function_">update</span>(data);</span><br><span class="line">  <span class="keyword">const</span> sha1Digest = sha1Hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> sha1Digest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> sha1 = <span class="title function_">calculateSHA1</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sha1);</span><br></pre></td></tr></table></figure><br>同样，也支持多种其他哈希算法</p>
<ul>
<li>SHA-256: <code>crypto.createHash(&#39;sha256&#39;)</code></li>
<li>SHA-512: <code>crypto.createHash(&#39;sha512&#39;)</code></li>
<li>MD5: <code>crypto.createHash(&#39;md5&#39;)</code></li>
<li>SHA-3-256: <code>crypto.createHash(&#39;sha3-256&#39;)</code></li>
<li>SHA-3-512: <code>crypto.createHash(&#39;sha3-512&#39;)</code></li>
<li>RIPEMD-160: <code>crypto.createHash(&#39;ripemd160&#39;)</code></li>
<li>Whirlpool: <code>crypto.createHash(&#39;whirlpool&#39;)</code></li>
<li>Blake2b: <code>crypto.createHash(&#39;blake2b&#39;)</code></li>
<li>Blake2s: <code>crypto.createHash(&#39;blake2s&#39;)</code></li>
</ul>
<p>你可以使用以上名称作为<code>crypto.createHash()</code>方法的参数来创建相应的哈希对象。然后，你可以使用<code>.update()</code>方法将数据添加到哈希对象中，并使用<code>.digest()</code>方法获取最终的哈希值。</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>加盐（Salting）和迭代（Iteration）是在密码哈希过程中使用的两种技术，旨在增强密码的安全性。</p>
<ol>
<li>加盐（Salting）：加盐是在密码哈希过程中引入一个随机的盐值（salt），将其与密码进行组合，然后再进行哈希计算。盐值是一个随机字符串，每个用户的盐值都是唯一的。通过将盐值添加到密码中，即使相同的密码在哈希过程中生成了相同的哈希值，但由于不同用户使用不同的盐值，最终的哈希值也会不同。这种技术可以防止使用彩虹表等预先计算的攻击手段进行密码破解。</li>
<li>迭代（Iteration）：迭代是在哈希计算过程中进行多次重复操作。通过多次迭代哈希算法，可以增加破解密码所需的计算成本。迭代的次数越多，破解者需要投入的计算资源就越多。迭代次数应该根据计算资源和应用的性能要求进行平衡。增加迭代次数可以有效抵御暴力破解和大规模计算资源的攻击。<br>加盐和迭代通常一起使用，以提高密码哈希的安全性。在存储密码时，应该为每个用户生成一个随机的盐值，并将其与用户的密码组合后进行哈希计算。然后，将盐值和哈希值一起存储在数据库中。当用户验证密码时，再次使用相同的盐值和迭代次数对输入的密码进行哈希计算，并与存储的哈希值进行比较，以验证密码的正确性。</li>
</ol>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法指的是使用相同的密钥（称为密钥）进行加密和解密过程。在对称加密算法中，发送方使用密钥将明文数据加密成密文，接收方使用相同的密钥将密文解密回明文。</p>
<h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>基本流程：</p>
<ol>
<li>密钥生成：从输入的密钥中生成16个子密钥，每个子密钥为48位。这些子密钥用于加密和解密过程中的轮函数。</li>
<li>初始置换（Initial Permutation）：将输入的64位明文数据进行初始置换，重新排列数据位的顺序。</li>
<li>加密/解密轮函数（Encryption/Decryption Round Function）：DES算法使用16个轮函数，每个轮函数的操作包括以下步骤：<ul>
<li>扩展置换（Expansion Permutation）：将32位数据扩展为48位，以便与子密钥进行异或运算。</li>
<li>子密钥与数据的异或运算：将扩展后的数据与当前轮的子密钥进行异或运算。</li>
<li>S盒替换（S-Box Substitution）：将48位数据分成8组，每组6位。通过8个S盒（每个S盒为4x16的置换表），将每组6位数据映射为4位输出。</li>
<li>P置换（Permutation）：对S盒输出进行P置换，重新排列4位数据的顺序。</li>
<li>轮函数输出：经过上述操作后，得到32位的轮函数输出。</li>
</ul>
</li>
<li>轮交换（Round Swap）：经过16个轮函数后，将最后一轮的左右32位数据交换位置。</li>
<li>逆初始置换（Final Permutation）：对交换后的数据进行逆初始置换，恢复数据位的顺序。</li>
</ol>
<p>Python中:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DES对象并指定密钥</span></span><br><span class="line">key = <span class="string">b&#x27;abcdefgh&#x27;</span>  <span class="comment"># 密钥长度必须是8个字节</span></span><br><span class="line">cipher = DES.new(key, DES.MODE_ECB)  <span class="comment"># 使用ECB模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">plaintext = <span class="string">b&#x27;Hello, DES!&#x27;</span></span><br><span class="line">ciphertext = cipher.encrypt(plaintext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密后的密文:&quot;</span>, ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">decrypted = cipher.decrypt(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的明文:&quot;</span>, decrypted)</span><br></pre></td></tr></table></figure><br>然而Crypto这个库装起来总是出错，另一方法是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> Cipher, algorithms, modes</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> padding</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">des_encrypt</span>(<span class="params">key, plaintext</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    iv = os.urandom(<span class="number">8</span>)  <span class="comment"># 生成随机的初始向量</span></span><br><span class="line">    cipher = Cipher(algorithms.TripleDES(key), modes.CBC(iv), backend=backend)</span><br><span class="line">    encryptor = cipher.encryptor()</span><br><span class="line">    padder = padding.PKCS7(<span class="number">64</span>).padder()  <span class="comment"># 使用PKCS7填充</span></span><br><span class="line">    padded_plaintext = padder.update(plaintext) + padder.finalize()</span><br><span class="line">    ciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()</span><br><span class="line">    <span class="keyword">return</span> iv + ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">des_decrypt</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    iv = ciphertext[:<span class="number">8</span>]</span><br><span class="line">    cipher = Cipher(algorithms.TripleDES(key), modes.CBC(iv), backend=backend)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    unpadder = padding.PKCS7(<span class="number">64</span>).unpadder()</span><br><span class="line">    padded_plaintext = decryptor.update(ciphertext[<span class="number">8</span>:]) + decryptor.finalize()</span><br><span class="line">    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">key = <span class="string">b&#x27;sixteen byte key&#x27;</span></span><br><span class="line">plaintext = <span class="string">b&#x27;This is a secret message&#x27;</span></span><br><span class="line"></span><br><span class="line">ciphertext = des_encrypt(key, plaintext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ciphertext:&quot;</span>, ciphertext)</span><br><span class="line"></span><br><span class="line">decrypted_text = des_decrypt(key, ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted text:&quot;</span>, decrypted_text.decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>JavaScript中:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用CryptoJS库（需要先引入CryptoJS库）</span></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">desEncrypt</span>(<span class="params">key, data</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&#x27;des-ecb&#x27;</span>, key, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> encrypted = cipher.<span class="title function_">update</span>(data, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  encrypted += cipher.<span class="title function_">final</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">desDecrypt</span>(<span class="params">key, encryptedData</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&#x27;des-ecb&#x27;</span>, key, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> decrypted = decipher.<span class="title function_">update</span>(encryptedData, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  decrypted += decipher.<span class="title function_">final</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decrypted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;abcdefgh&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>); <span class="comment">// 8字节的密钥</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encryptedData = <span class="title function_">desEncrypt</span>(key, data);</span><br><span class="line"><span class="keyword">const</span> decryptedData = <span class="title function_">desDecrypt</span>(key, encryptedData);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Encrypted data:&#x27;</span>, encryptedData);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Decrypted data:&#x27;</span>, decryptedData);</span><br></pre></td></tr></table></figure></p>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>基本流程：</p>
<ol>
<li>密钥扩展（Key Expansion）：<ul>
<li>输入密钥（128位、192位或256位）被分成一系列的字（每个字为32位）。</li>
<li>通过密钥调度算法，根据输入密钥生成轮密钥（Round Keys）。这些轮密钥用于每轮的轮函数中。<ul>
<li>初始轮密钥生成：<ul>
<li>将输入的密钥拆分成一系列字（每个字为32位）。</li>
<li>这些字直接用作初始的轮密钥。</li>
</ul>
</li>
<li>轮密钥扩展：<ul>
<li>对于每个轮密钥的生成，算法执行以下步骤：<ul>
<li>从上一轮的轮密钥中获取最后一个字，并进行特定的处理。</li>
<li>如果该字是4的倍数（0、4、8等），则进行密钥计算，涉及字的旋转、S盒替代和与轮常数的异或运算。</li>
<li>否则，如果该字不是4的倍数，则进行简单的字异或运算。</li>
<li>生成的字作为当前轮的轮密钥，并用于轮函数中的轮密钥加操作。</li>
</ul>
</li>
</ul>
</li>
<li>轮常数（Round Constants）：<ul>
<li>在密钥扩展过程中，每一轮都使用一个轮常数与某些字进行异或运算，以增加密钥的变化性。</li>
<li>轮常数是预定义的常量，与轮的顺序对应。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>初始轮（Initial Round）：<ul>
<li>将输入的明文数据（128位）与第一轮的轮密钥进行异或运算。</li>
</ul>
</li>
<li>轮函数（Round Function）：<ul>
<li>字节替代（SubBytes）：<ul>
<li>将输入数据的每个字节（8位）通过一个称为S盒（Substitution Box）的查找表进行替代。</li>
<li>S盒将每个输入字节映射到一个特定的输出字节，增加混淆效果。</li>
</ul>
</li>
<li>行位移（ShiftRows）：<ul>
<li>对输入数据的每一行进行循环左移操作，以增加数据的扩散性。</li>
<li>第一行不进行位移操作，第二行左移一位，第三行左移两位，第四行左移三位。</li>
</ul>
</li>
<li>列混淆（MixColumns）：<ul>
<li>对输入数据的每一列进行矩阵变换，通过一系列乘法和加法操作，增加数据的扩散性。</li>
<li>此操作使得每个字节的变化影响整个列。</li>
</ul>
</li>
<li>轮密钥加（AddRoundKey）：<ul>
<li>将轮密钥与上一轮输出的数据进行逐位异或运算。</li>
</ul>
</li>
</ul>
</li>
<li>重复轮函数（Rounds）：<ul>
<li>根据AES密钥长度的不同，重复执行轮函数的步骤。一般来说，128位密钥执行9轮，192位或256位密钥执行11轮。</li>
</ul>
</li>
<li>最后一轮（Final Round）：<ul>
<li>字节替代（SubBytes）</li>
<li>行位移（ShiftRows）</li>
<li>轮密钥加（AddRoundKey）</li>
</ul>
</li>
<li>输出：<ul>
<li>最终经过所有轮函数处理后的数据作为密文数据输出。<br>解密过程与加密过程相反，使用相同的密钥和相反顺序的操作来恢复明文数据。</li>
</ul>
</li>
</ol>
<p>Python中：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> Cipher, algorithms, modes</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> padding</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">key, plaintext</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    iv = os.urandom(<span class="number">16</span>)  <span class="comment"># 生成随机的初始向量</span></span><br><span class="line">    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)</span><br><span class="line">    encryptor = cipher.encryptor()</span><br><span class="line">    padder = padding.PKCS7(<span class="number">128</span>).padder()  <span class="comment"># 使用PKCS7填充</span></span><br><span class="line">    padded_plaintext = padder.update(plaintext) + padder.finalize()</span><br><span class="line">    ciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()</span><br><span class="line">    <span class="keyword">return</span> iv + ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    iv = ciphertext[:<span class="number">16</span>]</span><br><span class="line">    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    unpadder = padding.PKCS7(<span class="number">128</span>).unpadder()</span><br><span class="line">    padded_plaintext = decryptor.update(ciphertext[<span class="number">16</span>:]) + decryptor.finalize()</span><br><span class="line">    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">key = <span class="string">b&#x27;sixteen byte key&#x27;</span></span><br><span class="line">plaintext = <span class="string">b&#x27;This is a secret message&#x27;</span></span><br><span class="line"></span><br><span class="line">ciphertext = aes_encrypt(key, plaintext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ciphertext:&quot;</span>, ciphertext)</span><br><span class="line"></span><br><span class="line">decrypted_text = aes_decrypt(key, ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted text:&quot;</span>, decrypted_text.decode())</span><br></pre></td></tr></table></figure></p>
<p>Javascript中：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&quot;crypto-js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要加密的数据</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;Hello, AES!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个随机的密钥</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="title class_">CryptoJS</span>.<span class="property">lib</span>.<span class="property">WordArray</span>.<span class="title function_">random</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密数据</span></span><br><span class="line"><span class="keyword">var</span> encrypted_data = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, key).<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加密后的数据:&quot;</span>, encrypted_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密数据</span></span><br><span class="line"><span class="keyword">var</span> decrypted_data = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(encrypted_data, key).<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;解密后的数据:&quot;</span>, decrypted_data);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux /etc/ 目录详解</title>
    <url>/2023/06/09/Linux-etc-%E7%9B%AE%E5%BD%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="etc-文件夹的作用是什么"><a href="#etc-文件夹的作用是什么" class="headerlink" title="/etc/ 文件夹的作用是什么?"></a>/etc/ 文件夹的作用是什么?</h2><p>根路径下各个文件都有其特殊的用处, 譬如<code>/bin</code> 目录包含了系统启动和基本操作所需的核心命令（二进制文件）;<code>/boot</code> 目录包含了启动系统所需的文件，如内核映像文件和引导加载程序（bootloader）配置文件;<code>/dev</code> 目录是设备文件的存放位置等. </p>
<p>而<code>/etc</code>则是包含了系统的配置文件,大多数系统级别的配置文件和脚本都存放在此处，例如 <code>/etc/passwd</code>（存储用户信息）、<code>/etc/hosts</code>（存储主机名和 IP 地址的映射）等。了解其下各个子文件夹的内容对我们了解Linux的工作特性大有帮助, 许多我们常用的命令只是将配置文件的信息打印出来而已. </p>
<h2 id="etc-子文件-夹-类型"><a href="#etc-子文件-夹-类型" class="headerlink" title="/etc/ 子文件(夹)类型"></a>/etc/ 子文件(夹)类型</h2><p><code>/etc</code>文件夹中并不是只有文本文件, 还有文件夹, 比如<code>/etc/cron.d/</code>. 在Linux系统中，”.d” 的后缀通常表示一个目录（directory）。这种命名约定用于指示特定目录中包含了相关配置文件或脚本的集合。在特定的上下文中，”.d” 目录通常用于<strong>允许系统管理员或应用程序添加、修改或删除与特定功能相关的配置文件，而无需修改主配置文件</strong>。这种设计模式提供了一种灵活的方式来管理和组织配置。</p>
<p>除了<code>.conf</code>后缀外, 还有一类特殊的后缀<code>-</code>. 在Linux系统中，”/etc/passwd-“ 文件的 “-“ 后缀通常表示一个备份文件。这种命名约定用于表示原始文件的备份副本，通常在对原始文件进行修改或更新之前创建。对于 “/etc/passwd-“ 文件而言，它是 “/etc/passwd” 文件的备份副本。”/etc/passwd” 是一个重要的系统文件，它包含了关于系统中用户账户的基本信息，如用户名、用户ID、用户主目录等。</p>
<h2 id="常见的文件有哪些"><a href="#常见的文件有哪些" class="headerlink" title="常见的文件有哪些?"></a>常见的文件有哪些?</h2><ul>
<li><p>用户相关信息:</p>
<ul>
<li>基本子文件夹:<ol>
<li><code>/etc/passwd</code>： 这个文件包含了系统上所有用户的基本信息，如用户名、用户ID、默认shell、主目录等。它用于验证用户登录和识别用户。</li>
<li><code>/etc/group</code>： 这个文件包含了系统上所有用户组的信息，如组名、组ID和组成员。它用于管理用户和组的关系，控制访问权限等。</li>
<li><code>/etc/shadow</code>： 这个文件存储了用户的加密密码和密码过期信息。它通常只对管理员可见，用于保护用户密码的安全性。</li>
<li><code>/etc/default/useradd</code> : 新增用户的默认设置。</li>
</ol>
</li>
<li>与用户相关的命令有:<ol>
<li><code>useradd</code> 命令用于创建新的用户账户。它会读取 <code>/etc/default/useradd</code> 文件中的默认设置，并将新用户的信息添加到 <code>/etc/passwd</code>、<code>/etc/shadow</code> 和 <code>/etc/group</code> 文件中。</li>
<li><code>passwd</code> 命令用于更改用户密码。它会修改 <code>/etc/shadow</code> 文件中的密码字段，将新密码加密后保存。</li>
<li><code>usermod</code> 命令用于修改现有用户账户的属性。它可以修改 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 中的相关字段，如用户名、用户组、用户主目录等。</li>
<li><code>userdel</code> 命令用于删除用户账户。它会从 <code>/etc/passwd</code>、<code>/etc/shadow</code> 和 <code>/etc/group</code> 文件中删除与用户相关的信息。</li>
<li><code>id</code> 命令用于显示用户的标识号（UID）和所属的组标识号（GID）。它会读取 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件来获取用户和组的相关信息。</li>
<li><code>who</code> 命令用于显示当前登录系统的用户信息。它读取 <code>/var/run/utmp</code> 文件来获取已登录用户的信息。</li>
</ol>
</li>
</ul>
</li>
<li><p>网络配置信息:</p>
<ul>
<li>手动配置网络:<ol>
<li><code>/etc/hosts</code>： 这个文件用于配置主机名与IP地址的映射关系。你可以在这里手动添加或编辑条目，以便在本地系统上解析主机名。</li>
<li><code>/etc/resolv.conf</code>： 这个文件包含了用于解析域名的DNS服务器的配置信息。你可以在这里指定DNS服务器的IP地址、搜索域等。</li>
<li><code>/etc/network/interfaces</code> 或 <code>/etc/sysconfig/network-scripts/ifcfg-*</code>： 这些文件用于配置网络接口的设置，如IP地址、子网掩码、网关等。具体文件名称可能因不同的Linux发行版而有所不同。<ul>
<li>与用户信息相关的不同, 网络配置相关配置文件多是用于手动配置. 下面列出的命令通过读取<strong>内核</strong>的网络状态信息，不涉及具体的文件。</li>
</ul>
<ol>
<li><code>ip</code>： <code>ip</code> 命令是一个强大的网络工具，用于配置和显示网络接口、路由表、网络命名空间等。它可以读取和修改网络接口的各种属性，如 IP 地址、子网掩码、网关等。</li>
</ol>
</li>
<li><code>netstat</code>： <code>netstat</code> 命令用于显示网络状态和连接信息。它可以显示当前活动的网络连接、监听的端口以及路由表等信息。</li>
<li><code>route</code>： <code>route</code> 命令用于配置和显示网络路由表。它可以添加、删除和修改路由表项，指定网络流量的传输路径。</li>
<li><code>iptables</code>： <code>iptables</code> 命令是一个强大的防火墙工具，用于配置和管理网络包的过滤和转发规则。它可以读取和修改防火墙规则，控制网络流量的传输。<blockquote>
<p>为什么没有<code>ifconfig</code>? 因为<code>ip</code>命令要强大的多, 故而最新版Ubuntu甚至不默认安装该命令了. </p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
<li><p>硬盘配置信息:</p>
<ul>
<li><code>/etc/fstab</code>：  <code>/etc/fstab</code> 文件是用于存储文件系统挂载信息的配置文件。它包含了挂载点、文件系统类型、设备文件和挂载选项等信息。通过编辑该文件，你可以配置系统启动时自动挂载文件系统的行为。</li>
<li>相关命令:<ol>
<li><code>fdisk</code>： <code>fdisk</code> 命令用于分区硬盘。它可以读取和修改硬盘的分区表，允许你创建、删除、调整分区等操作。<code>fdisk</code> 命令直接操作硬盘设备文件，例如 <code>/dev/sda</code>。</li>
<li><code>parted</code>： <code>parted</code> 命令也用于分区硬盘，但提供了更高级的分区操作功能。它可以读取和修改硬盘的分区表，支持更多的分区类型和功能。<code>parted</code> 命令直接操作硬盘设备文件，例如 <code>/dev/sda</code>。</li>
<li><code>mkfs</code>： <code>mkfs</code> 命令用于创建文件系统。它可以在指定的分区上创建不同类型的文件系统，如 ext4、NTFS 等。<code>mkfs</code> 命令直接操作分区设备文件，例如 <code>/dev/sda1</code>。</li>
<li><code>mount</code>： <code>mount</code> 命令用于挂载文件系统。它可以将指定的文件系统挂载到指定的挂载点上，使得文件系统中的内容可访问。<code>mount</code> 命令会修改 <code>/etc/fstab</code> 文件以记录挂载信息。</li>
<li><code>umount</code>： <code>umount</code> 命令用于卸载文件系统。它可以卸载已经挂载的文件系统，使得挂载点上的内容不再可访问。<code>umount</code> 命令会修改 <code>/etc/fstab</code> 文件以移除挂载信息。</li>
<li><code>fsck</code>： <code>fsck</code> (file system check)命令用于检查和修复文件系统。它可以读取和修改文件系统的元数据，检测和修复文件系统中的错误。<code>fsck</code> 命令直接操作文件系统设备文件，例如 <code>/dev/sda1</code>。</li>
</ol>
</li>
<li>工作逻辑:<ol>
<li>分区操作：<code>fdisk</code> 和 <code>parted</code> 命令<strong>直接操作硬盘的分区表</strong>，可以读取和修改分区信息，包括创建、删除、调整分区等。</li>
<li>文件系统操作：<code>mkfs</code> 命令用于创建文件系统，可以在指定的分区上创建不同类型的文件系统。<code>mount</code> 命令用于挂载文件系统，将文件系统挂载到指定的挂载点上。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>/etc/apt</code> 目录相关的重要文件和目录：</p>
<ol>
<li><code>/etc/apt/sources.list</code> 或 <code>/etc/apt/sources.list.d/</code> 目录：这些文件用于定义软件包源（软件仓库）。<code>sources.list</code> 是主要的源配置文件，而 <code>sources.list.d/</code> 目录包含了其他源配置文件，通常以 <code>.list</code> 扩展名结尾。这些文件指定了系统从哪些源获取软件包，包括官方源、第三方源以及其他自定义源。</li>
<li><code>/etc/apt/apt.conf</code> 或 <code>/etc/apt/apt.conf.d/</code> 目录：这些文件是APT的配置文件。你可以在这里设置各种选项，如代理设置、下载限速等。<code>apt.conf</code> 是主要的配置文件，而 <code>apt.conf.d/</code> 目录包含了其他配置文件，通常以 <code>.conf</code> 扩展名结尾。</li>
<li><code>/etc/apt/preferences</code>：该文件是一个可选的配置文件，用于定义软件包的优先级。你可以使用它来指定系统如何处理软件包版本冲突或优先选择特定版本。</li>
<li><code>/etc/apt/trusted.gpg</code> 和 <code>/etc/apt/trusted.gpg.d/</code> 目录：这些文件和目录包含了用于验证软件包签名的 GPG 密钥。APT使用这些密钥来确保下载的软件包是经过验证和信任的。</li>
</ol>
</li>
<li><p><code>/etc/crontab</code> 是一个系统级别的crontab文件，用于配置在Linux系统上定期运行的任务。Cron是一个用于执行预定时间间隔任务的守护进程。在 <code>/etc/crontab</code> 文件中，你可以定义系统范围的定时任务。这些任务可以是系统维护、备份、日志清理、定期脚本等等。</p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230609190732.png" alt=""><ul>
<li><code>m</code>：分钟（0-59）</li>
<li><code>h</code>：小时（0-23）</li>
<li><code>dom</code>：一个月的某一天（1-31）, 即 <code>day of a month</code></li>
<li><code>mon</code>：月份（1-12）</li>
<li><code>dow</code>：星期几（0-7，其中0和7都代表星期日）,即 <code>day of a week</code></li>
<li><code>user</code>：执行任务的用户</li>
<li><code>command</code>：要运行的命令或脚本</li>
<li><code>run-parts</code>命令表示运行路径下所有脚本.</li>
</ul>
</li>
<li>上述文件表明: 每小时的第17分钟，系统会运行 <code>/etc/cron.hourly</code> 目录中的脚本；每天的早上6:25，系统会运行 <code>/etc/cron.daily</code> 目录中的脚本；每周的星期天早上6:47，系统会运行 <code>/etc/cron.weekly</code> 目录中的脚本；每月的第一天早上6:52，系统会运行</li>
<li><code>/etc/cron.monthly</code> 目录中的脚本。    <ul>
<li>当我们要增加全局性的计划任务时，一种方式是直接修改/etc/crontab。但是，一般不建议这样做，/etc/cron.d目录就是为了解决这种问题而创建的。<ul>
<li><code>/etc/cron.d</code> 是Linux系统中存放 Cron 任务的目录。Cron 是一个用于在预定时间或间隔上运行指定命令或脚本的任务调度程序。在 <code>/etc/cron.d</code> 目录中，你可以找到一系列以文件名结尾为 <code>.conf</code> 的配置文件，这些文件包含了 Cron 任务的定义。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>/etc/ssh/sshd_config</code>： 这个文件包含了SSH服务器的配置选项，如端口号、允许的用户、登录选项等。它用于控制SSH连接的行为。</p>
</li>
<li><p><code>/etc/alternatives</code> 是一个特殊的目录，它在Linux系统中扮演着重要的角色。它实际上是一组符号链接（symbolic link）的集合，用于提供系统中不同可替代项之间的选择。</p>
<ul>
<li>在Linux系统中，有一些命令或路径有多个可选项，比如不同的版本或不同的实现方式。正是 <code>/etc/alternatives</code> 目录中的符号链接允许你在这些可选项之间进行切换。每个符号链接指向一个真正的可执行文件、路径或其他资源。通过更改这些符号链接，你可以更改系统中默认使用的可选项。</li>
<li><code>update-alternatives --config &lt;link&gt;</code>用于管理这些链接. 替换 <code>&lt;link&gt;</code> 为你要管理的符号链接名，比如 <code>vi</code>。显示一个列表，其中列出了可用的选项及其对应的编号、名称和路径。<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230609184701.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p><code>/etc/sysctl.conf</code> 是一个重要的配置文件，用于管理Linux系统内核参数。内核参数是控制和调整操作系统内核行为的设置。</p>
<ul>
<li>在 <code>/etc/sysctl.conf</code> 文件中，你可以定义和修改各种内核参数的值。这些参数影响着系统的性能、安全性和行为。通过修改这些参数，你可以优化系统的性能、改变网络设置、提高安全性等。</li>
<li>以下是一些 <code>/etc/sysctl.conf</code> 文件的示例设置：<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230609190234.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本处理: Regex is all you need!</title>
    <url>/2023/06/10/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-Regex-is-all-you-need/</url>
    <content><![CDATA[<h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式?"></a>什么是正则表达式?</h2><p>正则表达式是一种功能强大、灵活性高的模式匹配工具。它可以进行更复杂的模式匹配，包括字符的重复、选择、分组、反向引用等。在Linux系统使用过程中, 有时会把它和<code>通配符(wildcards)</code>弄混淆. </p>
<p>通配符是一种特殊字符或字符序列，用于在文件名匹配和搜索中代表其他字符或字符序列。通配符可以替代一个或多个字符，以便匹配符合特定模式的文件名或文本字符串。它的形式与正则表达式非常相似, 但逻辑有所不同: 通配符的执行通常由操作系统或特定工具处理，其匹配逻辑可能是基于简单的字符串匹配算法。而正则表达式通常由正则表达式引擎执行，这些引擎会使用更复杂的算法和技术来实现正则表达式的模式匹配，如NFA（非确定有限自动机）或DFA（确定有限自动机）。</p>
<p>以下是一些常见的通配符:</p>
<ol>
<li>“[]“（范围通配符）：用于指定一个字符范围。例如，”[a-z]“ 可以匹配任何小写字母字符，”[0-9]” 可以匹配任何数字字符。</li>
<li>“[!]”（否定通配符）：用于排除特定字符。例如，”[!a-z]” 可以匹配任何非小写字母字符，”[!0-9]” 可以匹配任何非数字字符。</li>
<li>“{,}”（集合通配符）：用于指定多个选项。例如，”{cat,dog}” 可以匹配 “cat” 或 “dog”。<ul>
<li>集合通配符中的值可以没有,表示为空. 但值之间需用逗号分隔. 且逗号前后不能有空格, 否则拓展失效(因为是直接在bash中运行, 空格是分割符).</li>
<li>不是文件拓展(如*, []等), 不管文件存在与否都拓展成给定值. 对于文件拓展, 当你按下tab时, 它会自动搜索匹配的文件, 并将所有匹配到文件直接原位置展开, 以空格分割.</li>
<li>优先级高,总是先被运行(相较于其他拓展)</li>
<li>可以嵌套拓展<ul>
<li>{A{1,2},B{1,2}}: 等于A1 A2 B1 B2</li>
</ul>
</li>
<li>{Start..End}: 与方括号类似,不过用”..”连接</li>
<li>{Start..End..Step}: 指定步长</li>
</ul>
</li>
<li>“()”（分组通配符）：用于将多个字符组合在一起以进行更复杂的匹配。例如，”(ab)+” 可以匹配连续出现的 “ab”。</li>
<li>“*“（星号）：匹配任意字符序列（包括空字符序列）。例如，”*.txt” 可以匹配所有以 “.txt” 结尾的文件名，如 “file.txt”、”document.txt” 等。在正则表达式中这通常表示匹配前面的字符0次或多次.<ul>
<li>“*/“再加上通配符可以匹配子目录,有几层子目录就写几层</li>
<li>“**/“可以匹配零个或者多个子目录</li>
</ul>
</li>
<li>“?”: 匹配任意单个字符.</li>
</ol>
<p>使用通配符能够让你在处理多个文件作为输入或是批量查看文件时提高效率, 然而它的重心在于”文件”, 而非专门的”文本”, 这也是为什么不将单列为一节. 要对文本进行处理, 还得看我Regex.</p>
<h2 id="正则表达式有哪些类型"><a href="#正则表达式有哪些类型" class="headerlink" title="正则表达式有哪些类型?"></a>正则表达式有哪些类型?</h2><p>或许你使用过多种语言, 也使用过他们提供的正则表达式工具, 那么你就会发现尽管大体相似, 但似乎每个语言的正则表达式都不尽相同. 通常我们将正则表达式分为三类, BRE, ERE, Perl正则.</p>
<p>BRE（Basic Regular Expressions）：BRE是一种比ERE更简单的正则表达式语法，支持较少的元字符和操作符，但仍可以满足基本的模式匹配需求。它主要被诸如grep、sed和awk等POSIX工具使用.</p>
<p>ERE（Extended Regular Expressions）：ERE是一种比BRE更强大的正则表达式语法，支持更多的元字符和操作符，如重复次数限定符（+、*、?等）、分组、反向引用等。Perl, Python, PHP中均用到了ERE, 需要注意的是 Python的re模块要使用ERE语法，需要通过指定标志参数（如re.VERBOSE）启用ERE语法。</p>
<p>Perl正则表达式（Perl-regex）：Perl正则表达式是一种高度灵活和功能强大的正则表达式语法，扩展了ERE和BRE的功能，并添加了许多Perl特定的功能和语法。它主要在Perl编程语言中使用，但也在其他编程语言中得到了应用, 如JavaScript：JavaScript的正则表达式语法受到Perl正则表达式的影响，例如，使用(?:…)进行非捕获分组，使用\1、\2等进行反向引用。R与python默认使用的就是perl正则表达式语法. </p>
<p>从BRE到ERE再到Perl-regex, 其拥有的高级特性越来越多.  然而直接列出每个正则的语法对我们使用他们没有任何帮助, 故而我接下来会逐点介绍他们的异同之处.</p>
<h2 id="不同Regex语法的相同之处"><a href="#不同Regex语法的相同之处" class="headerlink" title="不同Regex语法的相同之处"></a>不同Regex语法的相同之处</h2><blockquote>
<p>“[:alnum:]”,”[:alpha:]”,”[:digit:]”,”[:lower:]”,”[:upper:]”,”[:space:]”,”[:blank:]”,”[:graph:]”,”[:print:]”,”[:cntrl:]”,”[:punct:]”,”[:xdigit:]”,”[0-9]”,”[xyz]”,”[\^xyz]”,”[A-Za-z]”,”[\^A-Za-z]”,”*“,”\W”,”\w”,”\B”,”\b”,”\\“</p>
</blockquote>
<p>以上字符在各个Regex语法中 用法,功能都一致, 我们也可以将其称之为基础功能. 但需要注意的是形如<code>[:alnum:]</code>的正则符和通配符中的保持一致, 但真正使用时, 我们需要将其用<code>[]</code>再包起来, 而通配符和JavaScript的RegExp对象则不需要. </p>
<h2 id="相同Regex符号的不同之处"><a href="#相同Regex符号的不同之处" class="headerlink" title="相同Regex符号的不同之处"></a>相同Regex符号的不同之处</h2><ul>
<li>单词边界: 除<code>\b</code>外, 还有两个符号可以匹配边界,<code>\&lt;</code>,<code>\&gt;</code>. 其中<code>\&lt;</code>匹配左边界,<code>\&gt;</code>匹配右边界. 然而后者仅仅在BRE和ERE中支持, Perl-regex无法使用.</li>
<li><code>()</code>: <code>()</code>是一个极其重要的符号, 它可以: 1) 将一部分正则表达式视为一个整体，形成一个分组, 从而能对这个分组进行整体操作;  2) 构建子表达式，用于定义复杂的模式。这允许你组合和嵌套多个子表达式，以构建更复杂的模式匹配规则; 3) 捕获匹配的文本。匹配成功后，捕获组会记录匹配的文本，以便后续处理和引用。可以通过编号或命名来引用捕获组, 实现重复出现相同模式的匹配，或者进行替换操作。在ERE和Perl-regex中, 可以直接使用, 但在BRE中需要对括号进行转义(这是BRE使用高级功能的办法, 为了后续说明简单, 若需要进行转义则表述为<code>转义使用</code>).</li>
<li><code>?</code>: 匹配前面的子表达式 0 次或 1 次（等价于{0,1}). 只有BRE需要<code>转义使用</code>.</li>
<li><code>+</code>: 匹配前面的子表达式 1 次或多次（等价于{1, }).  只有BRE需要<code>转义使用</code>.</li>
<li><code>&#123;n&#125;,&#123;n,&#125;&#123;n,m&#125;</code>: 匹配n次/大于n次/n到m次. BRE需要对<code>&#123;&#125;</code>进行转义(即<code>\&#123;\&#125;</code>)</li>
<li><code>.</code>: 匹配除换行符（’\n’）之外的任意单个字符.  如果要匹配包括“\n”在内的任何一个字符，请使用：’<code>(^$)|(.)</code>‘ (对于ERE), ‘<code>[.\n]</code>‘ (对于Perl-regex). 对于BRE, <code>awk</code>中句点能匹配换行符.</li>
<li><code>\num</code>: 匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用. BRE不支持.</li>
</ul>
<h2 id="有哪些文本处理工具"><a href="#有哪些文本处理工具" class="headerlink" title="有哪些文本处理工具?"></a>有哪些文本处理工具?</h2><p>文本处理最常用的三个命令行工具被我们称之为”linux三剑客”, 它们是：</p>
<ol>
<li><p>grep：grep 是 “Global Regular Expression Print” 的缩写，用于在文件中搜索匹配指定模式的文本行。它支持使用正则表达式进行强大的模式匹配，并可以递归搜索子目录。</p>
</li>
<li><p>sed：sed 是 “Stream Editor” 的缩写，它是一个流式文本编辑器，用于对文本进行流式处理。它主要用于在文本流中匹配和替换模式，并支持正则表达式、行选择、行删除、行插入等功能。</p>
</li>
<li><p>awk：awk 是一种强大的文本处理工具，用于从结构化文本文件中提取和操作数据。它支持灵活的模式匹配和处理，具有强大的文本处理能力和内置函数，可以进行数据过滤、转换、计算和格式化等操作。</p>
</li>
</ol>
<p>好像讲了, 又好像什么都没讲, 只知道用处不知道用法学了等于没学. 这三个命令各有所长, 接下来将逐一介绍.</p>
<h3 id="Grep命令"><a href="#Grep命令" class="headerlink" title="Grep命令:"></a>Grep命令:</h3><blockquote>
<p>控制匹配格式:</p>
</blockquote>
<ul>
<li><code>-i</code>（<code>--ignore-case</code>）：<ul>
<li>忽略大小写进行匹配。 例如：<code>grep -i &quot;hello&quot; file.txt</code></li>
</ul>
</li>
<li><code>-e pattern</code>（<code>--regexp=pattern</code>）：指定一个模式进行搜索匹配。 <ul>
<li>例如：<code>grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; file.txt</code></li>
</ul>
</li>
<li><code>-v</code>（<code>--invert-match</code>）：<ul>
<li>反转匹配，只显示不匹配的行。 例如：<code>grep -v &quot;error&quot; file.txt</code></li>
</ul>
</li>
<li><code>-w</code>（<code>--word-regexp</code>）：仅匹配完整的单词，而不是部分匹配。<ul>
<li>例如：<code>grep -w &quot;word&quot; file.txt</code></li>
</ul>
</li>
<li><code>-x</code>（<code>--line-regexp</code>）：只匹配整行，而不是行中的部分内容。<ul>
<li>例如：<code>grep -x &quot;exact line&quot; file.txt</code></li>
<li>事实上等同于<code>^pattern$</code></li>
</ul>
</li>
<li><code>-w</code> (<code>--word-regexp</code>) : 只显示全字符合的列。</li>
<li><code>-f file</code>（<code>--file=file</code>）：从指定文件中读取模式，逐行搜索匹配。 <ul>
<li>例如：<code>grep -f patterns.txt file.txt</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>选择不同的正则表达式语法: </p>
</blockquote>
<ul>
<li><code>-E</code>（<code>--extended-regexp</code>）：使用扩展的正则表达式语法ERE。 <ul>
<li>例如：<code>grep -E &quot;pattern&quot; file.txt</code></li>
<li>等同于<code>egrep &quot;pattern&quot; file.txe</code></li>
</ul>
</li>
<li><code>-P</code>（<code>--perl-regexp</code>）：使用 Perl 兼容的正则表达式语法Perl-regex。 <ul>
<li>例如：<code>grep -P &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-F</code>（<code>--fixed-strings</code>）：按照字符串字面值进行匹配，而不是正则表达式。 <ul>
<li>例如：<code>grep -F &quot;string&quot; file.txt</code></li>
</ul>
</li>
<li><code>-G</code> (<code>--basic-regexp</code>) : 默认情况下，<code>grep</code> 命令使用基本正则表达式进行匹配，因此可以省略 <code>-G</code> 参数。</li>
</ul>
<blockquote>
<p>控制匹配的文件</p>
</blockquote>
<ul>
<li><code>-x</code>（<code>--exclude=file</code>）：指定要排除的文件模式。 <ul>
<li>例如：<code>grep &quot;pattern&quot; --exclude=&quot;*.log&quot; directory</code></li>
<li>其他用法同下;</li>
</ul>
</li>
<li><code>--include=file</code>：指定要包含的文件模式。<ul>
<li>例如：<code>grep &quot;pattern&quot; --include=&quot;*.txt&quot; directory</code></li>
<li>多个文件：使用逗号分隔多个要包含的文件模式。例如：<code>--include=*.txt,*.log</code>。</li>
<li>通配符模式：使用通配符模式指定要包含的文件。例如：<code>--include=prefix*</code>。</li>
<li>文件路径：使用相对或绝对文件路径指定要包含的文件。例如：<code>--include=/path/to/included/file.txt</code>。</li>
</ul>
</li>
<li><code>-r</code> 参数同样会递归搜索指定目录及其所有子目录中的文件内容，但不会包括符号链接所指向的目录。当遇到符号链接时，它会忽略链接所指向的目录，而不会进一步递归搜索。<ul>
<li>例如：<code>grep -r &quot;pattern&quot; directory</code></li>
<li><code>-R</code> 参数会递归搜索指定目录及其所有子目录中的文件内容，包括符号链接所指向的目录。它会遍历整个目录树来搜索匹配的文件内容。</li>
</ul>
</li>
<li><code>--exclude-dir=dir</code>：排除指定目录的搜索。该选项只适用于递归搜索，并且排除的目录将被完全忽略，不会搜索其下的任何文件或子目录。<ul>
<li>例如：<code>grep &quot;pattern&quot; --exclude-dir=docs directory</code></li>
<li>单个目录：指定要排除的单个目录的名称。例如：<code>--exclude-dir=logs</code>。</li>
<li>多个目录：使用逗号分隔多个要排除的目录名称。例如：<code>--exclude-dir=logs,cache</code>。</li>
<li>通配符模式：使用通配符模式指定要排除的目录。例如：<code>--exclude-dir=docs*</code>。</li>
<li>目录路径：使用相对或绝对目录路径指定要排除的目录。例如：<code>--exclude-dir=/path/to/excluded</code>。</li>
</ul>
</li>
<li><code>-l</code>（<code>--files-with-matches</code>）：只显示包含匹配的文件名，而不显示匹配的具体行。<ul>
<li>例如：<code>grep -l &quot;pattern&quot; file1.txt file2.txt</code></li>
</ul>
</li>
<li><code>-L</code>（<code>--files-without-match</code>）：只显示不包含匹配的文件名。<ul>
<li>例如：<code>grep -L &quot;pattern&quot; file1.txt file2.txt</code></li>
</ul>
</li>
<li><code>-Z</code>（<code>--null</code>）：使用 NUL 字符作为文件名分隔符。NUL 字符是 ASCII 字符集中的控制字符，表示空字符或空值。它的 ASCII 值为 0（十进制）。在 Unix-like 系统中，NUL 字符通常用于表示字符串的结尾或作为文件名分隔符。<code>grep</code> 命令由此能够处理包含特殊字符或空格的文件名列表。Xargs命令也可以使用<code>-0</code>参数达到同样效果.<ul>
<li>例如：<code>grep -lz &quot;pattern&quot; file1.txt file2.txt</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bbb&quot;</span> &gt; file2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &gt; file3</span><br><span class="line"></span><br><span class="line">grep <span class="string">&quot;aaa&quot;</span> file* -lZ | xargs -0 <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>控制匹配输出格式</p>
</blockquote>
<ul>
<li><code>-n</code>（<code>--line-number</code>）：显示匹配行的行号。 <ul>
<li>例如：<code>grep -n &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-c</code>（<code>--count</code>）：只显示匹配的行数。 <ul>
<li>例如：<code>grep -c &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-q</code>（<code>--quiet</code>）：静默模式，不输出<strong>任何结果</strong>。 <ul>
<li>例如：<code>grep -q &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-s</code>（<code>--no-messages</code>）：静默模式，不显示<strong>错误信息</strong>。 <ul>
<li>例如：<code>grep -s &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-o</code> (<code>--only-matching</code>): 只显示匹配PATTERN 部分。</li>
</ul>
<blockquote>
<p>匹配 = 定位, 以下系数控制输出更多行, 譬如匹配一个ID, 输出它下面N行的数据.</p>
</blockquote>
<ul>
<li><code>-A num</code>（<code>--after-context=num</code>）：显示匹配行之后的 num 行内容。<ul>
<li>例如：<code>grep -A 3 &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-B num</code>（<code>--before-context=num</code>）：显示匹配行之前的 num 行内容。 <ul>
<li>例如：<code>grep -B 2 &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>-C num</code>（<code>--context=num</code>）：显示匹配行之前和之后的 num 行内容。<ul>
<li>例如：<code>grep -C 2 &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
<li><code>--group-separator=SEP</code>:  将匹配的组(也即匹配的行以及要输出的上下文)用分隔符分开</li>
<li><code>-m num</code>（<code>--max-count=num</code>）：设置匹配的最大行数。 <ul>
<li>例如：<code>grep -m 5 &quot;pattern&quot; file.txt</code></li>
</ul>
</li>
</ul>
<h3 id="Sed命令"><a href="#Sed命令" class="headerlink" title="Sed命令:"></a>Sed命令:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [选项] [脚本命令] 文件名</span><br></pre></td></tr></table></figure>
<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><blockquote>
<p>配置命令输出格式</p>
<ol>
<li><code>-n</code>,<code>--quiet</code>, <code>--silent</code>：禁止自动打印模式空间的内容。默认情况下，sed会自动打印模式空间的内容到标准输出。使用<code>-n</code>参数后，只有通过sed的打印命令（例如p）才会输出内容。</li>
<li><code>-i</code>：直接在源文件中进行修改。默认情况下，sed会将修改后的结果输出到标准输出。使用<code>-i</code>参数后，sed会直接在源文件中进行修改，并将结果写入源文件。例如：<code>sed -i &#39;s/pattern/replacement/&#39; file.txt</code>。</li>
</ol>
<p>与grep命令中含义一致的参数:</p>
<ol>
<li><code>-e</code>：允许在命令行上指定要执行的sed脚本。可以使用多个<code>-e</code>参数来指定多个命令。例如：<code>sed -e &#39;command1&#39; -e &#39;command2&#39; file.txt</code>。与Grep命令中含义一致.</li>
<li><code>-f</code>：从指定的文件中读取sed脚本。脚本文件中可以包含多个sed命令，每个命令占据一行。例如：<code>sed -f script.sed file.txt</code>。和Grep命令中含义一致.</li>
<li><code>-r</code>,<code>-E</code>,<code>--regexp-extended</code>：启用扩展的正则表达式语法。默认情况下，sed使用基本的正则表达式语法。使用<code>-r</code>参数后，可以使用更多的元字符和语法结构。<code>-E</code>与Grep命令中含义一致.</li>
<li><code>-z</code>：将输入文件视为以null字符分隔的记录。默认情况下，sed将输入文件视为以换行符分隔的记录。使用<code>-z</code>参数后，sed将输入文件视为以null字符（\0）分隔的记录。与Grep命令中含义一致.</li>
</ol>
<p>处理方式控制</p>
<ol>
<li><code>-l N</code>,<code>--line-length=N</code>: 在sed命令中，-l参数（或—line-length）用于指定输出行的最大长度。它限制了sed命令所产生的输出行的字符数量。当输出行的长度超过指定的最大长度时，sed命令将会对输出行进行截断，只保留指定长度的部分。这可以用来控制输出的格式，使得输出行在显示或处理上更易于处理。</li>
<li><code>-s</code>：在处理多个文件时，将每个文件视为独立的流。默认情况下，sed会将所有文件视为一个连续的流，并在所有文件上执行给定的命令。使用<code>-s</code>参数后，sed会将每个文件视为独立的流，并在每个文件上分别执行命令。<code>file-wise</code>形式执行命令.</li>
</ol>
<p>不那么常用的参数(毕竟核心是命令):</p>
<ol>
<li><code>-b</code> 或 <code>--binary</code>：以二进制模式打开文件。默认情况下，sed将文件视为文本文件并以文本模式打开。使用<code>-b</code>参数后，sed将以二进制模式打开文件，可以用于处理二进制文件。</li>
<li><code>-u</code> 或 <code>--unbuffered</code>：禁用输出缓冲。默认情况下，sed会在打印输出之前对其进行缓冲。使用<code>-u</code>参数后，禁用输出缓冲，使得输出立即可见。</li>
<li><code>-y</code>：执行逐字符替换。默认情况下，sed会按照给定的替换规则对文本进行模式匹配和替换。使用<code>-y</code>参数后，sed将执行逐字符的替换，将一个字符映射为另一个字符。</li>
<li><code>-h</code> 或 <code>--no-default-hold</code>：禁用默认的模式保持空间。默认情况下，sed使用一个特殊的模式保持空间来存储处理过的行。使用<code>-h</code>参数后，禁用默认的模式保持空间，可以使用自定义的保持空间。</li>
<li><code>-H</code> 或 <code>--default-hold</code>：启用默认的模式保持空间。如果在使用<code>-h</code>参数后想恢复默认的模式保持空间，可以使用<code>-H</code>参数。</li>
</ol>
</blockquote>
<h4 id="command解析"><a href="#command解析" class="headerlink" title="command解析"></a><code>command</code>解析</h4><p>sed命令语法格式为<code>[addr]X[options]</code>, <code>[addr]</code>是可选参数, 控制<code>X</code>(单个字符,决定执行什么命令)处理的对象, 若<code>[addr]</code>为空则默认全部. 而<code>[options]</code>则是对于<code>X</code>而言的, 只有部分命令用得上.</p>
<p><code>[addr]</code>可以是一个数值(<code>sed &#39;35d&#39; input.txt</code>), 正则表达式(<code>sed &#39;/^foo/q42&#39; input.txt</code>, 表示当该行找到时, 会以<code>42</code>状态码退出命令), 或是一个范围(<code>sed &#39;30,35d&#39; input.txt</code>).</p>
<p>执行多个命令有多种不同格式. 你可以使用<code>;</code>隔开, 命令会先后执行, 首先，<code>/^foo/d</code>这个命令会匹配以”foo”开头的行，并删除这些匹配到的行。这是一个针对行的操作。然后，<code>s/hello/world/</code>命令会在每一行中将第一个出现的”hello”替换为”world”。All characters following <code>a,c,i</code> commands are taken as the text to <code>append/change/insert</code>, 所以不能使用<code>;</code>分隔, 必须是<code>-e</code>参数或添加换行. <code>r</code>,<code>R</code>,<code>w</code>,<code>W</code>同理, 不过这次是文件名被破坏.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^foo/d ; s/hello/world/&#x27;</span> input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><br>你也可以使用<code>-e</code>参数指定不同命令:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;/^foo/d&#x27;</span> -e <span class="string">&#x27;s/hello/world/&#x27;</span> input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><br>你甚至可以直接指定含有命令的文件:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/^foo/d&#x27;</span> &gt; script.sed</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;s/hello/world/&#x27;</span> &gt;&gt; script.sed</span><br><span class="line">sed -f script.sed input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><br>括号 <code>&#123;&#125;</code> 用于分组多个命令，以便对一组命令进行相同的操作或逻辑控制。大括号 <code>&#123;&#125;</code> 内可以包含多个sed命令，每个命令之间使用分号 <code>;</code> 分隔。当sed处理到大括号时，它会将大括号内的命令作为一个单独的组，并按照顺序逐个执行其中的命令。<strong>在匹配特定模式时执行一系列操作</strong>.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -e <span class="string">&#x27;/pattern/&#123;s/foo/bar/; s/baz/qux/&#125;&#x27;</span> input.txt</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p><hr><br><strong>以下单独解释下各个命令的作用.</strong></p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p><code>a\ (\n) text</code>,<code>a text</code>: 在匹配处之后添加新行.<br><code>c\ (\n) text</code>,<code>c text</code>: Replace (change) lines with text (alternative syntax).<br><code>d</code>: Delete the pattern space; immediately start next cycle.<br><code>D</code>: 用于删除模式空间中的第一个换行符及其之前的内容，并将剩余的内容重新加载到模式空间中，然后继续执行后续的sed命令。<br><code>s/regexp/replacement/[flags]</code>: (substitute) Match the regular-expression against the content of the pattern space. If found, replace matched string with replacement.<br><code>i\ (a \n) text</code>,<code>i text</code>: insert text before a line (alternative syntax).<br><code>e command</code>: <code>s/foo/echo bar/e</code>命令将会将匹配到的”foo”替换为”echo bar”，然后执行这个替换后的内容作为Shell命令。该Shell命令的输出结果会取代原始匹配的文本。<br>需要注意的是，<code>e</code>命令只能在替换命令中使用，并且仅在替换命令的右侧才会生效。它不能用于其他sed命令或正则表达式的匹配部分。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/foo/echo bar/e&#x27;</span> input.txt</span><br></pre></td></tr></table></figure></p>
<h5 id="模式空间与保持空间"><a href="#模式空间与保持空间" class="headerlink" title="模式空间与保持空间"></a>模式空间与保持空间</h5><blockquote>
<p>模式空间是sed命令处理的主要工作区域，它会逐行地读取输入文本并进行处理。每次处理一行时，当前行的内容会存储在模式空间中。sed命令会对模式空间中的数据进行操作，例如匹配、替换、删除等操作。完成对当前行的处理后，模式空间会被清空，然后继续处理下一行。<br>保持空间是另一个临时存储区域，它可以用来存储额外的数据。保持空间在整个处理过程中可以持久存在，不会像模式空间那样在处理完一行后被清空。你可以使用sed命令的特定命令（如g、G、h、H等）来在模式空间和保持空间之间进行数据交换。这样可以在不同的行之间传递数据，或者将数据保存起来供后续处理使用。</p>
</blockquote>
<p><code>g</code>: 将保持空间中的内容复制到模式空间中。它会用保持空间的内容替换当前模式空间的内容。<br><code>G</code>: 将保持空间中的内容追加到模式空间中的行后。在模式空间中的当前行和保持空间中的内容之间会添加一个换行符。<br><code>h</code>: 将模式空间中的内容复制到保持空间中。它会用模式空间的内容替换当前保持空间的内容。<br><code>H</code>: 将模式空间中的内容追加到保持空间中的行后。在保持空间中的当前行和模式空间中的内容之间会添加一个换行符。<br><code>x</code>:交换两空间的内容;<br><code>z</code>:(zap) This command <strong>empties</strong> the content of pattern space.<br><code>n</code>: 当sed处理文件，遇到n命令时，它会将当前模式空间的内容输出，然后读取下一行，替换当前模式空间的内容。在下面的这个案例中, 每一次执行, 首先读取一行到模式空间并print, 随后n命令直接读取新的一行替换掉当前行, 后续命令会对该行进行处理(这里没有后续命令了), 同时由于该行已经被读取出来了, 第二次直接读取了第三行, 所以从结果上看类似与跳过了第二,四行.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;1,5 &#123;p; n&#125;&#x27;</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line"></span><br><span class="line">sed -n <span class="string">&#x27;1,5 p&#x27;</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br></pre></td></tr></table></figure><br><code>N</code>: 用于将下一行<strong>添加</strong>(而非替换)到模式空间中，并在两行之间插入一个换行符。这允许对多行文本进行操作。一旦多行文本位于模式空间中，可以使用其他sed命令对其进行处理，如正则表达式匹配、替换或删除等操作。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;N; s/foo\nbar/baz/&#x27;</span> input.txt</span><br></pre></td></tr></table></figure></p>
<h5 id="输出当前文本信息"><a href="#输出当前文本信息" class="headerlink" title="输出当前文本信息"></a>输出当前文本信息</h5><p><code>p</code>: Print the pattern space(单行或多行). 如果模式空间中有多行内容，<code>p</code>命令会将它们全部打印出来。<br><code>P</code>: Print the pattern space, up to the first \<newline\>. <code>P</code>命令用于将模式空间中的当前行的第一行部分复制到标准输出，并且只打印复制的部分。它不会打印整个匹配到的行。<br><code>l</code>: 显示当前处理的文本行，并在行的末尾显示其非打印字符的编码。<br><code>F</code>: 输出当前正在处理的文件的名称, 并附上一个换行符.<br><code>=</code>: Print the <strong>current input line number</strong> (with a trailing newline).</p>
<h5 id="标签跳转"><a href="#标签跳转" class="headerlink" title="标签跳转"></a>标签跳转</h5><p><code>b label</code>:当sed解析到b命令时，它会立即跳转到指定的标签处，继续执行后续的命令。这意味着b命令可以用于跳过当前处理行中的后续命令，直接转到指定位置继续处理下一行。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/pattern/ &#123;</span></span><br><span class="line"><span class="string">    s/foo/bar/</span></span><br><span class="line"><span class="string">    b end</span></span><br><span class="line"><span class="string">    s/hello/world/</span></span><br><span class="line"><span class="string">    :end</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> input.txt</span><br><span class="line"><span class="comment">#如果某一行匹配了`/pattern/`模式，那么sed将执行该块内的命令。在</span></span><br><span class="line"><span class="comment">#这个块内，首先执行`s/foo/bar/`命令替换第一个出现的&quot;foo&quot;为&quot;bar&quot;。</span></span><br><span class="line"><span class="comment">#然后，`b end`命令会跳转到标签`:end`处，继续处理下一行，跳过了`s/hello/world/`命令。</span></span><br></pre></td></tr></table></figure><br><code>t label</code>: <code>sed</code>命令在执行过程中，会逐行处理输入文本。当遇到<code>t</code>命令时，它会检查最近执行的<code>s</code>（替换）命令是否成功（即是否有发生替换）。如果有替换发生，<code>t</code>命令将会将控制转移到指定的标签处继续执行后续命令。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/foo/bar/ ; t label ; s/123/456/&#x27;</span> input.txt</span><br><span class="line"><span class="comment">#`s/foo/bar/`命令会尝试将每一行中的&quot;foo&quot;替换为&quot;bar&quot;。</span></span><br><span class="line"><span class="comment">#如果发生了替换，`t label`命令将跳转到标签`label`处继续执行后续命令，即`s/123/456/`命令。</span></span><br><span class="line"><span class="comment">#如果没有发生替换，`t label`命令不会执行跳转，直接执行下一个命令。</span></span><br></pre></td></tr></table></figure><br><code>T label</code>: 含义与<code>t</code>相反, 当不成功时进行跳转.<br><code>#</code>: A comment, until the next newline.<br><code>: label</code>: Specify the location of label for branch commands (<code>b</code>, <code>t</code>, <code>T</code>).</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><code>q[exit-code]</code>: (quit) Exit <code>sed</code> without processing any more commands or input.<br><code>Q[exit-code]</code>:(quit) This command is the same as <code>q</code>, but will <strong>not print the contents of pattern space</strong>. Like <code>q</code>, it provides the ability to return an exit code to the caller.<br><code>w filename</code>:用于将匹配到的行写入指定的文件。语法为：<code>w filename</code>，其中<code>filename</code>是要写入的文件名。例如，<code>/pattern/w output.txt</code>会将匹配到模式<code>pattern</code>的行写入到output.txt文件中。如果output.txt文件已存在，行将被追加到文件末尾；如果文件不存在，将创建新文件。<br><code>W filename</code>:与<code>w</code>命令类似，但它只写入匹配到模式的行中的第一行，并且在写入后删除该行。语法为：<code>W filename</code>，其中<code>filename</code>是要写入的文件名。例如，<code>/pattern/W output.txt</code>会将匹配到模式<code>pattern</code>的行中的第一行写入到output.txt文件中，并在写入后将该行从模式空间中删除。<br><code>r filename</code>:Reads file filename.<br><code>R filename</code>:Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read.</p>
<hr>

<h4 id="如何选择行"><a href="#如何选择行" class="headerlink" title="如何选择行?"></a>如何选择行?</h4><ol>
<li>直接通过行号:<ol>
<li><code>number</code>: 选择对应行</li>
<li><code>$</code>: 选择最后一行</li>
<li><code>first~step</code>: 从<code>first</code>开始, 以<code>step</code>为步长选择行.</li>
</ol>
</li>
<li>通过正则表达式: 默认使用BRE(Grep也是), 除非指定<code>-E</code>,<code>-r</code>参数.<ol>
<li><code>/regexp/</code>: 注意当使用<code>//</code>即空的正则时, 会使用上一个正则, 不论是<code>;</code>,<code>-e</code>,<code>-f</code>方法指定的.</li>
<li><code>\%regexp%</code>: <code>%</code>可以是任何其他单字符. 主要用在需要匹配路径的情况, 毕竟一个个转义也太麻烦了.</li>
<li><code>/regexp/I</code>,<code>\%regexp%I</code>: <code>I</code>修饰符的作用主要是令匹配大小写不敏感. 注意<code>i</code>是插入命令, 并非大小写敏感开关!</li>
<li><code>/regexp/M</code>, <code>\%regexp%M</code>: <code>M</code>意为<code>multiple</code>, 开启多行模式, <code>^$</code>只会匹配空行, 而非<code>buffer</code>的起点和终点(\` 和\‘, 注意一个是行内代码符号`, 一个是单引号).</li>
</ol>
</li>
<li>通过范围:<ol>
<li><code>num1,num2</code>: 匹配 [num1, num2]行, 包含num1,2. 注意若num2\&lt;num1, 则仅取一行.</li>
<li><code>0,/regexp/</code>: <code>1,/regexp/</code>会导致第一行中regex不被匹配到.</li>
<li><code>addr1,+N</code>: 匹配<code>addr1</code>后面N行.</li>
<li><code>addr1,~N</code>: 从匹配到<code>addr1</code>开始, 一直到下一个N的整数倍行.</li>
</ol>
</li>
</ol>
<h4 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h4><p>可以点击<a href="https://www.gnu.org/software/sed/manual/sed.html#Examples">这里</a>查看sed官方提供的例子, 很详细, 你可以学习到如何写一个sed脚本.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/sed -f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Put 80 spaces in the buffer</span></span><br><span class="line">1 &#123;</span><br><span class="line">  x</span><br><span class="line">  s/^$/          /</span><br><span class="line">  s/^.*$/&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;/</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete leading and trailing spaces</span></span><br><span class="line">y/TAB/ /</span><br><span class="line">s/^ *//</span><br><span class="line">s/ *$//</span><br><span class="line"></span><br><span class="line"><span class="comment"># add a newline and 80 spaces to end of line</span></span><br><span class="line">G</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep first 81 chars (80 + a newline)</span></span><br><span class="line">s/^\(.\&#123;81\&#125;\).*$/\1/</span><br><span class="line"></span><br><span class="line"><span class="comment"># \2 matches half of the spaces, which are moved to the beginning</span></span><br><span class="line">s/^\(.*\)\n\(.*\)\2/\2\1/</span><br></pre></td></tr></table></figure></p>
<h3 id="Awk命令"><a href="#Awk命令" class="headerlink" title="Awk命令"></a>Awk命令</h3><p>前面已经介绍了两种工具，其中：<code>grep</code> 主要用于在文件中搜索匹配的行，适用于简单的文本搜索和过滤； <code>sed</code> 主要用于对文本进行转换、替换和删除等操作，适用于对文本进行批量处理。而 <code>awk</code> 主要用于处理结构化文本数据，通过分割字段和处理行来提取和转换数据，适用于处理复杂的文本处理任务。</p>
<h4 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h4>]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫笔记: Javascript逆向分析</title>
    <url>/2023/06/15/Python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0-Javascript%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>本篇笔记的目的在于记录学习JavaScript逆向的一个过程，由于博主并没有APP逆向的需求，所以仅涉及以下两项：</p>
<ul>
<li>逆向算法：分为能够被解密的算法，对称加密算法（AES，DES等），非对称加密算法（RSA）；不能被解密的算法，消息摘要算法（md5，sha），数字签名算法（哈希）。</li>
<li>逆向混淆：ob混淆，webpack，jsdom等等</li>
</ul>
<p>同时本篇内容属于<code>skill learning</code>板块，会主要从实践出发，因而会给出一些案例。</p>
<h3 id="初步了解：一次完整的抓包"><a href="#初步了解：一次完整的抓包" class="headerlink" title="初步了解：一次完整的抓包"></a>初步了解：一次完整的抓包</h3><p>这一节我们主要通过<code>http://www.whggzy.com/front/search/category</code>网站来学习进行数据抓包的一个流程。</p>
<ul>
<li><p>首先我们进入该网站，并右键-&gt;点击检查或者直接敲击F12进入浏览器的开发者工具。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-180046.png" alt=""><br>在开发者工具选项中，我们常用栏目有四个：1）元素，这是我们的浏览器实际渲染后的页面。2）控制台，能够与JavaScript进行交互，尤其在我们进入XHR断点时有用。3）源代码，能够查看网站的静态资源，当请求的参数 or 数据 or 标头中有加密内容时，我们需要从这些源代码中找到对应的加密代码，并修改成python形式。4）网络，这一个模块是我们用的最多的模块，我们往往需要通过这一模块查看各个请求的信息。</p>
</li>
<li><p>随后，我们随意选取一个条目，通过关键字在网络中筛选出对应链接。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-181157.png" alt=""><br>具体步骤为：1）复制关键字，本例中为“乌海市公共资源交易中心国有土地使用权挂牌出让公告乌资交挂字〔2023〕29号”。2）打开开发者工具并定位到网络栏目，<code>ctrl+F</code> 打开搜索侧边栏，输入关键字并按下<code>enter</code>，点击出现的条目进入到详情栏。</p>
</li>
<li><p>从详情栏目我们可以获得构建一次请求所必须的信息。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-181556.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-184654.png" alt=""></p>
</li>
</ul>
<p>标头栏：1）常规，关键在于<code>请求URL</code>和<code>请求方法</code>, 需要注意的是有的URL由于含有字符串参数，往往显得比较长，我们只需要取前面的部分即可。2）请求标头，在Python中使用字典构建对应的headers从而欺骗网站服务器。</p>
<p>负载：可能分为两类，1）查询字符串参数，即URL 中<code>?</code> 后面<code>#</code> 之前的部分，在requests中使用params参数指定；2）请求负载，即表单数据，使用data参数指定。</p>
<p>预览：查看服务端对本次请求返回的结果。<br>从上述信息中，我们可以在Python中构建出这一请求，其中headers中的主机地址（host），域名（origin），防盗链接（referer），浏览器类型（User-Agent）是最基本的标头，几乎必填。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://www.whggzy.com/front/search/category&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;categoryCode&quot;</span>: <span class="string">&quot;ZcyAnnouncement41&quot;</span>, <span class="string">&quot;pageSize&quot;</span>: <span class="number">15</span>, <span class="string">&quot;pageNo&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.whggzy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://www.whggzy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://www.whggzy.com/ZcyAnnouncement4/ZcyAnnouncement41/index.html&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">session = requests.session()</span><br><span class="line">response = session.post(url=url, data=data, headers=headers)</span><br><span class="line">response.text</span><br><span class="line"><span class="comment">#$ &#x27;系统出错,请稍后重试&#x27;</span></span><br></pre></td></tr></table></figure><br>Oops！但是结果为什么会出错？<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.status_code</span><br><span class="line"><span class="comment">#$ 500 </span></span><br></pre></td></tr></table></figure><br>状态码500——表示服务器端错误，然而我们的网页正常渲染了？这说明我们的请求没有能够通过验证。这就要求我们对请求进行调试。</p>
<ul>
<li><p>如何调试？我们首先将<code>front/search/category</code>这一个URL相对地址复制，进入源代码页面，找到右侧边栏中的”XHR/提取断点”, 点击右侧加号添加一个断点，并将相对地址粘贴，接着刷新页面即可。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-183440.png" alt=""></p>
</li>
<li><p>并没有我们想要的结果？点击侧边栏上策的横向箭头进入下一步。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-183704.png" alt=""></p>
</li>
<li><p>持续几次后我们会进入这一页面。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2023/06/15/20230615-183927.png" alt=""></p>
</li>
</ul>
<p>经过检查作用域中headers和options的参数，我们发现情况不对！</p>
<p>其一是RequestHeaders中校验了Accept，Content-Type，X-Requested-With三个标头，而我们并没有将其加入到我们的请求headers中。这种校验通常是由JavaScript来完成，而非直接传入服务端，否则在headers中加入病毒就可以直接威胁到服务器的安全。</p>
<p>其二是网站居然将data作为一个字符串传输！而在我们的视角中，浏览器会默认将这个字符串解析成json格式。了解了这点后，我们可以对request进行修改。</p>
<blockquote>
<p>这实际上是浏览器防爬虫的一种手段，其他类似的方法还有将<code>get</code>改<code>post</code>等。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://www.whggzy.com/front/search/category&quot;</span></span><br><span class="line"><span class="comment"># data = &#123;&quot;categoryCode&quot;: &quot;ZcyAnnouncement41&quot;, &quot;pageSize&quot;: 15, &quot;pageNo&quot;: 1&#125;</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;&#123;&quot;categoryCode&quot;:&quot;ZcyAnnouncement41&quot;,&quot;pageSize&quot;:15,&quot;pageNo&quot;:1&#125;&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>:    <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>:    <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;X-Requested-With&quot;</span>:    <span class="string">&quot;XMLHttpRequest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.whggzy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://www.whggzy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://www.whggzy.com/ZcyAnnouncement4/ZcyAnnouncement41/index.html&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line">response = session.post(url=url, data=data, headers=headers)</span><br><span class="line"></span><br><span class="line">response.text</span><br><span class="line"><span class="comment">#$ &#x27;&#123;&quot;took&quot;:4,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful.............</span></span><br></pre></td></tr></table></figure>
<p>好耶！ 我们成功地获取了json文件（即类似python字典的这种格式）！</p>
<p>当然，通过<code>response.text</code>得到的是一个字符串，要想得到一个字典格式，我们需要使用<code>response.json()</code>或者是<code>json.loads(response.text)</code>的格式。</p>
<p>与<code>json.loads</code>相反的一个操作是<code>json.dumps</code>, 譬如我们前面想将data从字典形式变为字符串形式，就可用这一函数。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">&quot;categoryCode&quot;</span>: <span class="string">&quot;ZcyAnnouncement41&quot;</span>, <span class="string">&quot;pageSize&quot;</span>: <span class="number">15</span>, <span class="string">&quot;pageNo&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">data = json.dumps(data)</span><br><span class="line"><span class="comment">#$ &#x27;&#123;&quot;categoryCode&quot;:&quot;ZcyAnnouncement41&quot;,&quot;pageSize&quot;:15,&quot;pageNo&quot;:1&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>RstudioServer环境配置</title>
    <url>/2021/09/15/RstudioServer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="1-Rstudio-Server的安装："><a href="#1-Rstudio-Server的安装：" class="headerlink" title="1. Rstudio-Server的安装："></a>1. Rstudio-Server的安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y r-base</span><br><span class="line">sudo apt install -y gdebi-core </span><br><span class="line">wget https://download2.rstudio.org/rstudio-server-1.1.383-amd64.deb</span><br><span class="line">sudo gdebi rstudio-server-1.1.383-amd64.deb</span><br><span class="line">rstudio-server start</span><br></pre></td></tr></table></figure>
<p>使用自己的账户和密码即可在 ip+:+port(8787)登录</p>
<h3 id="2-布置内网穿透"><a href="#2-布置内网穿透" class="headerlink" title="2. 布置内网穿透:"></a>2. 布置内网穿透:</h3><ol>
<li>登录Sunny-Ngrok</li>
</ol>
<blockquote>
<p> <a href="https://www.ngrok.cc/">Sunny-Ngrok内网转发内网穿透 - 国内内网映射服务器</a>：</p>
</blockquote>
<ol>
<li>开通隧道：<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005162102.png" alt="image-20220416225229148"></li>
<li>下载sunny linux 64 bit：<a href="https://www.ngrok.cc/download.html">Sunny-Ngrok内网转发</a></li>
<li>解压 <code>unzip linux_amd64.zip</code></li>
<li><code>./sunny clientid 171556355325</code>打开</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005162105.png" alt="image-20220416225650485"></li>
<li><code>Forwarding</code>对应网址即可直接打开；</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005162111.png" alt="image-20220416225902902"></li>
</ol>
<h3 id="3-SSH-Xming图形化界面打开："><a href="#3-SSH-Xming图形化界面打开：" class="headerlink" title="3. SSH+Xming图形化界面打开："></a>3. SSH+Xming图形化界面打开：</h3><ol>
<li><p>下载putty <a href="https://the.earth.li/~sgtatham/putty/latest/w64/putty-64bit-0.76-installer.msi"><code>putty-64bit-0.76-installer.msi</code></a></p>
</li>
<li><p>点击安装，一路确认；<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005162114.png" alt="image-20220416230124724"></p>
</li>
<li><p>PuTTYgen生成新的密钥</p>
<p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005162115.png" alt="image-20220416230420589"></p>
<p><img src="D:\OneDrive\Molaison_notes\source\_posts\Rstudioserver\image-20220416230541602.png" alt="image-20220416230541602"></p>
<p>红圈为公钥，复制；蓝圈为私钥，保存；</p>
</li>
<li><p>在默认的 <code>/home/.ssh/</code>目录下创建 <code>authorized_keys</code>文件，将上一步复制好的公钥复制到该文件中；</p>
</li>
<li><p>设置 <code>.ssh</code>  <code>authorized_keys</code>权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ <span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 SSH，打开密钥登录功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config </span><br><span class="line"><span class="comment">###/etc/ssh/sshd_config </span></span><br><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host .ssh]$ service sshd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时使用如下代码应当可以直接成功,如果不行则重启虚拟机和主机再试.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh host_name@host_ip </span><br></pre></td></tr></table></figure>
</li>
<li><p>安装xwindows组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x-window-system-core</span><br></pre></td></tr></table></figure>
</li>
<li><p>主机内下载xming<a href="https://sourceforge.net/projects/xming/">Xming X Server for Windows download | SourceForge.net</a></p>
</li>
<li><p>安装之后打开，进入ssh，输入<code>firefox &amp;</code>即可打开浏览器，并直接用Ip：port进入Rstudio-server(因为实际上用的是host的浏览器)</p>
</li>
</ol>
<h3 id="4-TightvncViewer"><a href="#4-TightvncViewer" class="headerlink" title="4. TightvncViewer"></a>4. TightvncViewer</h3><h3 id="5-可能出现的错误："><a href="#5-可能出现的错误：" class="headerlink" title="5. 可能出现的错误："></a>5. 可能出现的错误：</h3><h5 id="1-密钥登录Server-refused-our-key"><a href="#1-密钥登录Server-refused-our-key" class="headerlink" title="1. 密钥登录Server refused our key"></a>1. 密钥登录Server refused our key</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 authorized_keys </span><br><span class="line"><span class="built_in">chmod</span> 700 /root/.ssh</span><br></pre></td></tr></table></figure>
<p>首先第一步需要确保权限设置正确；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> <span class="variable">$USER</span>:<span class="variable">$USER</span> ~/.ssh -R</span><br></pre></td></tr></table></figure>
<h4 id="home、end、pgup、pgdn为什么都会变成小键盘的数字82467193。"><a href="#home、end、pgup、pgdn为什么都会变成小键盘的数字82467193。" class="headerlink" title="home、end、pgup、pgdn为什么都会变成小键盘的数字82467193。"></a>home、end、pgup、pgdn为什么都会变成小键盘的数字82467193。</h4><p>切换输入法，回到微软的自带的英文输入</p>
]]></content>
      <categories>
        <category>problem solving</category>
      </categories>
      <tags>
        <tag>data analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-blog环境配置</title>
    <url>/2022/10/05/hexo-blog%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="基本软件安装与配置"><a href="#基本软件安装与配置" class="headerlink" title="基本软件安装与配置"></a>基本软件安装与配置</h2><h3 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h3><p>step 1: 进入nodejs官网 —- <a href="https://nodejs.org/en/">nodejs</a><br>step 2: Download for Windows(x64) —&gt; 选择Long Term Support(LTS)项下载.<br>step 3: 打开msi文件, 等待guide wizard安装, 随后一路next即可(除了路径切换).<br>step 4: win+R —&gt; 输入cmd —&gt; 输入node -v查看版本信息 —&gt; 显示版本代表安装成功.</p>
<h3 id="git安装与配置"><a href="#git安装与配置" class="headerlink" title="git安装与配置"></a>git安装与配置</h3><p>下载与配置过程过于麻烦, 考虑到本文主题, 这里不做详细介绍, 可参照<a href="https://blog.csdn.net/mukes/article/details/115693833">git安装与配置</a>.</p>
<h3 id="hexo安装与配置"><a href="#hexo安装与配置" class="headerlink" title="hexo安装与配置"></a>hexo安装与配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//选择一个文件夹作为本地博客，右键 &gt; Git Bash Here</span><br><span class="line">npm i hexo-cli -g   //安装Hexo</span><br><span class="line">hexo -v   //查看hexo版本</span><br><span class="line">hexo init chniny-blog   //新建并初始化一个文件</span><br><span class="line"><span class="built_in">cd</span> chniny-blog   //进入文件夹</span><br><span class="line">npm install   //安装所需模块</span><br><span class="line">npm install hexo-deployer-git --save   //安装用于写markdown文档的模块</span><br></pre></td></tr></table></figure>
<h3 id="next主题下载"><a href="#next主题下载" class="headerlink" title="next主题下载"></a>next主题下载</h3><p>step 1: 下载next主题<br>method 1: 在本地博客文件夹右键 &gt; Git bash here:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>method 2: 进入<a href="https://github.com/theme-next/hexo-theme-next​">next-github</a>, 点击Code按钮, 点击Download ZIP. 将ZIP解压至本地文件夹的theme文件夹下, 并重命名为next(此处名称在设置主题时需要与配置文件保持一致).</p>
<p>step 2: 打开本地博客文件夹根目录下的_config.yml文件, 找到theme并配置为<code>theme:next</code>.</p>
<h3 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h3><p>step 1: 设置用户名和邮箱, 右键 -&gt; Git Bash Here:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub 用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub 邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>step 2: 创建ssh密钥, 输入命令<code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>. 进入 [C:\Users\用户名.ssh]目录, 找到”id_rsa.pub”右键-&gt;打开方式-&gt;记事本, 打开并复制里面内容.</p>
<p>step 3: 登录github, 点击头像-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key-&gt;将title命名为hexo,并将step 2复制的文本粘贴入key文本框中-&gt; Add SSH key.</p>
<p>step 4: Git Bash -&gt; 输入<code>ssh -T git@github.com</code> -&gt; 出现”Are you sure…”, 输入yes确认.</p>
<p>step 5: 点击github页面左上角logo进入主页 -&gt; Create a new repository -&gt; 见下图介绍:<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005194945.png" alt=""></p>
<p>step 6: 打开博客文件夹配置文件_config.yml, 在末尾加上:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/name/name.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是, name为你的github用户名, 且每个”:”与后接的值之间必须要有一个空格;</p>
<h3 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h3><p>这里博主选择使用Github+Picgo+Jsdelivr搭建图床.</p>
<p>Github配置:与上一步一样,新建Github repository, 设置库为Public, 但是名称可以任意设置;</p>
<p>Token获取: GitHub主页 -&gt; 右上角头像 -&gt; settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token -&gt; 填写note并点击Generate token -&gt; 复制token;</p>
<p>Picgo安装: 从<a href="https://molunerfinn.com/PicGo/">Picgo官网</a>直接下载对应版本安装即可;</p>
<p>Picgo配置: 打开Picgo -&gt; 图床设置 -&gt; GitHub图床, 参考配置如下;<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005221912.png" alt=""><br>仓库名设定: “用户名/仓库名”, 也即下图中红框部分:<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005222559.png" alt=""><br>将第二步获得的token粘贴到对应输入;<br>指定路径表示我们上传的图片存放于库中哪个目录下;</p>
<p>jsdelivr加速: 由于github在不<strong>科学上网</strong>的条件下不稳定, 且速度较慢(通过修改hosts文件或者使用代理能够解决), 使用cdn为github加速. 配置如下:<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005223408.png" alt=""><br>其他可用域名:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">CloudFlare:</span> <span class="string">test1.jsdelivr.net</span></span><br><span class="line"><span class="attr">CloudFlare:</span> <span class="string">testingcf.jsdelivr.net</span></span><br><span class="line"><span class="attr">Fastly:</span> <span class="string">fastly.jsdelivr.net</span></span><br></pre></td></tr></table></figure>
<p>替换图中gcore.jsdelivr.net即可;</p>
<h2 id="网站主题与信息配置"><a href="#网站主题与信息配置" class="headerlink" title="网站主题与信息配置"></a>网站主题与信息配置</h2><h3 id="站点信息配置"><a href="#站点信息配置" class="headerlink" title="站点信息配置"></a>站点信息配置</h3><p>个人信息配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Molaison&#x27;s</span> <span class="string">blogs</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;Per Aspera Ad Astra.&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">Bioinformatics</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Computational</span> <span class="string">Biology</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Machine</span> <span class="string">Learning</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Molaison</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>网址信息配置:</p>
<ul>
<li>url设置为你的Github库的网址, 即下图中红框部分;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005200237.png" alt=""></li>
<li>root节点设置为”/“, 2022/10/4日实测不设置该节点 or 设置为”/name.github.io/“ or “/name.github.io” 均会导致网站样式表无法加载, 呈现下图样式, 具体原因可能是js文件路径错误导致;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005200655.jpg" alt=""></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://github.com/Molaison/Molaison.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>打开目录”theme\next\”下的_config.yml文件, 主题配置主要在此文件中进行;</p>
<p>布局设置: next主题提供了四种布局,可依照需求选择,预览效果见<a href="https://github.com/theme-next/awesome-next#live-preview">awesome-next</a>给出的示例,即”Live Preview”下的链接;</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>菜单设置: menu下的键值对代表侧边栏中是否含有该标签,即下图红框部分(由于设置了语言,这里显示为中文,但并不是通过翻译实现,而是在next主题目录下的language文件夹中对应的yml配置文件中,使用键值对实现);<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/0520221005201849.png" alt=""><br>menu_settings中icons和badges分别表示是否显示图标和计数符号;</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>侧边栏设置:设置侧边栏位置;<br>头像设置: 根目录-&gt;theme-&gt;next-&gt;source-&gt;images-&gt;avatar.gif,调整图像大小,随后将其转成gif即可;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>文章目录设置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                                  <span class="comment"># 是否开启目录</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>                                  <span class="comment"># 自动增加列表数，比如`1.1 1.2 1.3`</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span>                                   <span class="comment"># 标题内容大于侧边栏宽，是否再下一行显示</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span>                             <span class="comment"># 是否自动扩展所有列表，而不是仅扩展当前二级标题下的列表</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>代码块主题设置: 更多可用主题可以查看<a href="https://theme-next.js.org/highlight/">next-highlight code</a>;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>problem solving</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习笔记</title>
    <url>/2021/02/05/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Tidyverse"><a href="#Tidyverse" class="headerlink" title="Tidyverse"></a>Tidyverse</h2><h3 id="dplyr包-数据转换"><a href="#dplyr包-数据转换" class="headerlink" title="dplyr包: 数据转换"></a>dplyr包: 数据转换</h3><h4 id="数据和包载入"><a href="#数据和包载入" class="headerlink" title="数据和包载入"></a>数据和包载入</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>nycflights13<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">nycflights13<span class="operator">::</span>flights</span><br></pre></td></tr></table></figure>
<h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><p>以下5个函数参数相同:</p>
<ol>
<li>第一个参数为数据框;</li>
<li>随后参数使用变量名称(不带引号)描述操作;</li>
<li>返回一个新的数据框;</li>
</ol>
<h5 id="filter-按值筛选"><a href="#filter-按值筛选" class="headerlink" title="filter(): 按值筛选"></a>filter(): 按值筛选</h5><p>基于筛选条件筛选出观测子集:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">==</span> x_1<span class="punctuation">,</span> colname_2 <span class="operator">==</span> x_2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#筛选出第一列中值为x_1,和第二列中值为x_2的行</span></span><br><span class="line"><span class="punctuation">(</span>subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">==</span> x_1<span class="punctuation">,</span> colname_2 <span class="operator">==</span> x_2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#在console中直接显示结果同时将值储存进subset</span></span><br></pre></td></tr></table></figure>
<h6 id="基于比较符"><a href="#基于比较符" class="headerlink" title="基于比较符"></a>基于比较符</h6><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">&gt;=</span> x_1<span class="punctuation">,</span> colname_2 <span class="operator">&lt;=</span> x_2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#比较运算符有: &gt;,&lt;,&lt;=,&gt;=,!=,==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于浮点数</span></span><br><span class="line"><span class="built_in">sqrt</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span> <span class="operator">==</span> <span class="number">2</span>  <span class="comment">#FALSE</span></span><br><span class="line"><span class="number">1</span><span class="operator">/</span><span class="number">49</span><span class="operator">*</span><span class="number">49</span> <span class="operator">==</span> <span class="number">1</span> <span class="comment">#FALSE</span></span><br><span class="line"><span class="comment">#通常使用near()函数</span></span><br><span class="line">near<span class="punctuation">(</span><span class="built_in">sqrt</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span>  <span class="comment">#TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于区间</span></span><br><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> between<span class="punctuation">(</span>colname_1<span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#选出位于区间(3,9)之间的colname值</span></span><br></pre></td></tr></table></figure>
<h6 id="基于逻辑符"><a href="#基于逻辑符" class="headerlink" title="基于逻辑符"></a>基于逻辑符</h6><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">&gt;=</span> x_1<span class="operator">|</span>colname_1 <span class="operator">&gt;=</span> x_3<span class="punctuation">)</span><span class="comment">#或</span></span><br><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">&gt;=</span> x_1<span class="operator">&amp;</span>colname_1 <span class="operator">&gt;=</span> x_3<span class="punctuation">)</span><span class="comment">#与</span></span><br><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> <span class="operator">!</span><span class="punctuation">(</span>colname_1 <span class="operator">&gt;=</span> x_1<span class="punctuation">)</span><span class="punctuation">)</span><span class="comment">#非</span></span><br><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span> colname_1 <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span>x_1<span class="punctuation">,</span>x_2<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h6 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h6><blockquote>
<p>缺失值 :  称为NA（Not available，不可用）</p>
</blockquote>
<p>对于缺失值的操作也都是缺失值（大多数情况）；</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="literal">NA</span> <span class="operator">==</span> <span class="literal">NA</span></span><br><span class="line"><span class="comment"># 值为NA</span></span><br><span class="line">x <span class="operator">=</span> <span class="literal">NA</span>;</span><br><span class="line"><span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#TRUE</span></span><br></pre></td></tr></table></figure>
<p>在筛选器中,为NA值得行和条件为FALSE的行会被过滤,如果需要保留;</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> filter<span class="punctuation">(</span>parentset<span class="punctuation">,</span><span class="built_in">is.na</span><span class="punctuation">(</span>colname_1<span class="punctuation">)</span><span class="operator">|</span>colname_1 <span class="operator">&gt;=</span> x_3<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>其他NA特殊操作的值:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="literal">NA</span><span class="operator">^</span><span class="number">0</span> <span class="comment">#=0</span></span><br><span class="line"><span class="literal">NA</span><span class="operator">|</span><span class="literal">TRUE</span> <span class="comment">#TRUE</span></span><br><span class="line"><span class="literal">NA</span><span class="operator">*</span><span class="number">0</span> <span class="comment">#=NA</span></span><br></pre></td></tr></table></figure>
<h5 id="arrange-对行排序"><a href="#arrange-对行排序" class="headerlink" title="arrange(): 对行排序"></a>arrange(): 对行排序</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> arrange<span class="punctuation">(</span>parentset<span class="punctuation">,</span> col_1<span class="punctuation">,</span> col_2<span class="punctuation">,</span> col_3<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#首先根据列1排序,再对列2排序,表示如果数据在“变量1”的值相同时按照“变量2”排序</span></span><br><span class="line">subset <span class="operator">&lt;-</span> arrange<span class="punctuation">(</span>parentset<span class="punctuation">,</span> desc<span class="punctuation">(</span>col_1<span class="punctuation">)</span><span class="punctuation">,</span> col_2<span class="punctuation">,</span> col_3<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#desc()函数使之降序排列,即descend</span></span><br><span class="line"><span class="comment">#缺失值无论降序还是升序,总是在最后</span></span><br></pre></td></tr></table></figure>
<h5 id="select-按名称选取"><a href="#select-按名称选取" class="headerlink" title="select(): 按名称选取"></a>select(): 按名称选取</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> select<span class="punctuation">(</span>parentset<span class="punctuation">,</span> col_1<span class="punctuation">,</span> col_2<span class="punctuation">,</span> col_3<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#选取第1,2,3列</span></span><br><span class="line">subset <span class="operator">&lt;-</span> select<span class="punctuation">(</span>parentset<span class="punctuation">,</span> col_1<span class="operator">:</span>col_3<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#也是选取1:3列</span></span><br><span class="line">subset <span class="operator">&lt;-</span> select<span class="punctuation">(</span>parentset<span class="punctuation">,</span> <span class="operator">-</span><span class="punctuation">(</span>col_1<span class="operator">:</span>col_3<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#选取不在1:3列间的列</span></span><br></pre></td></tr></table></figure>
<h6 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h6><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">starts_with<span class="punctuation">(</span>str<span class="punctuation">)</span><span class="operator">:</span> <span class="comment">#以str开头的名称</span></span><br><span class="line"></span><br><span class="line">end_with<span class="punctuation">(</span>str<span class="punctuation">)</span><span class="operator">:</span> <span class="comment">#以str结尾的名称</span></span><br><span class="line"></span><br><span class="line">contains<span class="punctuation">(</span>str<span class="punctuation">)</span><span class="operator">:</span><span class="comment">#包含str的名称</span></span><br><span class="line"></span><br><span class="line">matches<span class="punctuation">(</span>pattern<span class="punctuation">)</span><span class="operator">:</span><span class="comment">#匹配正则pattern的名称</span></span><br><span class="line"></span><br><span class="line">num_range<span class="punctuation">(</span><span class="string">&quot;X&quot;</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span><span class="operator">:</span><span class="comment">#匹配 &#123;X1, X2, X3, X4 &#125;,神技</span></span><br><span class="line"><span class="comment">#会默认忽略大小写,如果要区分大小写，可以设置任意帮助函数的参数ignore.case = FALSE</span></span><br></pre></td></tr></table></figure>
<p>select可以重命名变量,但是会丢失其他变量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> select<span class="punctuation">(</span>parentset<span class="punctuation">,</span> newname<span class="operator">=</span>oldname<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用select的变体可以保留其他变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rename<span class="punctuation">(</span>parentset<span class="punctuation">,</span> newname<span class="operator">=</span>oldname<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>也可以使用everything()函数进行列排序:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> select<span class="punctuation">(</span>parentset<span class="punctuation">,</span> col5<span class="punctuation">,</span>col3<span class="punctuation">,</span>everything<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#原顺序为1,2,3,4,5,现在为5,3,1,2,4</span></span><br></pre></td></tr></table></figure>
<p>one_of(character_1,···,character_n):如果某个列的名字出现在序列里，则选出它</p>
<h5 id="mutate-使用函数创建新变量"><a href="#mutate-使用函数创建新变量" class="headerlink" title="mutate(): 使用函数创建新变量"></a>mutate(): 使用函数创建新变量</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset <span class="operator">&lt;-</span> mutate<span class="punctuation">(</span>parentset<span class="punctuation">,</span> newcol1<span class="operator">=</span>col1<span class="operator">/</span>col2<span class="punctuation">,</span>newcol2<span class="operator">=</span>new1<span class="operator">/</span>col1<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码产生了两个新列, 总是加在数据框最后</li>
<li>新列按顺序产生, 列一经产生即可使用(new2使用了new1)</li>
<li>运算法则:<ul>
<li>加减乘除 “+”, “-”,”*”,”/”,”^”</li>
<li>模运算:”%/%”整除,”%%”求余</li>
<li>对数:log(),log2(),log10();</li>
<li>偏移函数:lead(),lag(),前移或者后移一位</li>
<li>累加,滚动聚合: 累加和,积,最小值,最大值:cumsum(), cumprod(), cummin(),cummax()</li>
</ul>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">transmute<span class="punctuation">(</span>parentset<span class="punctuation">,</span> newcol1<span class="operator">=</span>col1<span class="operator">/</span>col2<span class="punctuation">,</span>newcol2<span class="operator">=</span>new1<span class="operator">/</span>col1<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>只保留新的变量;</p>
<h5 id="summarize-摘要统计量"><a href="#summarize-摘要统计量" class="headerlink" title="summarize(): 摘要统计量"></a>summarize(): 摘要统计量</h5><p>summarize()，它可以将数据框折叠成一行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summarize<span class="punctuation">(</span>flights<span class="punctuation">,</span> delay <span class="operator">=</span> mean<span class="punctuation">(</span>dep_delay<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1 × 1</span></span><br><span class="line"><span class="comment">#&gt; delay</span></span><br><span class="line"><span class="comment">#&gt; &lt;dbl&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 12.6</span></span><br></pre></td></tr></table></figure>
<p>group_by() 可以将分析单位从整个数据集更改为单个分组.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">by_day <span class="operator">&lt;-</span> group_by<span class="punctuation">(</span>flights<span class="punctuation">,</span> year<span class="punctuation">,</span> month<span class="punctuation">,</span> day<span class="punctuation">)</span></span><br><span class="line">summarize<span class="punctuation">(</span>by_day<span class="punctuation">,</span> delay <span class="operator">=</span> mean<span class="punctuation">(</span>dep_delay<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Source: local data frame [365 x 4]</span></span><br><span class="line"><span class="comment">#&gt; Groups: year, month [?]</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="comment">#&gt; year month day delay</span></span><br><span class="line"><span class="comment">#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 2013 1 1 11.55</span></span><br><span class="line"><span class="comment">#&gt; 2 2013 1 2 13.86</span></span><br><span class="line"><span class="comment">#&gt; 3 2013 1 3 10.99</span></span><br><span class="line"><span class="comment">#&gt; 4 2013 1 4 8.95</span></span><br><span class="line"><span class="comment">#&gt; 5 2013 1 5 5.73</span></span><br><span class="line"><span class="comment">#&gt; 6 2013 1 6 7.15</span></span><br></pre></td></tr></table></figure>
<h5 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h5><p>即: “%&gt;%”, 将返回值传递给管道符后的操作函数作为输入,通常可读作然后:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">delays <span class="operator">&lt;-</span> flights <span class="operator">%&gt;%</span></span><br><span class="line"> group_by<span class="punctuation">(</span>dest<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line"> summarize<span class="punctuation">(</span></span><br><span class="line">  count <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  dist <span class="operator">=</span> mean<span class="punctuation">(</span>distance<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  delay <span class="operator">=</span> mean<span class="punctuation">(</span>arr_delay<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line"> filter<span class="punctuation">(</span>count <span class="operator">&gt;</span> <span class="number">20</span><span class="punctuation">,</span> dest <span class="operator">!=</span> <span class="string">&quot;HNL&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h5 id="缺失值忽略参数"><a href="#缺失值忽略参数" class="headerlink" title="缺失值忽略参数"></a>缺失值忽略参数</h5><p>na.rm=TRUE参数可以在计算前除去缺失值;</p>
<h5 id="计数参数"><a href="#计数参数" class="headerlink" title="计数参数"></a>计数参数</h5><p>即n(), 它的值是操作单位中值的个数;</p>
<h5 id="常见摘要函数"><a href="#常见摘要函数" class="headerlink" title="常见摘要函数"></a>常见摘要函数</h5><h6 id="位置-median-和mean"><a href="#位置-median-和mean" class="headerlink" title="位置: median()和mean()"></a>位置: median()和mean()</h6><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">not_cancelled <span class="operator">%&gt;%</span></span><br><span class="line">group_by<span class="punctuation">(</span>year<span class="punctuation">,</span> month<span class="punctuation">,</span> day<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">summarize<span class="punctuation">(</span></span><br><span class="line"><span class="comment"># 平均延误时间：</span></span><br><span class="line">avg_delay1 <span class="operator">=</span> mean<span class="punctuation">(</span>arr_delay<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment"># 50%的x大于它，同时50%的x小于它。</span></span><br><span class="line">avg_delay2 <span class="operator">=</span> median<span class="punctuation">(</span>arr_delay<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h6 id="分散程度-sd-x-、IQR-x-和mad-x"><a href="#分散程度-sd-x-、IQR-x-和mad-x" class="headerlink" title="分散程度: sd(x)、IQR(x) 和mad(x)"></a>分散程度: sd(x)、IQR(x) 和mad(x)</h6><p>分别是标准差, 四分位距, 绝对中位差;</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">not_cancelled <span class="operator">%&gt;%</span></span><br><span class="line">group_by<span class="punctuation">(</span>dest<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">summarize<span class="punctuation">(</span>distance_sd <span class="operator">=</span> sd<span class="punctuation">(</span>distance<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h6 id="秩-min-x-、quantile-x-0-25-和max-x"><a href="#秩-min-x-、quantile-x-0-25-和max-x" class="headerlink" title="秩: min(x)、quantile(x, 0.25) 和max(x)"></a>秩: min(x)、quantile(x, 0.25) 和max(x)</h6><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">not_cancelled <span class="operator">%&gt;%</span></span><br><span class="line">group_by<span class="punctuation">(</span>year<span class="punctuation">,</span> month<span class="punctuation">,</span> day<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">summarize<span class="punctuation">(</span></span><br><span class="line">first <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">(</span>dep_time<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">last <span class="operator">=</span> <span class="built_in">max</span><span class="punctuation">(</span>dep_time<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h6 id="定位度量：first-x-、nth-x-2-和last-x"><a href="#定位度量：first-x-、nth-x-2-和last-x" class="headerlink" title="定位度量：first(x)、nth(x, 2) 和last(x)"></a>定位度量：first(x)、nth(x, 2) 和last(x)</h6><p>和索引取值的区别在于,当定位不存在时取默认值位置;</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">not_cancelled <span class="operator">%&gt;%</span></span><br><span class="line">group_by<span class="punctuation">(</span>year<span class="punctuation">,</span> month<span class="punctuation">,</span> day<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">summarize<span class="punctuation">(</span></span><br><span class="line">first_dep <span class="operator">=</span> first<span class="punctuation">(</span>dep_time<span class="punctuation">)</span><span class="punctuation">,</span>last_dep <span class="operator">=</span> last<span class="punctuation">(</span>dep_time<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h6 id="计数-count"><a href="#计数-count" class="headerlink" title="计数:count()"></a>计数:count()</h6><p>唯一值计数:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n_distinct<span class="punctuation">(</span><span class="punctuation">)</span>;</span><br></pre></td></tr></table></figure>
<p>加权计数:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">count<span class="punctuation">(</span>df <span class="punctuation">,</span> wt<span class="operator">=</span> weight<span class="punctuation">)</span><span class="comment">#weight可以是其他列或者别的权重</span></span><br></pre></td></tr></table></figure>
<h6 id="逻辑值计数-sum-x-gt-a-和mean-x-0"><a href="#逻辑值计数-sum-x-gt-a-和mean-x-0" class="headerlink" title="逻辑值计数: sum(x&gt;a)和mean(x==0)"></a>逻辑值计数: sum(x&gt;a)和mean(x==0)</h6><p>sum()使用逻辑表达式计数可以计算true值的个数;</p>
<p>而mean则可以直接获得比例,因为true值为1,FALSE为0;</p>
<h5 id="按多个变量分组"><a href="#按多个变量分组" class="headerlink" title="按多个变量分组"></a>按多个变量分组</h5><p>当使用多个变量进行分组时，每次的摘要统计会==用掉一个分组变量==。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">daily <span class="operator">&lt;-</span> group_by<span class="punctuation">(</span>flights<span class="punctuation">,</span> year<span class="punctuation">,</span> month<span class="punctuation">,</span> day<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">(</span>per_day <span class="operator">&lt;-</span> summarize<span class="punctuation">(</span>daily<span class="punctuation">,</span> flights <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Source: local data frame [365 x 4]</span></span><br><span class="line"><span class="comment">#&gt; Groups: year, month [?]</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="comment">#&gt; year month day flights</span></span><br><span class="line"><span class="comment">#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 2013 1 1 842</span></span><br><span class="line"><span class="comment">#&gt; 2 2013 1 2 943</span></span><br><span class="line"><span class="comment">#&gt; 3 2013 1 3 914</span></span><br><span class="line"><span class="comment">#&gt; 4 2013 1 4 915</span></span><br><span class="line"><span class="comment">#&gt; 5 2013 1 5 720</span></span><br><span class="line"><span class="comment">#&gt; 6 2013 1 6 832</span></span><br><span class="line"><span class="comment">#&gt; # ... with 359 more rows</span></span><br><span class="line"><span class="punctuation">(</span>per_month <span class="operator">&lt;-</span> summarize<span class="punctuation">(</span>per_day<span class="punctuation">,</span> flights <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>flights<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Source: local data frame [12 x 3]</span></span><br><span class="line"><span class="comment">#&gt; Groups: year [?]</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="comment">#&gt; year month flights</span></span><br><span class="line"><span class="comment">#&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 2013 1 27004</span></span><br><span class="line"><span class="comment">#&gt; 2 2013 2 24951</span></span><br><span class="line"><span class="comment">#&gt; 3 2013 3 28834</span></span><br><span class="line"><span class="comment">#&gt; 4 2013 4 28330</span></span><br><span class="line"><span class="comment">#&gt; 5 2013 5 28796</span></span><br><span class="line"><span class="punctuation">(</span>per_year <span class="operator">&lt;-</span> summarize<span class="punctuation">(</span>per_month<span class="punctuation">,</span> flights <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>flights<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1 × 2</span></span><br><span class="line"><span class="comment">#&gt; year flights</span></span><br><span class="line"><span class="comment">#&gt; &lt;int&gt; &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 2013 336776</span></span><br></pre></td></tr></table></figure>
<ol>
<li>但是取加权平均或者方差或者中位数时,很容易出错,因为对整体取中位数和分组取中位数在取中位数完全不同;</li>
<li>可以用ungroup()取消分组</li>
</ol>
<h3 id="tibble数据框"><a href="#tibble数据框" class="headerlink" title="tibble数据框"></a>tibble数据框</h3><h4 id="创建tibble数据框"><a href="#创建tibble数据框" class="headerlink" title="创建tibble数据框"></a>创建tibble数据框</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">as_tibble<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="comment">#从普通数据框转换</span></span><br><span class="line"></span><br><span class="line">tibble<span class="punctuation">(</span>x<span class="operator">=</span>vector<span class="punctuation">,</span>y<span class="operator">=</span>vector<span class="punctuation">,</span>z<span class="operator">=</span>vector<span class="punctuation">)</span><span class="comment">#直接创建</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tibble相比较data.frame: 不能改变输入的类型（例如，不能将字符串转换为因子）、变量的名称，也不能创建行名称。</li>
<li>可以在tibble 中使用在R 中无效的变量名称（即不符合语法的名称)作为列名,需要使用反引号` 将它们括起来</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tb <span class="operator">&lt;-</span> tibble<span class="punctuation">(</span></span><br><span class="line">`:)` <span class="operator">=</span> <span class="string">&quot;smile&quot;</span><span class="punctuation">,</span></span><br><span class="line">` ` <span class="operator">=</span> <span class="string">&quot;space&quot;</span><span class="punctuation">,</span></span><br><span class="line">`<span class="number">2000</span>` = &quot;number&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>transposed tibble: 列标题由公式（以~ 开头）<br>定义，数据条目以逗号分隔，对少量数据进行布局</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tribble<span class="punctuation">(</span></span><br><span class="line">    <span class="operator">~</span>x<span class="punctuation">,</span> <span class="operator">~</span>y<span class="punctuation">,</span> <span class="operator">~</span>z<span class="punctuation">,</span></span><br><span class="line">    <span class="comment">#--|--|----</span></span><br><span class="line">    <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3.6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">8.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 2 × 3</span></span><br><span class="line"><span class="comment">#&gt; x y z</span></span><br><span class="line"><span class="comment">#&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 a 2 3.6</span></span><br><span class="line"><span class="comment">#&gt; 2 b 1 8.5</span></span><br></pre></td></tr></table></figure>
<h5 id="打印tibble"><a href="#打印tibble" class="headerlink" title="打印tibble()"></a>打印tibble()</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tibble<span class="punctuation">(</span></span><br><span class="line">a <span class="operator">=</span> lubridate<span class="operator">::</span>now<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> runif<span class="punctuation">(</span><span class="number">1e3</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">86400</span><span class="punctuation">,</span></span><br><span class="line">b <span class="operator">=</span> lubridate<span class="operator">::</span>today<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> runif<span class="punctuation">(</span><span class="number">1e3</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line"><span class="built_in">c</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">1e3</span><span class="punctuation">,</span></span><br><span class="line">d <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">1e3</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">e <span class="operator">=</span> sample<span class="punctuation">(</span><span class="built_in">letters</span><span class="punctuation">,</span> <span class="number">1e3</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1,000 × 5</span></span><br><span class="line"><span class="comment">#&gt; a b c d e</span></span><br><span class="line"><span class="comment">#&gt; &lt;dttm&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 2016-10-10 17:14:14 2016-10-17 1 0.368 h</span></span><br><span class="line"><span class="comment">#&gt; 2 2016-10-11 11:19:24 2016-10-22 2 0.612 n</span></span><br><span class="line"><span class="comment">#&gt; 3 2016-10-11 05:43:03 2016-11-01 3 0.415 l</span></span><br><span class="line"><span class="comment">#&gt; 4 2016-10-10 19:04:20 2016-10-31 4 0.212 x</span></span><br><span class="line"><span class="comment">#&gt; 5 2016-10-10 15:28:37 2016-10-28 5 0.733 a</span></span><br><span class="line"><span class="comment">#&gt; 6 2016-10-11 02:29:34 2016-10-24 6 0.460 v</span></span><br><span class="line"><span class="comment">#&gt; # ... with 994 more rows</span></span><br><span class="line">nycflights13<span class="operator">::</span>flights <span class="operator">%&gt;%</span></span><br><span class="line"> print<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="literal">Inf</span><span class="punctuation">)</span><span class="comment">#width显示宽度,n为行数</span></span><br><span class="line"><span class="comment">#可通过设置选项(option)控制默认打印方式</span></span><br><span class="line">options<span class="punctuation">(</span>tibble.print_max <span class="operator">=</span> n<span class="punctuation">,</span> tibble.print_min <span class="operator">=</span> m<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h5 id="取子集"><a href="#取子集" class="headerlink" title="取子集"></a>取子集</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> tibble<span class="punctuation">(</span></span><br><span class="line">    x <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    y <span class="operator">=</span> rnorm<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">)</span></span><br><span class="line">df<span class="operator">$</span>x <span class="comment">#$只能通过名字提取</span></span><br><span class="line">df<span class="punctuation">[[</span><span class="string">&quot;x&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">df<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="comment"># 双中括号既可以按名称也可以按位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与管道符结合</span></span><br><span class="line">df <span class="operator">%&gt;%</span> .<span class="operator">$</span>x <span class="comment">#.为占位符,功能如其名</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span></span><br><span class="line">df <span class="operator">%&gt;%</span> .<span class="punctuation">[[</span><span class="string">&quot;x&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span></span><br></pre></td></tr></table></figure>
<h3 id="readr"><a href="#readr" class="headerlink" title="readr"></a>readr</h3><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><ul>
<li>csv文件: read_csv()读取逗号分隔文件、read_csv2() 读取分号分隔文件（这在用, 表示小数位的国家非常普遍）、read_tsv() 读取制表符分隔文件、read_delim() 可以读取使用任意分隔符的文件。</li>
<li>read_fwf() 读取固定宽度的文件。既可以使用fwf_widths() 函数按照宽度来设定域，也可以使用fwf_positions() 函数按照位置来设定域。read_table() 读取固定宽度文件的一种常用变体，其中使用空白字符来分隔各列。</li>
</ul>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>direction: 绝对or相对路径</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">heights <span class="operator">&lt;-</span> read_csv<span class="punctuation">(</span><span class="string">&quot;data/heights.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">read_csv<span class="punctuation">(</span><span class="string">&quot;a,b,c</span></span><br><span class="line"><span class="string">1,2,3</span></span><br><span class="line"><span class="string">4,5,6&quot;</span><span class="punctuation">)</span><span class="comment">#也可以读取行内CSV文件,换行不能省!</span></span><br></pre></td></tr></table></figure>
<p>skip = n:跳过前N行:</p>
<p>comment = char: 丢弃所有以char开头的行,即将其注释掉</p>
<p>col_names = FALSE: 不使用数据的第一行作为列名称(默认为TRUE. 标注为X1 X2 X3 ….;或者使用向量为其命名;</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">read_csv<span class="punctuation">(</span><span class="string">&quot;1,2,3\n4,5,6&quot;</span><span class="punctuation">,</span> col_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;z&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h4 id="解析向量"><a href="#解析向量" class="headerlink" title="解析向量"></a>解析向量</h4><ul>
<li>parse_*() 函数族: 接受一个字符向量，并返回一个特定向量，如逻辑、整数或日期向量：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_integer<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;231&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> <span class="string">&quot;456&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> na <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">)</span><span class="comment">#&quot;na=&quot;哪些字符串应该当作缺失值来处理</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>解析失败的值在输出中是以缺失值的形式存在的</p>
</li>
<li><p>problems() 函数来获取完整的失败信息集合(tibble)</p>
</li>
<li><p>parse_double()解析浮点数,，parse_number() 则是灵活的数值型解析函数。</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_double<span class="punctuation">(</span><span class="string">&quot;1,23&quot;</span><span class="punctuation">,</span> locale <span class="operator">=</span> locale<span class="punctuation">(</span>decimal_mark <span class="operator">=</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="comment">#“地区&quot;根据地区设置解析选项</span></span><br><span class="line">parse_number<span class="punctuation">(</span></span><br><span class="line"><span class="string">&quot;123.456.789&quot;</span><span class="punctuation">,</span></span><br><span class="line">locale <span class="operator">=</span> locale<span class="punctuation">(</span>grouping_mark <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#parse_number()忽略数值前后的非数值型字符</span></span><br><span class="line">parse_number<span class="punctuation">(</span><span class="string">&quot;$100&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 100</span></span><br><span class="line">parse_number<span class="punctuation">(</span><span class="string">&quot;20%&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 20</span></span><br><span class="line">parse_number<span class="punctuation">(</span><span class="string">&quot;It cost $123.45&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 123</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>parse_character():</p>
<ul>
<li><p>charToRaw()获得字符串ASCII编码</p>
</li>
<li><p>设定编码方式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_character<span class="punctuation">(</span>x1<span class="punctuation">,</span> locale <span class="operator">=</span> locale<span class="punctuation">(</span>encoding <span class="operator">=</span> <span class="string">&quot;Latin1&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;El Niño was particularly bad this year&quot;</span></span><br><span class="line">parse_character<span class="punctuation">(</span>x2<span class="punctuation">,</span> locale <span class="operator">=</span> locale<span class="punctuation">(</span>encoding <span class="operator">=</span> <span class="string">&quot;Shift-JIS&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;こんにちは&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>未知编码方式:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">guess_encoding<span class="punctuation">(</span>charToRaw<span class="punctuation">(</span>x1<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; encoding confidence</span></span><br><span class="line"><span class="comment">#&gt; 1 ISO-8859-1 0.46</span></span><br><span class="line"><span class="comment">#&gt; 2 ISO-8859-9 0.23</span></span><br><span class="line">guess_encoding<span class="punctuation">(</span>charToRaw<span class="punctuation">(</span>x2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; encoding confidence</span></span><br><span class="line"><span class="comment">#&gt; 1 KOI8-R 0.42</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>parse_factor(): R 使用因子表示取值范围是已知集合的分类变量。</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fruit <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;apple&quot;</span><span class="punctuation">,</span> <span class="string">&quot;banana&quot;</span><span class="punctuation">)</span></span><br><span class="line">parse_factor<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;apple&quot;</span><span class="punctuation">,</span> <span class="string">&quot;banana&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bananana&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> levels <span class="operator">=</span> fruit<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning: 1 parsing failure.</span></span><br><span class="line"><span class="comment">#&gt; row col expected actual</span></span><br><span class="line"><span class="comment">#&gt; 3 -- value in level set bananana</span></span><br><span class="line"><span class="comment">#&gt; [1] apple banana &lt;NA&gt;</span></span><br><span class="line"><span class="comment">#&gt; attr(,&quot;problems&quot;)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1 × 4</span></span><br><span class="line"><span class="comment">#&gt; row col expected actual</span></span><br><span class="line"><span class="comment">#&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 3 NA value in level set bananana</span></span><br><span class="line"><span class="comment">#&gt; Levels: apple banana</span></span><br><span class="line"><span class="comment">#存在向量中没有的值，生成一条警告</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间解析:</p>
<ul>
<li><p>parse_datetime():</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_datetime<span class="punctuation">(</span><span class="string">&quot;2010-10-01T2010&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;2010-10-01 20:10:00 UTC&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parse_date():</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_date<span class="punctuation">(</span><span class="string">&quot;2010-10-01&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;2010-10-01&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parse_time():</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>hms<span class="punctuation">)</span></span><br><span class="line">parse_time<span class="punctuation">(</span><span class="string">&quot;20:10:01&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 20:10:01</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义格式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">parse_date<span class="punctuation">(</span><span class="string">&quot;01/02/15&quot;</span><span class="punctuation">,</span> <span class="string">&quot;%m/%d/%y&quot;</span><span class="punctuation">)</span></span><br><span class="line">年</span><br><span class="line"><span class="comment">#%Y（4 位数）。</span></span><br><span class="line"><span class="comment">#%y（2 位数；00-69 → 2000-2069、70-99 → 1970-1999）。</span></span><br><span class="line">月</span><br><span class="line"><span class="comment">#%m（2 位数）。</span></span><br><span class="line"><span class="comment">#%b（简写名称，如Jan）。</span></span><br><span class="line"><span class="comment">#%B（完整名称，如January）。</span></span><br><span class="line">日</span><br><span class="line"><span class="comment">#%d（1 位或2 位数）。</span></span><br><span class="line"><span class="comment">#%e（2 位数）</span></span><br><span class="line">时间</span><br><span class="line"><span class="comment">#%H（0-23 小时）。</span></span><br><span class="line"><span class="comment">#%I（0-12 小时，必须和%p 一起使用）。</span></span><br><span class="line"><span class="comment">#%p（表示a.m./p.m.）。</span></span><br><span class="line"><span class="comment">#%M（分钟）。</span></span><br><span class="line"><span class="comment">#%S（整数秒）。</span></span><br><span class="line"><span class="comment">#%OS（实数秒）。</span></span><br><span class="line"><span class="comment">#%Z（时区，America/Chicage 这样的名称）。注意，要当心缩写。如果你是美国人，注意</span></span><br><span class="line"><span class="comment">#EST 是加拿大没有夏时制的一个时区。它表#示东部标准时间！我们还会在12.5 节中继</span></span><br><span class="line"><span class="comment">#续讨论这个话题。</span></span><br><span class="line"><span class="comment">#%z（与国际标准时间的时差，如+0800）。</span></span><br><span class="line"><span class="comment">#非数值字符</span></span><br><span class="line"><span class="comment">#%.（跳过一个非数值字符）。</span></span><br><span class="line"><span class="comment">#%*（跳过所有非数值字符）。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h4><h2 id="ggplot2"><a href="#ggplot2" class="headerlink" title="ggplot2"></a>ggplot2</h2><h3 id="基础图画绘制"><a href="#基础图画绘制" class="headerlink" title="基础图画绘制"></a>基础图画绘制</h3><h4 id="数据（Data）和映射（Mapping）"><a href="#数据（Data）和映射（Mapping）" class="headerlink" title="数据（Data）和映射（Mapping）"></a>数据（Data）和映射（Mapping）</h4><h5 id="数据要求"><a href="#数据要求" class="headerlink" title="数据要求"></a>数据要求</h5><p>用于绘制图形的data frame或者tibble.</p>
<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p><strong>aes()</strong>函数是ggplot2中的映射函数, 所谓的映射即为数据集中的数据关联到相应的图形属性过程中一种对应关系, 图形的颜色，形状，分组等都可以通过通过数据集中的变量映射。</p>
<hr>
<p>将钻石数据集中克拉和价格映射为X,Y轴变量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data <span class="operator">=</span> diamond<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> carat<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>#将钻石的颜色（color）映射<strong>颜色</strong>属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>diamond<span class="punctuation">,</span> mapping<span class="operator">=</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>carat<span class="punctuation">,</span> y<span class="operator">=</span>price<span class="punctuation">,</span> shape<span class="operator">=</span>cut<span class="punctuation">,</span> colour<span class="operator">=</span>color<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p<span class="operator">+</span>geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#绘制点图</span></span><br></pre></td></tr></table></figure>
<p>#将钻石的切工（cut）映射到<strong>形状</strong>属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>diamond<span class="punctuation">,</span> mapping<span class="operator">=</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>carat<span class="punctuation">,</span> y<span class="operator">=</span>price<span class="punctuation">,</span> shape<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p<span class="operator">+</span>geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#绘制点图</span></span><br></pre></td></tr></table></figure>
<p>#将钻石的切工（cut）映射到<strong>分组</strong>属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认分组设置, 即group=1p + geom_boxplot()</span></span><br><span class="line"><span class="comment">#分组(group)也是ggplot2种映射关系的一种, 如果需要把观测点按额外的离散变量进行分组处理, 必须修改默认的分组设置。</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>diamond<span class="punctuation">,</span> mapping<span class="operator">=</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>carat<span class="punctuation">,</span> y<span class="operator">=</span>price<span class="punctuation">,</span> group<span class="operator">=</span>factor<span class="punctuation">(</span>cut<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">+</span> geom_boxplot<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h4 id="几何对象（Geometric）"><a href="#几何对象（Geometric）" class="headerlink" title="几何对象（Geometric）"></a>几何对象（Geometric）</h4><h5 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h5><p><strong>单变量连续变量</strong>：可绘制直方图展示，提供一个连续变量，画出数据的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>diamond<span class="punctuation">)</span><span class="operator">+</span>geom_histogram<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>price<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#以价格（price）变量为例，且按照不同的切工填充颜色(即一个直方内有不同颜色的切工块)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>diamond<span class="punctuation">)</span><span class="operator">+</span>geom_histogram<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>price<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">,</span> position<span class="operator">=</span><span class="string">&quot;dodge&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#dodge选项使得原本纵向分布的&quot;切工&quot;块变为并列显示</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>diamond<span class="punctuation">)</span><span class="operator">+</span>geom_histogram<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>price<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">,</span> position<span class="operator">=</span><span class="string">&quot;fill&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#设置使用position=&quot;fill&quot;，按相对比例画直方图,可以显示不同价格时,各切工所占比例</span></span><br></pre></td></tr></table></figure>
<h5 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h5><p><strong>单变量分类变量</strong>：可使用柱状图展示，提供一个x分类变量，画出数据的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>diamond<span class="punctuation">)</span><span class="operator">+</span>geom_bar<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>clarity<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#以透明度（clarity）变量为分类，且按照不同的切工填充颜色</span></span><br><span class="line"><span class="comment">#ggplot自动计算分类数</span></span><br></pre></td></tr></table></figure>
<h5 id="箱式图"><a href="#箱式图" class="headerlink" title="箱式图"></a>箱式图</h5><p><strong>箱线图</strong>:  通过绘制观测数据的五数总括，即最小值、下四分位数、中位数、上四分位数以及最大值，描述了变量值的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>diamond<span class="punctuation">)</span><span class="operator">+</span>geom_boxplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span>cut<span class="punctuation">,</span> y<span class="operator">=</span>price<span class="punctuation">,</span>fill<span class="operator">=</span>color<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#按切工(cut)分类，对价格(price)变量画箱式图，再按照color变量分别填充颜色。</span></span><br></pre></td></tr></table></figure>
<h4 id="标尺（Scale）"><a href="#标尺（Scale）" class="headerlink" title="标尺（Scale）"></a>标尺（Scale）</h4><p>在对图形属性进行映射之后，使用<strong>标尺</strong>可以控制这些属性的显示方式，比如坐标刻度，颜色属性等。</p>
<p><strong>scale函数命名通式</strong>: 一般使用三个单词用”_”连接:</p>
<ol>
<li>第一个都是scale</li>
<li>第二个是color fill x y linetype shape size等可更改的参数</li>
<li>第三个是具体的类型.</li>
</ol>
<h5 id="颜色标尺"><a href="#颜色标尺" class="headerlink" title="颜色标尺"></a>颜色标尺</h5><h6 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h6><p>对于颜色scale函数,第二个有两个参数, 一个是fill,主要是指填充颜色;另一个是color,指点或者线的颜色;</p>
<h6 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h6><p>根据数据为离散型还是连续性决定;</p>
<p>1）离散型：在颜色变量是离散变量的时候使用，比如分类时每一类对应一种颜色</p>
<ul>
<li>manual 直接指定分组使用的颜色</li>
<li>hue 通过改变色相（hue）饱和度（chroma）亮度（luminosity）来调整颜色</li>
<li>brewer 使用ColorBrewer的颜色</li>
<li>grey 使用不同程度的灰色</li>
</ul>
<p><strong>manual</strong> 参数:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p<span class="operator">+</span>scale_fill_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span><span class="string">&quot;green&quot;</span><span class="punctuation">,</span><span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span><span class="string">&quot;orange&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p<span class="operator">+</span>scale_fill_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Fair&quot;</span><span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span><span class="string">&quot;Good&quot;</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Very Good&quot;</span> <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span> Premium <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> Ideal <span class="operator">=</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_fill_manual<span class="punctuation">(</span><span class="string">&quot;class&quot;</span><span class="punctuation">,</span> values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span><span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span><span class="string">&quot;orange&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Fair&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Good&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Very Good&quot;</span><span class="punctuation">,</span><span class="string">&quot;Premium&quot;</span><span class="punctuation">,</span><span class="string">&quot;Ideal&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;一般&quot;</span><span class="punctuation">,</span> <span class="string">&quot;好&quot;</span><span class="punctuation">,</span> <span class="string">&quot;很好&quot;</span><span class="punctuation">,</span> <span class="string">&quot;高级&quot;</span><span class="punctuation">,</span> <span class="string">&quot;理想&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>brewer 使用ColorBrewer的颜色</strong>:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>RColorBrewer<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#主要是palette参数调用色板</span></span><br><span class="line">p <span class="operator">+</span> scale_fill_brewer<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># 默认使用Blues调色板中的颜色</span></span><br><span class="line">p <span class="operator">+</span> scale_fill_brewer<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;Greens&quot;</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment">#使用Greens调色板中的颜色</span></span><br><span class="line">p <span class="operator">+</span> scale_fill_brewer<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;Greens&quot;</span><span class="punctuation">,</span>direction <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>direction参数决定颜色顺序, 为-1则反着来;</p>
<p><strong>grey 使用不同程度的灰色</strong>:</p>
<p>通过start end 两个参数指定，0为黑，1为白，都在0-1范围内</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">+</span> scale_fill_grey<span class="punctuation">(</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="comment">#设定灰度范围</span></span><br><span class="line">p <span class="operator">+</span> scale_fill_grey<span class="punctuation">(</span>start<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span> end<span class="operator">=</span><span class="number">0</span><span class="punctuation">)</span>  </span><br><span class="line">p <span class="operator">+</span> scale_fill_grey<span class="punctuation">(</span>start<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span> end<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>2）连续型：颜色变量是连续变量的时候使用，比如0-100的数，数值越大颜色越深这样</p>
<ul>
<li>gradient 创建渐变色</li>
<li>distiller 使用ColorBrewer的颜色</li>
<li>identity 使用color变量对应的颜色，对离散型和连续型都有效</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>x <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span>y <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span>z1 <span class="operator">=</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>df<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>colour <span class="operator">=</span> z1<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>gradient 创建渐变色</strong>#参数设定节点颜色:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置两端颜色p + scale_color_gradient(low = &quot;white&quot;, high = &quot;black&quot;)</span></span><br><span class="line"><span class="comment">#设置中间过渡色</span></span><br><span class="line">p <span class="operator">+</span> scale_color_gradient2<span class="punctuation">(</span>low <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> mid <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> high <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#使用R预设调色板</span></span><br><span class="line">p <span class="operator">+</span> scale_color_gradientn<span class="punctuation">(</span>colours <span class="operator">=</span>rainbow<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#legeng展示指定标签</span></span><br><span class="line">p <span class="operator">+</span> scale_color_gradient<span class="punctuation">(</span>low <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> high <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>                             breaks<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span>  labels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span><span class="string">&quot;b&quot;</span><span class="punctuation">,</span><span class="string">&quot;c&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#legend名称</span></span><br><span class="line">p <span class="operator">+</span> scale_color_gradient<span class="punctuation">(</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span> low <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> high <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>       limits<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>distiller 使用ColorBrewer的颜色</strong>:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">+</span> scale_color_distiller<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;Spectral&quot;</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_color_distiller<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;Greens&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h5 id="坐标轴尺度修改"><a href="#坐标轴尺度修改" class="headerlink" title="坐标轴尺度修改"></a>坐标轴尺度修改</h5><p>参数与上类似,第一个参数为scale, 然后是x,y表明对哪个轴操作,最后是详细操作;</p>
<ul>
<li>更改坐标轴名称</li>
<li>更改x轴上标数的位置和内容</li>
<li>显示对一个轴做统计变换</li>
<li>只展示一个区域内的点</li>
<li>更改刻度标签的位置</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 横坐标是离散变量，纵坐标是连续变量</span></span><br><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>mtcars<span class="punctuation">,</span> aes<span class="punctuation">(</span>factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">,</span> mpg<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 更改坐标轴名称</span></span><br><span class="line">p <span class="operator">+</span> scale_x_discrete<span class="punctuation">(</span><span class="string">&quot;cyl&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 更改横轴标度</span></span><br><span class="line">p <span class="operator">+</span> scale_x_discrete<span class="punctuation">(</span>labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;4&quot;</span><span class="operator">=</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span><span class="string">&quot;6&quot;</span><span class="operator">=</span><span class="string">&quot;b&quot;</span><span class="punctuation">,</span><span class="string">&quot;8&quot;</span><span class="operator">=</span><span class="string">&quot;c&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 指定横轴顺序以及展示部分</span></span><br><span class="line">p <span class="operator">+</span> scale_x_discrete<span class="punctuation">(</span>limits<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;6&quot;</span><span class="punctuation">,</span><span class="string">&quot;4&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连续变量可以更改标度（图与上相似，略）</span></span><br><span class="line">p <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span><span class="string">&quot;ylab_mpg&quot;</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="number">30</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="number">30</span><span class="punctuation">)</span><span class="punctuation">,</span> labels<span class="operator">=</span>scales<span class="operator">::</span>dollar<span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">30</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 连续变量可以更改标度，还可以进行统计变换</span></span><br><span class="line">p <span class="operator">+</span> scale_y_reverse<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># 纵坐标翻转，小数在上面，大数在下面</span></span><br><span class="line">p <span class="operator">+</span> scale_y_log10<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>trans <span class="operator">=</span> <span class="string">&quot;log10&quot;</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> scale_y_sqrt<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 更改刻度标签的位置</span></span><br><span class="line">p <span class="operator">+</span> scale_x_discrete<span class="punctuation">(</span>position <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span> <span class="operator">+</span>  scale_y_continuous<span class="punctuation">(</span>position <span class="operator">=</span> <span class="string">&quot;right&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>data analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>再读GeneXII: The insight of biology</title>
    <url>/2023/06/14/%E5%86%8D%E8%AF%BBGeneXII-The-insight-of-biology/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>biology</tag>
      </tags>
  </entry>
  <entry>
    <title>基因工程学习笔记</title>
    <url>/2022/10/14/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><ul>
<li><p>Basic steps in gene cloning</p>
<ul>
<li>将DNA片段插入载体;</li>
<li>导入宿主细胞</li>
<li>recombinant molecule 复制</li>
<li>宿主细胞分裂</li>
<li>plating产生clony</li>
</ul>
</li>
<li><p>basic steps in PCR:特异引物识别DNA片段从而使其被复制从而富集</p>
<ul>
<li>94°C 氢键断开, 双链分开</li>
<li>50-60°C, DNA与引物杂交, 退火</li>
<li>74°C, Taq DNA polymerase(抗高温), 引物5’-&gt;3’复制</li>
<li>94°C下一轮循环</li>
</ul>
</li>
<li>Limitation of PCR:<ul>
<li>必须知道退火位点,也即知道引物结合地方序列;</li>
<li>长度限制: <strong>5kb-40kb</strong>(特殊技术可以最高复制40kb)</li>
</ul>
</li>
<li>usage: <ul>
<li>virus dectation: 高倍扩增</li>
<li>purifying gene</li>
</ul>
</li>
</ul>
<h3 id="载体"><a href="#载体" class="headerlink" title="载体"></a>载体</h3><h4 id="Plasmid"><a href="#Plasmid" class="headerlink" title="Plasmid"></a>Plasmid</h4><ul>
<li>载体要求:<ul>
<li>能够在宿主体内复制: 含有复制起点</li>
<li>理想大小小于10kb,大了会断开,而且不易于操作;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1420221014110645.png" alt=""></li>
</ul>
</li>
<li>宿主细胞:大肠杆菌, <strong>一次只接受一个质粒拷贝</strong>;</li>
<li>类型I: plasmids,<ul>
<li>环形分子</li>
<li>独立于基因组</li>
<li>携带一个或多个基因<ul>
<li>携带抗体基因可作为选择性标签,四环素和青霉素抗性基因;</li>
</ul>
</li>
</ul>
</li>
<li>质粒复制方式:<ul>
<li>integrative:插入宿主基因组复制</li>
<li>non-integrative:含有复制起始位点，独立复制,也称为episome;</li>
</ul>
</li>
<li>copy number: 宿主体内独立存在的质粒分子数；<ul>
<li>stringent:少但是大, 1-2/cell</li>
<li>relaxed:多, over 50/cell</li>
</ul>
</li>
<li>conjugation:<ul>
<li>物理接触</li>
<li>产生pilus(管道?)</li>
<li>宿主DNA滚环复制并转移到受体中</li>
<li>conjugative&amp;non-conjugative:产生pilus or not;<ul>
<li>由于conjugative plasmid 会传播至其他细胞;</li>
<li><strong>tra基因控制</strong>(含有则conjugative)</li>
</ul>
</li>
<li>compatibility:是否两质粒能共存;<ul>
<li>incompatiblity:在复制过程中两个子代细胞分别获得一个</li>
</ul>
</li>
</ul>
</li>
<li>F plasmid/F factor: 含有tra基因,conjugative;</li>
</ul>
<h4 id="Bacteriophage-Phage"><a href="#Bacteriophage-Phage" class="headerlink" title="Bacteriophage(Phage)"></a>Bacteriophage(Phage)</h4><ul>
<li>噬菌体特征:<ul>
<li>侵染细菌</li>
<li>结构简单</li>
<li>含有DNA|RNA:编码复制的基因</li>
<li>Capsid:外衣</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>类型I:λ phage<ul>
<li>episome</li>
<li>环状和线性DNA之间切换(cos位点)</li>
<li>基因成簇排列</li>
<li>裂解型</li>
<li>感染时间小于20min</li>
<li>基因组大小49kb</li>
</ul>
</li>
<li>prophage:整合进基因组的噬菌体DNA;</li>
<li>lysogen:携带prophage的宿主;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1420221014111709.png" alt=""><ul>
<li>编码capsid的基因成簇排列</li>
<li>便于控制基因组表达</li>
<li>b2 region: 可以删掉以增加能放进capsid的<strong>外源DNA长度</strong></li>
</ul>
</li>
<li>cos site:sticky end<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1420221014112239.png" alt=""></li>
<li>线性的DNA分子通过两cos位点环化，从宿主基因组脱离</li>
<li>内切酶识别序列，能够将滚环复制得到的长链切断成单个噬菌体基因组</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>类型II:M13<ul>
<li>环状, 但是却是<strong>单链DNA</strong></li>
<li>不发生细胞裂解，M13颗粒<strong>持续释放</strong></li>
<li>capsid由三个基因的多份拷贝(不是多次复制)编码</li>
<li>不发生整合</li>
</ul>
</li>
<li>M13复制流程:<ul>
<li>单链DNA注入并合成双链，称为RF，复制态</li>
<li>双链DNA 通过滚环复制生成新的RF<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1420221014113837.png" alt=""></li>
</ul>
</li>
<li>双链replicative form(RF)通过滚环机制重新产生单链DNA(滚环但是不复制)</li>
<li>单链DNA环化并组装</li>
</ul>
</li>
<li>M13的优势:<ul>
<li>基因组小于10kb;</li>
<li>RF类似质粒,能够以质粒形式感染;</li>
<li>单链形式DNA有利于测序和体外突变(in vitro mutagenesis);还能用于phage display(将要表达的蛋白基因和衣壳基因连在一起使其位于噬菌体外部)</li>
</ul>
</li>
</ul>
<h3 id="DNA纯化"><a href="#DNA纯化" class="headerlink" title="DNA纯化"></a>DNA纯化</h3><ul>
<li>Terminology:<ul>
<li>Total cell DNA: genomic DNA加上additional DNA molecules(如质粒)</li>
<li>Pure plasmid DNA:从细菌中提取,去除genomic DNA后的;</li>
<li>Phage DNA:from bacteriophage particles<ul>
<li>需要去除衣壳(M13除外,RF直接na)</li>
</ul>
</li>
<li>Defined medium: all the components are known(M9)</li>
<li>Undefined medium:the precise identity and quantity of the components are not known(LB)</li>
</ul>
</li>
</ul>
<ul>
<li>Basic steps:<ul>
<li>细菌培养<ul>
<li>E.coli培养:<ul>
<li>LB medium</li>
<li>37°C</li>
<li>摇床充气</li>
</ul>
</li>
<li>检测细胞浓度:<ul>
<li>光学法:测量在600nm处的吸光度(光密度OD是在特定波长下的吸光度)</li>
<li>$1\ OD_{600} = 0.8\times 10^9\ cells/ml$</li>
</ul>
</li>
</ul>
</li>
<li>离心使细胞裂解</li>
<li>细胞抽提(去除除DNA外组分)<ul>
<li>物理方法:研磨</li>
<li>化学方法:<ul>
<li>溶菌酶:digests the cell wall</li>
<li>EDTA: removes magnesium ions</li>
<li>sodium dodecyl sulphate (SDS):removes lipid molecules.</li>
<li>离心:remove insoluble debris</li>
</ul>
</li>
<li>DNA纯化:<ul>
<li>方法1:降解污染物<ul>
<li>proteinase K处理: 消化蛋白质;</li>
<li>苯酚和氯仿混合(Phenol&amp;chloroform):沉淀蛋白质</li>
<li>ribonuclease:去除RNA</li>
</ul>
</li>
<li>方法2:组分分离<ul>
<li>离子交换层析:DNA, RNA,部分蛋白质带负电结合与正电树脂,随后盐溶液洗脱,RNA+protein首先脱出,<strong>DNA最后,保留</strong>;</li>
<li>silica method:<ul>
<li>guanidinium thiocyanate硫氰酸胍：将除DNA外的物质变性, 同时使得DNA结合于silica particles;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DNA富集:<ul>
<li>Ethanol precipitation:$Na^+$, -20°C条件</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1520221015095725.png" alt=""><ol>
<li>玻璃棒搅动附着DNA</li>
<li>离心沉淀DNA</li>
</ol>
</li>
<li>DNA浓度: 测量在260nm波长时的吸光度<ul>
<li>$1 \ OD_{260} = 50\ ug/ml$</li>
</ul>
</li>
<li>DNA纯度:<ul>
<li>The ratio of the absorbances at 260 and 280 nm </li>
<li>around <strong>1.8</strong> with a pure DNA sample.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>分离质粒和细菌基因组:<ul>
<li>物理性质:<ul>
<li>质粒DNA分子较小, 细菌基因组较大</li>
<li>质粒和细菌基因组都为环状,但是在细胞抽提时基因组会断裂成线性分子,所以我们要做的是分离环状DNA分子;</li>
</ul>
</li>
<li>质粒DNA双链的两种形式:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1520221015175437.png" alt=""><ul>
<li>Covalently closed circular (ccc) DNA (Supercoiled DNA) </li>
<li>Open-circular (oc) DNA</li>
</ul>
</li>
<li>超螺旋分子能很轻易地从非超螺旋分子中分离,且大多数质粒以超螺旋形式存在于细胞中;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1520221015175849.png" alt=""><ul>
<li>alkaline denaturation:碱变性法</li>
<li>线性DNA在高PH时变性双链分开,而超螺旋质粒则保持原样;</li>
<li>再将PH调回7,DNA分子复性,但交织在一起,通过离心被去除;</li>
<li>这一过程大部分RNA和蛋白质也变得不溶, 被离心去除;</li>
</ul>
</li>
<li>氯化铯密度梯度离心:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1520221015180554.png" alt=""></li>
<li>密度不同，导致蛋白质(浮力小)在管的顶部，而RNA则相反在底部,DNA的浮力密度在蛋白质与RNA之间故而在管中间;</li>
<li>EtBr处理:分离超螺旋DNA和其他DNA<ul>
<li>EtBr通过插入相邻碱基对与DNA结合，导致双螺旋部分解开。</li>
<li>超螺旋不易结合故而浮力密度减少较少,而线性分子减少较多;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>质粒扩增:</p>
<ul>
<li>多拷贝质粒能够在没有蛋白质合成的情况下复制</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1520221015182120.png" alt=""><ul>
<li>氯霉素, 蛋白质合成抑制;</li>
</ul>
</li>
</ul>
</li>
<li><p>λ噬菌体DNA获取:</p>
<ul>
<li>获取噬菌体颗粒: 侵染后离心后噬菌体颗粒在清液层,而细菌沉积;<ul>
<li>噬菌体分为烈性噬菌体和溶原性噬菌体;<ul>
<li>在感染于寄主细菌细胞时，前者往往在菌体内增殖并将菌体裂解；</li>
<li>后者则不使细菌裂解，而成为与细胞同步增殖的遗传因子——原噬菌体。</li>
<li>温和噬菌体的基因组整合于宿主菌基因中，这种整合在细菌染色体上的噬菌体基因称为原噬菌体，原噬菌体可随细菌染色体的复制而复制，并通过细菌的分裂传给下一代，不引起细菌裂解，这种带有原噬菌体的细菌称为溶原性细菌。</li>
</ul>
</li>
<li>lysogenic型λ噬菌体获取:<ul>
<li>cI基因:控制噬菌体处于prophage状态;<ul>
<li>在cI内引入一个温度敏感突变(temperature-sensitive,即cIts)</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016144732.png" alt=""><ul>
<li>30°C:正常分裂;</li>
<li>42°C:裂解;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>non-lysogenic型λ噬菌体获取:<ul>
<li>许多载体都删除了cI基因,无法整合入细菌基因组;</li>
<li>所以只能通过细胞裂解获得噬菌体,故而需要注意噬菌体与细菌的比例;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017100510.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>富集噬菌体颗粒:<ul>
<li>PEG,一种长链多聚化合物,在有盐的条件下能够让噬菌体颗粒沉淀;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016150415.png" alt=""><ul>
<li>能够有效减少悬液的体积,有助于DNA提取;</li>
</ul>
</li>
</ul>
</li>
<li>噬菌体颗粒提纯:氯化铯密度梯度离心;<ul>
<li>去除细菌残骸,DNA;</li>
</ul>
</li>
<li>DNA提取:只要去除蛋白外壳即可,苯酚或者蛋白酶处理;</li>
</ul>
</li>
<li>M13噬菌体DNA获取:<ul>
<li>Replicative form形式同质粒一样获取;</li>
<li>单链DNA形式获取:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016151156.png" alt=""></li>
<li>类似λ烈性菌;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Manipulation-of-Purified-DNA"><a href="#Manipulation-of-Purified-DNA" class="headerlink" title="Manipulation of Purified DNA"></a>Manipulation of Purified DNA</h3><ul>
<li>DNA外切酶:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016151825.png" alt=""></li>
<li>直接移除双链末端碱基对;</li>
<li>移除双链中一条单链的末端核苷酸;</li>
</ul>
</li>
<li>DNA内切酶:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016151904.png" alt=""><ol>
<li>只能切开单链，或者双链中裸露的单链;</li>
<li>既可以切单链也可以切双链;</li>
<li>在特异性位点切割双链;</li>
</ol>
</li>
</ul>
</li>
<li><p>DNA连接酶: </p>
<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016152028.png" alt=""><ol>
<li>连接双链中的单链断开</li>
<li>连接两双链分子</li>
</ol>
</li>
</ul>
</li>
<li><p>DNA聚合酶:</p>
<ul>
<li>需要有双链区(primer)起始聚合;</li>
<li>DNA聚合酶I<ul>
<li>5’-3’外切酶活性由一个323氨基酸片段决定，失去这一片段不影响聚合酶功能，但是无法解聚DNA, 缺失该片段后的酶,叫做Klenow fragment;(注意是这个修改后的<strong>酶!!!</strong>)</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016152320.png" alt=""><ul>
<li>修复功能通过替换旧链方式实现，当5’-3’外切酶功能失去后，只能填充缺口，无法切除确实部分;</li>
<li>注意5’-3’外切酶,缺口处理方向;</li>
</ul>
</li>
</ul>
</li>
<li>Taq DNA polymerase:<ul>
<li>耐高温的嗜热菌DNA聚合酶I</li>
</ul>
</li>
</ul>
</li>
<li>DNA modifying enzymes<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016153508.png" alt=""><ol>
<li>去除5‘端末端磷酸基团</li>
<li>重新在5’端接上磷酸基团</li>
<li>将脱氧核苷酸加到DNA链(单双)3‘末端(OH基团)</li>
</ol>
</li>
</ul>
</li>
<li>限制性内切酶:<ul>
<li>Host-controlled restriction:宿主细胞能够在噬菌体复制之前切割噬菌体DNA,而细菌自身的DNA受到保护，不会被降解，因为它被甲基修饰。<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016153754.png" alt=""></li>
</ul>
</li>
<li>II型限制性内切酶在基因克隆中很重要。</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016154517.png" alt=""><ul>
<li>识别位点为回文序列；</li>
<li>II限制性内切酶有相同的亚基，识别的序列必然相同；</li>
<li>两亚基位置不平行，故而结合位置有差异, 所以产生粘性末端;</li>
<li><strong>BamHI和BglII具有相同的粘性末端</strong>;</li>
<li>还需要注意的是切割出的粘性末端长度:<img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016154931.png" alt=""><ul>
<li>如EcoRI,切割”G|AATTC”,但是由于对称结构,左右两边各留出一个核苷酸,粘性末端为”AATT”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>restriction digest:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016155432.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016155445.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016155458.png" alt=""><ul>
<li>Ethidium bromide (EtBr):前面说到能够插入DNA双链,同时也能用来给DNA染色;</li>
</ul>
</li>
<li>DNA分子大小评估:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016155656.png" alt=""><ul>
<li>a size marker;</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016155856.png" alt=""><ul>
<li>使用不同的酶切割获取不同的基因;</li>
</ul>
</li>
</ul>
</li>
<li>DNA ligation:<ul>
<li>互补粘性末端的连接比钝性末端要高效的多;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016160405.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016160207.png" alt=""></li>
</ul>
</li>
<li>Putting sticky ends onto a blunt-ended molecule:<ul>
<li>Linkers<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016160554.png" alt=""><ul>
<li>There should not be any BamHI recognition site in the fragment!</li>
</ul>
</li>
</ul>
</li>
<li>Adaptors<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016163527.png" alt=""></li>
<li>实际上是带有粘性末端的片段;</li>
<li>Part c是可能的问题:adaptor相互连接;<ul>
<li>解决办法:将粘性末端突出链(5’端)的磷酸基团去除,从而无法互相结合</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016164034.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>Producing sticky ends by homopolymer tailing<ul>
<li>Terminal deoxynucleotidyl transferase:末端转移酶,见上文 DNA modifying enzymes;能够往3’端添加核苷酸;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1620221016164509.png" alt=""><ul>
<li>目的基因加poly C,载体加poly G,结合稳定;</li>
<li>polymer长度不同的问题: Klenow polymerase+ligase</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Introduction-of-DNA-into-Living-cells"><a href="#Introduction-of-DNA-into-Living-cells" class="headerlink" title="Introduction of DNA into Living cells"></a>Introduction of DNA into Living cells</h3><ul>
<li><p><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017162039.png" alt=""></p>
<ul>
<li>未连接的载体</li>
<li>未连接的DNA</li>
<li>自体连接的载体</li>
<li>携带错误片段的分子</li>
</ul>
</li>
<li><p>[质粒DNA引入]Transformation:the introduction of any DNA molecule into any living cell.</p>
<ul>
<li>只有少部分物种能够轻松转化;</li>
<li>大肠杆菌只吸收少量DNA;</li>
<li>大肠杆菌需要化学或者物理处理使得其competent;<ul>
<li>competent: DNA吸收能力增强的细菌培养物;</li>
</ul>
</li>
<li>Competent treatment:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017163651.png" alt=""></li>
</ul>
<ol>
<li>calcium chloride($CaCl_2$)溶液,低温处理;<ul>
<li>氯化钙能使DNA沉积于细胞表面;</li>
<li>同时造成细胞膜产生物理变化(如打出孔)</li>
</ul>
</li>
<li>将温度提升到42°C,使得DNA被吸收</li>
<li>检测是否吸收完成|稳定:通过判断某些基因是否表达(如表达青霉素抗性的基因)</li>
</ol>
</li>
<li>Select transformed cells:<ul>
<li>1 ng pUC8质粒只能够产生100-10000个转化体, 仅为总DNA分子数的0.01%,故而要经过挑选;</li>
<li>抗生素选择:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017164600.png" alt=""><ul>
<li>用共有抗性 amp 筛选出载体分子和重组分子(不含载体的被筛去); </li>
<li>需要37°C培养1小时以让抗性基因表达;</li>
</ul>
</li>
</ul>
</li>
<li>Recombinant identification<ul>
<li>插入失活:正常表达的载体含有的选择性标签由于目的基因的插入而失活;<ul>
<li>插入后原本表达的特征不表达;</li>
</ul>
</li>
<li>抗生素抗性基因选择(pBR22):<ul>
<li>pBR22携带四环素和青霉素抗性[BamHI插入]</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017164159.png" alt=""></li>
<li>用木板记录下菌落位置,并按位置移植到$tet^R$培养基中,重组分子由于插入失活从而无法生长, 在第一个中<strong>取反</strong>即可得知重组分子菌落位置;</li>
</ul>
</li>
<li>lac基因选择(pUC8):<ul>
<li>pUC8携带青霉素抗性基因[BamHI插入]</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017165754.png" alt=""><ul>
<li>半乳糖苷酶由两部分组成:一部分由宿主编码(编辑过的大肠杆菌,缺失了编码lacZ’的部分),另一部分由质粒表达,组合成全酶;</li>
<li>X-gal:乳糖类似物,被半乳糖苷酶分解生成深蓝色产物;</li>
<li><blockquote>
<p>IPTG: 在没有乳糖存在时，lac操纵子（元）处于阻遏状态。此时，I序列在PI启动序列操纵下表达的Lac阻遏蛋白与O序列结合，阻碍RNA聚合酶与P序列结合，抑制转录启动。当有乳糖存在时，lac操纵子（元）即可被诱导。在这个操纵子（元）体系中，真正的诱导剂并非乳糖本身。乳糖进入细胞，经β-半乳糖苷酶催化，转变为异乳糖。后者作为一种诱导剂分子结合阻遏蛋白，使蛋白构象变化，导致阻遏蛋白与O序列解离、发生转录。异丙基硫代半乳糖苷（IPTG）的作用与异乳糖相同，是一 种作用极强的诱导剂，不被细菌代谢而十分稳定，因此被实验室广泛应用。</p>
</blockquote>
</li>
<li>由于recombinants中的lac基因被插入失活,故而无法合成半乳糖苷酶片段,无法分解X-gal,呈现白色;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>[噬菌体DNA引入]transfection&amp;in vitro packaging:<ul>
<li>transfection: equivalent to transformation;<ul>
<li>M13双链的RF形式DNA导入</li>
</ul>
</li>
<li>in vitro packaging: <ul>
<li>λ噬菌体转染效率低,使用in vitro packaging方法;</li>
<li>capsid 蛋白准备:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017180750.png" alt=""><ul>
<li>系统1: 缺陷cos位点,cos位点无法被识别, 致使λ噬菌体无法复制(滚环需要环状DNA),但是能够合成蛋白;</li>
<li>系统2:有两个重组, 两个所携带capsid基因中分别有一个突变,生成的蛋白不全,故而无法独立完成感染循环,将之混合后能够进行组装从而获得噬菌体.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>噬菌斑:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017181342.png" alt=""><ul>
<li>对于λ噬菌体:包含裂解的宿主细胞和噬菌体颗粒;</li>
<li>对于M13:包含生长缓慢的细菌和M13颗粒;</li>
</ul>
</li>
<li>每个噬菌斑来自于单个感染的细胞;</li>
<li>可能是recombinants,也可能是self-ligated vectors;</li>
</ul>
</li>
<li>Select recombinant phages:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/1720221017181727.png" alt=""></li>
<li>lac基因插入失活:recombinant的噬菌斑不是white,而是clear!</li>
<li>λ cI基因插入失活:non-recombinant的cI基因正常工作,形成lysogen,故而呈现浑浊噬菌斑;</li>
<li>Spi表型:λ噬菌体不能感染P2噬菌体已经感染的大肠杆菌,称之为$Spi^+$;<ul>
<li>插入新的DNA能够使λ转变为$Spi^-$,从而能够形成噬菌斑[也只有重组型可以];</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cloning-Vectors-for-E-coli"><a href="#Cloning-Vectors-for-E-coli" class="headerlink" title="Cloning Vectors for E.coli"></a>Cloning Vectors for E.coli</h3><ul>
<li>经典质粒:<ul>
<li>pBR322<ul>
<li>4363bp大小,体积小;</li>
<li>青霉素和四环素抗性基因;</li>
<li>15copies, 高拷贝数;</li>
</ul>
</li>
<li>pBR327<ul>
<li>比pBR22更高的拷贝数(30-45copies)</li>
</ul>
</li>
<li>pUC8<ul>
<li>500-700copies;</li>
<li>青霉素抗性基因+lac’基因,能够完成重组体选择</li>
<li>lac’基因上有一簇限制性位点,允许DNA片段两不同粘性末端;</li>
</ul>
</li>
<li>pGEN3Z<ul>
<li>青霉素抗性基因+lac’基因</li>
<li>含有两promoter序列在lac’基因的两端,可以用于体外转录,从而允许双向转录;</li>
</ul>
</li>
</ul>
</li>
<li>噬菌体载体:<ul>
<li>lambda噬菌体:<ul>
<li>大小问题: 噬菌体衣壳大小有限,能放入的DNA长度有限;<ul>
<li>solution: 将无重要功能的b2区去除从而省出空间;</li>
</ul>
</li>
<li>酶切位点问题:λ噬菌体有多个酶切位点(甚至对于同一个限制酶);<ul>
<li>solution: 将分泌限制酶的E.coli突变体用λ噬菌体感染,如果只有产生突变的,去除了限制位点的噬菌体能形成噬菌斑;</li>
<li>绝大部分的λDNA被降解, 少数剩下的(产生plaque)丢失了限制位点;</li>
</ul>
</li>
<li>种类:<ul>
<li>λ insertion vector:去除b2区得到,存在一个酶切位点;<ul>
<li>普通λ基因组只能增加5%的DNA,也即3kb,否则放不进capsid,去除非必要区后,容量大大增加;</li>
<li>λgt10:CI基因能够保持基因组在Prophage状态,含有EcoRI限制位点, 基因插入失活,从而产生clear plaque;携带8kb</li>
<li>λ ZAPII:含有lacZ’基因,故而能够允许插入失活,并含有6个限制性位点;</li>
</ul>
</li>
<li>replacemnet vector替换型载体: 含有一个stuffer区, 能够通过限制性位点替换掉Stuffer fragment;携带10kb;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030150554.png" alt=""></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030150710.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>λ噬菌体既可以用环状DNA以质粒形式转染,也可以使用liner形式(含有EcoRI和cos位点)<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030151520.png" alt=""></li>
<li>cosmid : a plasmid that carries a <em>cos</em> site;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030151734.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所需的克隆数:N <ul>
<li><script type="math/tex; mode=display">N = \frac{\log{1-\rho}}{\log{1-\frac{a}{b}}}</script></li>
<li>$\rho$ = 在基因文库中gene of interest出现的概率;</li>
<li>$a$ = 插入片段的大小</li>
<li>$b$ = 基因组总大小;</li>
</ul>
</li>
<li>M13噬菌体:<ul>
<li>由于M13基因组基因相隔很近, 修改或者是删除这些基因将会导致RF的功能受阻,只有508个碱基的修改不会影响, 也即是复制起始位点所在区;</li>
<li>插入<em>lacZ’</em>到起始位点后面的流程:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030154702.png" alt=""></li>
<li>怎么做到将限制性位点插入lacZ’?<ul>
<li>首先利用密码子的简并性, 突变得到EcoRI位点同时不改变lacZ’的功能;</li>
<li>接着将两端有EcoRI粘性末端的polylinker(携带多个限制位点)插入lacZ’的限制位点;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030155050.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>Hybrid plasmid-M13 vectors (phagemids):杂交M13和质粒:<ul>
<li>将M13的一部分DNA(形成RF的基因)导入pUC8从而使得质粒能像M13一样进行;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030165448.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Cloning-vectors-for-Eukaryotes"><a href="#Cloning-vectors-for-Eukaryotes" class="headerlink" title="Cloning vectors for Eukaryotes"></a>Cloning vectors for Eukaryotes</h2><ul>
<li>出于某些特殊目的, 我们可能需要使用真核生物作为宿主:<ul>
<li>为了获得大量药用蛋白;</li>
<li>为了改变某个生物的性质,如为农作物添加除草剂抗性;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030174223.png" alt=""></li>
</ul>
</li>
<li>真菌载体(酵母):<ul>
<li>2 μm plasmid: </li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030174343.png" alt=""><ul>
<li>REP1 and REP2 are  involved in replication of the  plasmid.</li>
<li>FLP: 编码能够使质粒内重组的蛋白;</li>
<li>copy numbers:70-200</li>
</ul>
</li>
<li>selective marker:<ul>
<li>LEU2: 编码将丙酮酸转化为亮氨酸的酶, 对于trp-营养缺陷型的宿主来说是必要的,故而以之作为宿主,再使用含LEU2的载体从而得到recombinant;</li>
<li>其他的marker也类似,主要是使用缺陷型;</li>
</ul>
</li>
<li>克隆载体:<ul>
<li>种类:<ul>
<li>Yeast episomal plasmids (YEps):<ul>
<li>为shuttle vector, 能够同时在酵母和大肠杆菌中复制;<ul>
<li>这一性质使得其能首先通过大肠杆菌进行纯化, 再转入酵母;</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030183656.png" alt=""></li>
</ul>
</li>
<li>载体通过与宿主基因组中同源的基因发生重组从而整合进基因组:<ul>
<li>LEU突变体和酵母LEU基因发生重组.使得质粒进入酵母基因组,类似插入序列,会复制目标片段,形成两个基因,但通常只有一个有效</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030184555.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>Yeast integrative plasmids (YIps) <ul>
<li>跟episome的区别在于没有起始位点,只能通过整合进基因组和宿主一起复制;</li>
</ul>
</li>
<li>Yeast replicative plasmids (YRps) <ul>
<li>跟integrative相对, 以质粒形式复制;</li>
</ul>
</li>
<li>Yeast centromere plasmids (YCps)<ul>
<li>含有复制区和着丝粒,能够像基因组一样复制,故而被称为mini-chromosome;</li>
</ul>
</li>
</ul>
</li>
<li>几种克隆载体比较:<ul>
<li>转化频率:<ul>
<li>加入一定量质粒DNA能获得的转化体数(个每微克)</li>
<li>YEps &gt; YRps,YCps &gt;&gt; YIps</li>
</ul>
</li>
<li>拷贝数:<ul>
<li>YEps:20-50</li>
<li>YRps:5-100</li>
<li>YIps == YCps == 1</li>
</ul>
</li>
<li>重组体稳定性: YIps &gt; YCps &gt; YEps &gt; YRps</li>
</ul>
</li>
<li>特殊载体:YAC yeast artificial chromosome<ul>
<li>组成成分:<ul>
<li>centromere: 能够像基因组一样复制</li>
<li>two telomeres:<ul>
<li>作用1: 让末端能够正确地被复制;</li>
<li>作用2: 避免其被外切酶消化;</li>
</ul>
</li>
<li>复制起点;</li>
</ul>
</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030193821.png" alt=""><ul>
<li>TEL: act as seeding sequences for telomeres building</li>
<li>CEN4: DNA from the  centromere region of chromosome </li>
<li>ori: The origins of replication</li>
<li>SUP4: selectable marker into which new DNA is inserted. Yeast  are <strong>normally red</strong>(accumulation of red pigment), and those transformed with YAC will form <strong>colorless</strong> colonies.</li>
<li>URA3 and TRP1: selectable markers.</li>
</ul>
</li>
<li>Electroporation: <img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030194838.png" alt=""><ul>
<li>电穿孔法:在膜上打出暂时的孔洞从而吸收DNA, 对于植物来说则是要多加两步, 去细胞壁和重新生成细胞壁;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对于植物:<ul>
<li>Ti(tumor inducing) plasmid:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030202015.png" alt=""></li>
<li>Ti质粒转染后T-DNA会整合进基因组,从而使细胞表现出成瘤性</li>
<li>Ti质粒过大, 不利于操作:<ul>
<li>解决方法1: 双质粒法, 将T-DNA从原来的Ti质粒移出至质粒B,剩下质粒A;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030203248.png" alt=""></li>
<li>质粒A负责表达转移T-DNA的蛋白;</li>
<li>质粒B则小到便于我们操作,从而能够添加限制位点;</li>
</ul>
</li>
<li>解决方法2:共整合法,Ti质粒加上一个携带有T-DNA同源片段的质粒(含目的基因)<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030203237.png" alt=""></li>
<li>T-DNA和小质粒发生同源重组,从而将目的基因转移到T-DNA中;</li>
</ul>
</li>
</ul>
</li>
<li>T-DNA整合的机理:</li>
</ul>
</li>
<li>质粒载体直接转移:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030203605.png" alt=""></li>
<li>超螺旋质粒能够通过同源重组整合进植物基因组;</li>
<li>导入细胞的方法: Biolistics,PEG-induced DNA delivery,Electroporation</li>
</ul>
</li>
<li>将基因导入叶绿体基因组:<ul>
<li>通过同源重组导入, 叶绿体数量多,表达量高;</li>
</ul>
</li>
<li>植物病毒载体:<ul>
<li>植物病毒多为RNA,仅有的两种DNA病毒不适合作为克隆载体;</li>
</ul>
</li>
</ul>
</li>
<li>动物克隆载体:<ul>
<li>部分蛋白在细菌或者真菌中无法正常表达;基因疗法,通过将一个基因导入病人细胞;</li>
<li>P elements:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/10/3020221030204534.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>biology</tag>
      </tags>
  </entry>
  <entry>
    <title>蛋白质组学学习笔记</title>
    <url>/2023/06/10/%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%84%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章—蛋白质组学绪论"><a href="#第一章—蛋白质组学绪论" class="headerlink" title="第一章—蛋白质组学绪论"></a>第一章—蛋白质组学绪论</h2><ul>
<li><p>蛋白质组学的必要性</p>
<ul>
<li>You can have a protein in the cell when its  mRNA is no longer present</li>
<li>You can have lots of mRNA without translation of the message to protein</li>
<li>No good correlation between mRNA  abundance and protein amount in a cell at a  given time.</li>
</ul>
</li>
<li><p>从mRNA水平不一定能预测细胞中相应蛋白质 的水平。</p>
<ul>
<li>各种mRNA不同的<strong>稳定性</strong>和不同的<strong>翻译效率</strong></li>
<li>蛋白质形成后在<strong>稳定性和转换速度</strong>上有很大不同。</li>
<li>mRNA水平没有告诉我们相应蛋白质的<strong>调节状态</strong>，蛋白质的活性和功能常有一些内源翻译后的改变，也会因环境因素而改变<ul>
<li>翻译后的多种修饰</li>
<li>蛋白质易受损伤</li>
<li>蛋白质修饰引发蛋白质降解</li>
</ul>
</li>
</ul>
</li>
<li><p>蛋白质白质表达水平变化极大</p>
<ul>
<li>基因的转录速度</li>
<li>mRNA的翻译效率</li>
<li>细胞中蛋白质的降解速度</li>
</ul>
</li>
<li>含有不常使用的某些基因倾向于较低水平表达。</li>
<li>针对生命活动 中某一种或某几种蛋白质，难以形成一种整体观， 难以系统透彻地阐释生命活动的基本机制。</li>
</ul>
<ul>
<li><p>基因组与转录组不能取代蛋白质组</p>
<ul>
<li>基因和蛋白质并不存在严格的线性关系</li>
<li>ORF并不预示一定存在相对应的功能性基因</li>
<li>mRNA水平并非与蛋白质的表达水平对应</li>
<li>翻译后修饰及同工蛋白质(Isoforms)等现象在 基因水平无从表现</li>
<li>蛋白质与蛋白质的相互作用</li>
</ul>
</li>
<li><p>蛋白质组学与蛋白质化学</p>
<ul>
<li>后者同一时间内只研究一个蛋白质或多亚基蛋白质复合物。研究工作通常包括完整序列测定、结构测定以及结构控制功能的模型研究</li>
<li>前者需要获得体系内所有蛋白质组分的物理、化学及生 物学参数，如分子量、等电点、表达量等。是在数据库匹配工具帮助下 进行部分序列测定。</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230610150335.png" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>蛋白质组学所遇到的挑战<ul>
<li>蛋白组学实验中, 往往只能检测到一小部分蛋白质</li>
<li>需要被研究物种的全基因组序列</li>
<li>无法进行大规模蛋白分析<ul>
<li>蛋白质易降解</li>
<li>存在很多同工体</li>
<li>没有蛋白质的克隆手段</li>
</ul>
</li>
<li>数据分析<ul>
<li>数据存在噪声, 难以分离真实信号, 导致搜索耗费资源</li>
<li>数据库匹配只能给出可信度得分, 需要人为干涉消除假阳性</li>
</ul>
</li>
<li>生物医学瓶颈<ul>
<li>只能获得疾病某一时刻的状态, 无法追踪其真实进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章—蛋白质样品的制备"><a href="#第二章—蛋白质样品的制备" class="headerlink" title="第二章—蛋白质样品的制备"></a>第二章—蛋白质样品的制备</h2><h3 id="蛋白质的提取-收集样品-破碎-抽提"><a href="#蛋白质的提取-收集样品-破碎-抽提" class="headerlink" title="蛋白质的提取: 收集样品+破碎+抽提"></a>蛋白质的提取: 收集样品+破碎+抽提</h3><ul>
<li><p>样品收集: 要控制稳定的材料来源</p>
<ul>
<li>注意因素<ul>
<li>生长时期</li>
<li>组织位置</li>
<li>可溶性</li>
<li>蛋白质组的修饰</li>
</ul>
</li>
<li>材料存储, 上中下三策, 解冻时要越快越好，但避免局部过热<ul>
<li>优先直接用, 立即抽提</li>
<li>先以液氮处理后於 -70℃则更佳</li>
<li>在采集后，尽速置於 -20℃</li>
</ul>
</li>
<li>制备样品<ul>
<li>待分析的蛋白样品全部处于溶解状态（包括多数疏水性蛋白）</li>
<li>防止样品在聚焦时发生<strong>蛋白的聚集和沉淀</strong></li>
<li>防止发生样品的抽提后化学修饰（如酶性或化学性<strong>降解</strong>等）</li>
<li>完全去除样品中的<strong>核酸和某些干扰蛋白</strong></li>
<li>尽量去除起干扰作用的高丰度或无关蛋白</li>
</ul>
</li>
</ul>
</li>
<li><p>破碎细胞: 分泌性蛋白质，多散布在材料中，只要研磨均匀，大多可抽取得到。不能研磨过度，以免细胞破得太碎。</p>
<ul>
<li>液态氮研磨：以研钵打碎材料後研磨成粉。</li>
<li>均质器： 玻璃等材质，较温和的研磨方法。<ul>
<li>把材料先切成碎片才容易进行抽取。材料亦可以液氮急速冷却</li>
</ul>
</li>
<li>玻璃球 (glass bead)：以很细的玻璃球混在样本中，用力振荡</li>
<li>酶解</li>
<li><p>洗涤剂裂解</p>
</li>
<li><p>冻融</p>
</li>
<li>渗透裂解</li>
<li>超音波震荡 (ultrasonication)： 以超音波打破细胞，多用在微生物材料。</li>
</ul>
</li>
<li><p>细胞裂解: 保持低温（冰浴，使用预冷的溶液）,直接加入含强变性剂的裂解液</p>
<ul>
<li>目标:<ul>
<li>必须打断non-covalent protein-protein, protein-DNA, protein-lipid interactions, disrupt S-S bonds</li>
<li>必须阻止蛋白裂解;<ul>
<li>避免蛋白水解和降解的措施<ul>
<li>保持低温</li>
<li>变性剂</li>
<li>蛋白酶抑制剂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>裂解液主要成分<ul>
<li>还原剂：用于还原二硫键或防止蛋白质氧化<ul>
<li>DTT : 含有自由巯基，带电荷，IEF过程中降低溶解度 (抗氧化剂)</li>
<li>TBP: 不带电荷，增强IEF过程中蛋白溶解度，提高一维向二维转移效率</li>
</ul>
</li>
<li>缓冲液<ul>
<li>NaN3:除菌</li>
<li>EDTA: 除二价离子</li>
<li>蛋白酶抑制剂</li>
</ul>
</li>
<li>酶：用于消化污染的核酸、糖和脂类</li>
<li>变性剂: 改变溶液离子强度和PH，破坏蛋白质-蛋白质相互作用,破坏蛋白质的二级结构和三级结构。<ul>
<li>尿素－硫脲混合物提高样品溶解度, 硫脲水溶性差，只有在浓尿素溶液中可溶性才好</li>
</ul>
</li>
<li>去污剂：有助于溶解膜蛋白质，并有助于膜蛋白质与脂类的分离<ul>
<li>SDS：阴离子去污剂，能破坏大多数非共价结合的蛋白; 破坏IEF，所以只用于前期溶解，然后用非离子或两性离子去污剂置换出来。</li>
<li>CHAPS：两性离子去污剂，对膜蛋白溶解有效 </li>
</ul>
</li>
</ul>
</li>
<li>非蛋白物质的去除<ul>
<li>核酸：超声（防止产生泡沫）和核酸酶（产生假点）</li>
<li>脂与多糖：超速离心（部分损失）</li>
<li>盐：小分子，浓度过高会降低等电聚焦的电压<ul>
<li>透析（时间长），凝胶过滤，沉淀重悬法（部分损失）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>蛋白质浓缩:</p>
<ul>
<li>盐析及沉淀法: 蛋白质在水溶液中的溶解度，会因溶液中其它盐类浓度的改变而增減</li>
<li>硫酸铵 (ammonium sulfate)<ul>
<li>硫酸铵是中性盐，对蛋白质有相当好的安定作用。</li>
<li>又因为其离子容积较大，吸走水分子的能力也大，成为有效的盐析工具。</li>
</ul>
</li>
<li>有机溶剂沉淀法<ul>
<li>因稀释水浓度而降低水活性，则蛋白质上亲水性区域的水合度降低，开始聚集在一起，产生沉淀。</li>
<li>使用有机溶剂, 先把温度降至零度左右，缓缓加到蛋白质溶液中，边搅拌使生沉淀。</li>
<li>以离心收集，以增加回收，并可去除丙酮。蛋白质沉淀可凉干，或在布氏漏斗中以少量乙醚洗过制成粉末；</li>
</ul>
</li>
<li>顺序抽提法</li>
</ul>
</li>
<li><p>蛋白质的分离纯化</p>
<ul>
<li>目标: <ul>
<li>高活性: 纯化成品与原始粗抽液二者间，其比活性之比值（纯化倍率）越高越好。</li>
<li>高回收率：一般指总活性的回收</li>
<li>高纯度：相对而言，在<strong>电泳</strong>上看不到其它杂质，即可视为均质。</li>
<li>方便与快速: </li>
<li>经济</li>
</ul>
</li>
<li>要求:<ul>
<li>高分辨率</li>
<li>高通量</li>
<li>与质谱的下游分析兼容</li>
</ul>
</li>
<li><p>可用于分离的性质:</p>
<ul>
<li><p>分子大小: </p>
<ul>
<li>透析（dialysis）和超过滤（加压或离心）<ul>
<li>截留分子量 (MWCO): 一种超滤膜对大小已知的分子化合物的截留性质<ul>
<li>对于大于截留分子量的分子，通过超滤膜可以有90 / 95 %的截留效率</li>
<li>可以在温和条件下进行,没有大的生物活性的损失</li>
</ul>
</li>
</ul>
</li>
<li>密度梯度（区带）离心<ul>
<li>每种蛋白质颗粒沉降到与自身密度相等的介质密度梯度时,即停止不前,最后各种蛋白质在离心管中被分离成各自独立的区带(zone)。</li>
<li>降系数即用来描述此沉降性质；单位为 S (Svedberg unit)。</li>
</ul>
</li>
<li>凝胶过滤法: 不改变样品的生物学性质<ul>
<li>又称凝胶层析Gel chromatography、分子筛层析moleculer chromatography或排阻层析ellusion chromatography 。</li>
<li>凝胶条件:<ul>
<li>化学惰性</li>
<li>没有或只有极少量的离子交换基团</li>
<li>有足够的机械强度。</li>
</ul>
</li>
<li>凝胶的交联度或孔度（网孔大小）决定了凝胶的分级分离范围: 对大分子物质的分离，多采用琼脂糖。对小分子物质的分离，多采用葡聚糖。</li>
<li>依次洗脱收集后，通过紫外吸收法测定吸收峰。</li>
</ul>
</li>
</ul>
</li>
<li><p>溶解度</p>
<ul>
<li>等电点沉淀和PH值控制<ul>
<li>当pH = pI，净电荷为零，相邻蛋白质分子之间失去了静电斥力而趋向于聚集沉淀。</li>
<li>不同的蛋白质等电点不同，因此可以通过控制溶液的PH值来沉淀混合物中的某种蛋白成分。</li>
<li>蛋白质可以保持天然构象，能重新溶解于一定浓度的溶液中。</li>
</ul>
</li>
<li>蛋白质的盐析<ul>
<li>当溶液中的离子强度达到一定的数值时（盐浓度高达一定数值时），蛋白质的溶解度开始下降，很多蛋白质可以从水溶液中析出，这种现象称为盐析。</li>
</ul>
</li>
<li>有机溶剂分级分离法<ul>
<li>有机溶剂的加入改变了介质的介电常数。</li>
<li>这些有机溶剂不仅能引起蛋白质沉淀，而且伴随着变性。</li>
</ul>
</li>
<li>改变温度<ul>
<li>一般蛋白质的分级分离操作一般都在0~4oC温度下进行。</li>
<li>0~40oC之间：大部分球状蛋白质的溶解度随温度升高而增加，</li>
</ul>
</li>
</ul>
</li>
<li>电荷<ul>
<li>离子交换层析<ul>
<li>阳离子交换型树脂: 与树脂中的带电基团相互作用，结果X与Na＋交换（阳离子交换），形成SO3-X</li>
<li>在样品与树脂充分交换后，可通过提高<strong>流动相中的盐浓度</strong>，或<strong>改变流动相的pH</strong>，或是同时采用这两种方法进行逐一洗脱</li>
</ul>
</li>
<li>电泳<ul>
<li>等电聚焦或称电聚焦: 高分辨率的蛋白质分离技术, 也可用于蛋<strong>白质等电点的测定</strong><ul>
<li>在具有pH梯度的介质（如浓蔗糖溶液）中,  在外电场作用下, 各种蛋白质将移向并聚焦（停留）在等于其<strong>等电点的pH梯度</strong>处，并形成一个很窄的区带。<ul>
<li>pH梯度制作: 预电泳, 利用缓冲液在电场作用下在凝胶内沿电场方向制造一个pH梯度。</li>
</ul>
</li>
<li>只要它们的pI有0.02（甚至&lt;0.02）pH单位的差别就能分开。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>吸附性质<ul>
<li>硅胶,氧化铝和活性炭等.主要用来分离非离子、水不溶性化合物</li>
</ul>
</li>
<li>对配体分子的生物学亲和力<ul>
<li>利用蛋白质分子对其配体分子<strong>特有的识别能力</strong>, 即生物学亲和力<ul>
<li>经常只需一步处理即可将某种所需蛋白质从复杂混合物中分离出来，纯度相当高。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2D Gel Electrophoresis</p>
<ul>
<li>过程:<ul>
<li>第一向：等电聚焦电泳(SDS破坏电荷条件), 水平方向, PH从大到小<ul>
<li>very high voltages (5000V)</li>
<li>a long period of time (10h)</li>
<li>Presence of a pH gradient</li>
<li>pH gradient and electric field strength决定分辨率</li>
<li>IPG等电聚焦优点<ul>
<li>pH梯度稳定；</li>
<li>可以生成任意的适当的pH梯度用于不同目的的分离<ul>
<li>非线形梯度胶条也可以在特定pH范围使蛋白质分布更均匀</li>
</ul>
</li>
<li>上样量大，可达几十毫克<ul>
<li>胶越长, 上样量越大, 分辨率越高; 快速筛选或高丰度蛋白质则用短胶条</li>
</ul>
</li>
<li>重复性好；</li>
<li>强度好，易操作 。</li>
</ul>
</li>
</ul>
</li>
<li>第二向：SDS-PAGE, 垂直方向, 分子量从大到小<ul>
<li>modest voltages (200V)</li>
<li>shorter period of time (2h)</li>
<li>Presence of SDS</li>
<li>%acrylamide &amp; electric field strength, 丙烯酰胺含量和电场强度决定分辨率<ul>
<li>丙烯酰胺含量越高, 带跑的越近, 尽量让要研究的带在中间位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>效果:<ul>
<li>0.0025 pH units精度</li>
<li>能够获得蛋白相对丰度(染色强度)</li>
<li>通过比较能够获得差异蛋白</li>
<li>能够发现新的蛋白</li>
</ul>
</li>
<li>缺点:<ul>
<li>Cannot handle extremely acidic / basic proteins 超出PH梯度范围的无法处理</li>
<li>Misses some large proteins (&gt;150 kD )&amp; membrane proteins (&gt;30% of all proteins)</li>
<li>Only detects high abundance proteins (top 30% typically)<ul>
<li>低丰度蛋白的分离: 将总蛋白组分成蛋白质组亚群，再用pH梯度小于2个pH单位的IPG胶进行窄pH范围的分离。</li>
</ul>
</li>
<li>耗时长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章—Strategies-for-protein-Identification-and-Quantification"><a href="#第三章—Strategies-for-protein-Identification-and-Quantification" class="headerlink" title="第三章—Strategies for protein Identification and Quantification"></a>第三章—Strategies for protein Identification and Quantification</h2><ul>
<li>两大鉴定方法, 爱德曼降解法和质谱</li>
<li>Edman degradation:<ul>
<li>phenyl isothiocyanate(硫氢酸苯): labeling the N-terminal amino acid</li>
</ul>
</li>
</ul>
<h2 id="第四章—蛋白质相互作用检测技术"><a href="#第四章—蛋白质相互作用检测技术" class="headerlink" title="第四章—蛋白质相互作用检测技术"></a>第四章—蛋白质相互作用检测技术</h2><h2 id="第五章—蛋白质生物信息学"><a href="#第五章—蛋白质生物信息学" class="headerlink" title="第五章—蛋白质生物信息学"></a>第五章—蛋白质生物信息学</h2>]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>biology</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习杂记</title>
    <url>/2022/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="线性可分SVM"><a href="#线性可分SVM" class="headerlink" title="线性可分SVM:"></a>线性可分SVM:</h3><ul>
<li>主要参考<a href="https://cloud.tencent.com/developer/article/1525310">这样一步一步推导支持向量机，谁还看不懂？</a>,及<a href="https://zhuanlan.zhihu.com/p/77750026">【机器学习】支持向量机 SVM</a></li>
<li>优化公式:<ul>
<li><script type="math/tex; mode=display">D = \frac{||\omega^Tx+b||}{||\omega||}</script></li>
<li>$\omega$和$b$为超平面有关参数;</li>
<li>定义$\omega^Tx+b\geq 0$的为正样本(y=1), 反之($\leq$)则为负样本(y=-1)</li>
<li>则有:<ul>
<li><script type="math/tex; mode=display">\frac{y_i\times(\omega^Tx+b)}{||w||\times D}\geq 1</script></li>
<li>仅当样本点为支持向量时, 等于$||w||\times D$, </li>
<li>此时的D为超平面的间隔, 也是我们想要最大化的对象;</li>
</ul>
</li>
<li>故而所求变为:<ul>
<li><script type="math/tex; mode=display">D = \max\frac{(\omega^Tx_{sup}+b)\times y}{||w||}</script></li>
</ul>
</li>
<li>$x_{sup}$表明它为支持向量, 总是在超平面上, 不影响最优化结果, 式子变为:<ul>
<li><script type="math/tex; mode=display">D = \max\frac{1}{||w||}</script></li>
</ul>
</li>
<li>等价于:<ul>
<li><script type="math/tex; mode=display">D = \min||w||</script></li>
</ul>
</li>
<li>为方便计算,将式子化为:<ul>
<li><script type="math/tex; mode=display">D = \min\frac{1}{2}||w||^2</script></li>
</ul>
</li>
<li>约束条件为:<ul>
<li><script type="math/tex; mode=display">(\omega^Tx+b)\times y\geq 1</script></li>
<li><script type="math/tex; mode=display">\Rightarrow g_i(\omega,b)=1-y_i(\omega^Tx_i+b)\leq 0</script></li>
</ul>
</li>
</ul>
</li>
<li>KKT条件:<ul>
<li><script type="math/tex; mode=display">\frac{\partial L}{\partial w_ {i}}  =  \frac {\partial f}{\partial w_ {i}}+\sum^{n}_{j=1} \lambda _ {j}\frac {\partial g_ {j}}{\partial w_ {i}}  =0\\  \lambda_ig_ {i}  (w)=0\\  g_{i}  (w)  \leqslant 0\\\lambda_i>0</script></li>
</ul>
</li>
<li>引入松弛变量:<ul>
<li><script type="math/tex; mode=display">g_i(w)\leq 0\Rightarrow h_i(w)=g_i(w)+a_i^2=0</script></li>
<li><script type="math/tex; mode=display">\Rightarrow L(w,\lambda,a) = f(w)+\sum_{i=1}^n\lambda_i\times[g_i(w)+a_i^2]</script></li>
<li><script type="math/tex; mode=display">= f(w)+\sum_{i=1}^n\lambda_i\times g_i(w)+\sum_{i=1}^n\lambda_i\times a_i^2</script></li>
</ul>
</li>
<li>因为<ul>
<li><script type="math/tex; mode=display">\lambda_i\geq 0\\\Rightarrow \sum\lambda\times a_i^2\geq0</script></li>
</ul>
</li>
<li>故原式变为<ul>
<li><script type="math/tex; mode=display">L(w,b)= f(w)+\sum_{i=1}^n\lambda_i\times g_i(w)</script></li>
</ul>
</li>
<li>当 $f(w)$ 取到最小值 $p$ 时, 我们得到最佳参数,然而由于约束的存在,<br>我们不一定能够取到最小值,只能尽量接近;</li>
<li>由于<ul>
<li><script type="math/tex; mode=display">\sum_{i=1}^n\lambda_i\times g_i(w)\leq 0</script></li>
</ul>
</li>
<li>所以<ul>
<li><script type="math/tex; mode=display">L(w,b) \leq p</script></li>
</ul>
</li>
<li>故而我们需要先尽可能接近 $p$<ul>
<li><script type="math/tex; mode=display">\max_\lambda L(w,b,\lambda)</script></li>
</ul>
</li>
<li>接着再求总体最小值<ul>
<li><script type="math/tex; mode=display">\min_{w,b}\max_\lambda  L(w,b,\lambda)\\ s.t.\qquad\lambda _ {i}\geqslant  0</script></li>
</ul>
</li>
<li>从而可以构造Lagrange函数:<ul>
<li><script type="math/tex; mode=display">\min_{w,b}\max_\lambda  L(w,b,\lambda)=\\\ \frac{1}{2}||w||^2+\sum_{i=1}^m\lambda_i\times[1-y_i(w^Tx+b)]\\ s.t.\qquad\lambda _ {i}\geqslant  0</script></li>
<li>注意维度问题, $\omega$ 维度与样本个数相同, 而 $\lambda$ 维度与一个样本点的特征数相同(即 $m$)</li>
</ul>
</li>
<li>强对偶性转换(与KKT互为充要条件, 前面已满足),等价于<ul>
<li><script type="math/tex; mode=display">\max_\lambda\min_{w,b}  L(w,b,\lambda)</script></li>
</ul>
</li>
<li>由此我们可以先求 $\min_{w,b}  L(w,b,\lambda)$<ul>
<li><script type="math/tex; mode=display">\frac{\partial L}{\partial w} = 0\\\frac{\partial L}{\partial b}=\sum_{i=1}^m{x_y\times y_i} = 0</script></li>
</ul>
</li>
<li>第一个式子怎么求($\frac{\partial L}{\partial w} = 0$)?<ul>
<li><script type="math/tex; mode=display">L(w,b,\lambda)=\frac {1}{2}||w|^ {2}+\sum_{i=1}^{m}\lambda_i\times(1-y_ {i}(w^ {T}\vec{x_ {i}}+b))</script></li>
<li>$i$ 表示第 $i$ 特征, $m$ 为总特征数;</li>
</ul>
</li>
<li>具体推导建议查看<a href="https://cloud.tencent.com/developer/article/1525310">这样一步一步推导支持向量机，谁还看不懂？</a>;</li>
</ul>
<h2 id="Adaboost推导"><a href="#Adaboost推导" class="headerlink" title="Adaboost推导"></a>Adaboost推导</h2><h3 id="Adaboost基本流程"><a href="#Adaboost基本流程" class="headerlink" title="Adaboost基本流程:"></a>Adaboost基本流程:</h3><ul>
<li>输入: Datasets: {…,[$x_i$,$y_i$],…};</li>
<li>学习器: $F(x) = sign(F_m(x)) = sign(\Sigma_k^M{F_k(x)\times \alpha_k})$;</li>
<li>参数: <ul>
<li>$W_i, i = 1…N$: 各个样本点的权值;这一权重代表了被分类错误的严重性,也即当一个学习器分类;</li>
<li>$\alpha_k$:各个学习器的权值;</li>
</ul>
</li>
</ul>
<p><strong>流程</strong>:</p>
<ul>
<li>初始化样本点权重: $W_i = 1/N$;</li>
<li>迭代:<ul>
<li>训练一个弱学习器$G_k$,G 代表 gender;</li>
<li>更新$\alpha_k,W_i$:<ul>
<li>error rate: <ul>
<li><script type="math/tex; mode=display">e_m = \Sigma_i^N{W_i\times I(G(x_i)\ != y_i)}</script></li>
</ul>
</li>
<li>the weight of the Gender learner:<ul>
<li><script type="math/tex; mode=display">\alpha_k = \frac{1}{2}\log{\frac{1-e_m}{e_m}}, i.e.\frac{1}{2}\log{\frac{positive\ rate}{negative\ rate}}</script></li>
</ul>
</li>
<li>The weight of each sample points:<ul>
<li>$W<em>{k,i} = W</em>{k-1,i}\times \exp{-\alpha_m\times y_i\times G_m(x)}$</li>
</ul>
</li>
<li>$F<em>m = F</em>{m-1}+\alpha\times G(x)$</li>
</ul>
</li>
</ul>
</li>
<li>最终学习器:$F(x) = sign(F_m(x)) = sign(\Sigma_m^M \alpha_mG_m(x))$</li>
</ul>
<h3 id="更新公式的推导"><a href="#更新公式的推导" class="headerlink" title="更新公式的推导"></a>更新公式的推导</h3><ul>
<li>Loss function: <ul>
<li>Loss = $\exp(-y<em>i\times[F</em>{m-1}(x)+\alpha_m\times G_m(x)])$<ul>
<li>$= \exp(-y<em>i\times F</em>{m-1}(x))\times\exp(-y_i\times\alpha_m\times G_m(x))$</li>
<li>定义:$W<em>i = \exp(-y_i\times F</em>{m-1}(x))$</li>
<li>$= W_i\times\exp(-y_i\times \alpha_m \times G_m(x))$</li>
</ul>
</li>
<li>故而损失最小化也即:<ul>
<li>$W_i$已知;</li>
<li>$G^*(x) = \alpha<em>m\times G_m(x) = \argmin</em>{\alpha,G(x)}[{\exp(-y_i\times \alpha_m \times G_m(x_i))}]$</li>
<li>由于要在整个训练集上最小化损失,故而要将其期望最小化:<ul>
<li><script type="math/tex; mode=display">E[Loss] = \exp(-\alpha \times y_i \times G_m(x_i))\\ => \exp(-\alpha)\times P(y=G_m(x))+\exp(\alpha)\times P(y != G_m(x))</script><blockquote>
<p>离散型变量的期望求和公式;</p>
</blockquote>
</li>
<li><script type="math/tex; mode=display">-\exp(-\alpha)\times P(y=G_m(x))+\exp(\alpha)\times P(y != G_m(x))==0</script><blockquote>
<p>求导并使其等于0, 从而找到最小点;</p>
</blockquote>
</li>
<li><script type="math/tex; mode=display">\alpha_k = \frac{1}{2}\log{\frac{1-P(y != G_m(x))}{P(y != G_m(x))}}</script><blockquote>
<p>$\alpha$更新公式;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数:"></a>损失函数:</h2><ul>
<li>类型:<ul>
<li>0-1损失:</li>
<li>平方损失:</li>
<li>绝对损失:</li>
<li>对数损失:</li>
</ul>
</li>
<li>直接将(f(x),y)带进Loss函数去算,得到的是单个预测的损失;</li>
<li>我们要验证决策函数f的优良性, 应当求其期望:<ul>
<li>输入输出遵循联合分布P(X,Y),则<strong>期望损失</strong>: <ul>
<li><script type="math/tex; mode=display">R_{exp}(f) = E_P[L(Y,f(X))] = \inf_{\kappa\times y}L(x,f(x))P(x,y)dxdy</script></li>
</ul>
</li>
<li>然而我们无法知道P(X,Y) [这正是我们需要的], 故而我们只能用已知的—训练集的损失, 也即<strong>经验损失</strong>:<ul>
<li><script type="math/tex; mode=display">R_{emp}(f) =\frac{1}{N}\sum_{i=1}{N}L(y_i,f(x_i)</script></li>
</ul>
</li>
<li>根据经验风险最小化求最优:<ul>
<li><script type="math/tex; mode=display">\min_f \in F{\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}}</script></li>
</ul>
</li>
<li>就如同下图, 忽略黑线, 能够直接取到最中心的等值线[最小值];<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-163209.png" alt=""></li>
</ul>
</li>
<li>然而我们在这种情况下求到的只能是过拟合的, 因为根据大数定律, 只有当样本量无穷大的时候,我们才能让经验风险接近期望风险;</li>
<li>我们当然不希望过拟合(这意味着我们得到的模型只是贴近于训练数据集),因此我们要为其加上正则项:<ul>
<li><script type="math/tex; mode=display">R_{srm}(f) =\frac{1}{N}\sum_{i=1}{N}L(y_i,f(x_i)+\lambda J(f)\\ srm = structural risk minimization\\ J(f) = 模型复杂度</script></li>
<li>关于正则化可查看<a href="https://molaison.github.io/2022/11/23/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E5%8C%96/">什么是正则化</a></li>
<li>这时,当结构风险过小,也即模型过于复杂时[含有多个非零参数],第二项模型复杂度会比较大,因而不会被选取;</li>
</ul>
</li>
</ul>
</li>
<li>泛化误差: 刚才我们讲到的是对于训练数据集的风险, 最小化其得到模型f,用这个模型去预测没被用来训练的数据, 就可以得到泛化误差:<ul>
<li><script type="math/tex; mode=display">R_{exp}(\hat{f}(X)) = E_P[L(Y,\hat{f}(X)] = \inf_{\kappa\times y}L(x\hat{f}(X))P(x,y)dxdy</script></li>
<li>泛化误差也叫out of sample error,因为是经过最小化风险得到的模型, 参数已然确立, 相当于测定模型离真实值的偏离程度;</li>
</ul>
</li>
</ul>
<h2 id="正则化作用"><a href="#正则化作用" class="headerlink" title="正则化作用:"></a>正则化作用:</h2><ul>
<li>L1正则化: $\alpha||w||_1$, 1-范数<ul>
<li>权值向量各个元素的绝对值之和</li>
<li>作用: <ul>
<li>偏向于让权值向量在优化过程中接近于0,即变得稀疏;</li>
</ul>
</li>
<li>原理:</li>
</ul>
</li>
<li>L2正则化: $||\alpha||w||_2^2$, 2-范数的平方<ul>
<li>权值向量各个元素平方和的平方根</li>
<li>作用:<ul>
<li>对于大数值的权值向量进行惩罚, 从而更偏向分散的权重向量;[也即使用更多特征,从而能够减少过拟合]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><ul>
<li>我们求解实质上是优化问题, 最小化loss;</li>
<li>正则化相当于在我们优化的过程中添加了限定条件, 如<ul>
<li>等值限定条件:<ul>
<li><script type="math/tex; mode=display">\begin{align*}&min \quad f(x)\\ & s.t. \quad h(x) = 0\end{align*}</script></li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-163209.png" alt=""></li>
<li>如果不添加该限定条件, 那么应当按照f(x)的极值点来求, 也即是找到$\frac{\partial{f(x)}}{\partial{x}} = 0$的点;</li>
<li>但是由于$h(x)=0$这一条件的存在, 我们只能选择在上图黑线上的点, 由等值线可知, 越往圈内越小, 故最小值在图中相切处取得;<ul>
<li>也只能在相切处取得, 因为若是相交, 则说明:<ul>
<li>往圈内走还有别的取值线与之相交, 也即是说:</li>
<li>沿着圈向内还能取到更小值;</li>
</ul>
</li>
</ul>
</li>
<li>所以也就是说, 对于f(x)和h(x)而言, 在相切的地方, 两个函数的梯度一定在同一条直线上, 可以表示为:<ul>
<li><script type="math/tex; mode=display">\nabla f(x) = \lambda \times \nabla h(x)...(1)</script></li>
</ul>
</li>
<li>变化一下式子:<ul>
<li><script type="math/tex; mode=display">\nabla f(x) +\lambda \times \nabla h(x) = 0...(2)</script></li>
</ul>
</li>
<li>这就又回到了起点, 我们再对$\lambda,x,y$分别求偏导, 并使偏导等于0, 再解方程组即可;</li>
<li>那么对于多个约束的情况呢?<ul>
<li>上面我们得到了:<ul>
<li><script type="math/tex; mode=display">G(x) = \nabla f(x) +\lambda \times \nabla h(x) = 0...(3)</script></li>
</ul>
</li>
<li>再加一个约束$h_2(x)=0$, 也无非是:<ul>
<li><script type="math/tex; mode=display">\nabla G(x) +\lambda_2 \times \nabla h(x) = 0...(4)</script></li>
</ul>
</li>
<li>再多来点也无非是:<ul>
<li><script type="math/tex; mode=display">L(x,\lambda)=f(x)+\sum_{i-1}^{n}\lambda_{i}\nabla h_{i}(x)...(5)</script></li>
</ul>
</li>
<li>然后对$\lambda_i,x$求偏导, 使其等于0;</li>
</ul>
</li>
<li>对于等式约束和不等式约束混合:<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/27/20221127-141109.png" alt=""></li>
<li>又要分为两个情况:<ul>
<li>由于一个在可行域内部的h(x)上的点, 如果他不是f(x)的极值点[下图左], 那么除非h(x)在该点处与等值线相切,并且位于边界处,就能够沿着h(x)在可行域内找到f(x)更小的点;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-183224.png" alt=""></li>
</ul>
</li>
<li>因此实质上只有两种情况:<ul>
<li>上图右:在 h(x) 和 等值线相切的地方[并且是边界处]<ul>
<li><script type="math/tex; mode=display">\nabla f(x)+\lambda \nabla h(x)+\mu \nabla g(x) = 0\\ h(x)=0\\ g(x)=0\\ \mu \geq 0...(6)</script></li>
<li>由图可知, 越往外值越大, 故而g(x)的梯度方向是向外的, 而f(x)的极小值点在中间, 也即其梯度是向内的;</li>
<li>所以二者梯度相反, 所以对应(1)式中$\lambda&lt;0$, 变化为(2)的形式后自然大于0了;</li>
</ul>
</li>
<li>上图左:f(x) 的极值点本身就在可行域里面。<ul>
<li>等于没有不等式约束;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用松弛变量的方法引入:<ul>
<li>将$g(w_i)&lt;0$变为 $h(w_i) = g(w_i)+a_i^2 =0$, 再作为无约束优化求解:</li>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/27/20221127-142102.png" alt=""></li>
<li>λ为什么大于0?<ul>
<li>同上面集合方法的证明;</li>
</ul>
</li>
<li>对于$\lambda\times a_i = 0$,有两种情形(对应上面)<ul>
<li>情形1:$\lambda_i=0,a_i\neq 0$<ul>
<li>$\lambda_i=0$, 相当于没有约束</li>
</ul>
</li>
<li>情形2:$\lambda_i\neq0,a_i=0$<ul>
<li>此时$g_i(w) = 0$,且$\lambda_i&gt;0$;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何在一个方程里面显示出来:[也就是KKT条件]<ul>
<li><script type="math/tex; mode=display">\nabla f(x)+\lambda \nabla h(x)+\mu \nabla g(x) = 0\\ \mu g(x) = 0\\ \mu \geq 0 \\ h(x)=0\\ g(x) \leq 0...()</script></li>
<li>这个优化问题的极值点一定满足这组方程组。</li>
<li>不是极值点也可能会满足，但是不会存在某个极值点不满足的情况;</li>
<li>也即该优化问题取得极值的必要条件;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>回到L1,L2正则化, 我们可以用只有两个权值w1,w2的模型作为例子;<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-191241.png" alt=""></li>
<li>对于L1正则化(右图):<ul>
<li>它将原本在整个坐标系的解空间, 限制到了方形的边缘上(不等式限制$w_1+w_2\le C$)</li>
<li>而等值线与菱形端点相交的概率要大很多, 所以会有权值在最优时取到0(端点位于坐标轴上),至于为什么概率会更大:<ul>
<li>在不加约束的条件下, loss函数中心的位置落于红色区域,则等值线与端点相交[取一个点,灵活半径画圆,总是最先碰到端点];<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-193528.png" alt=""></li>
</ul>
</li>
<li>将图线不断延伸, 即可发现红色区域面积远大于白色区域[或许截个圆比较合适]</li>
</ul>
</li>
</ul>
</li>
<li>对于L2正则化(左图), 圆形区域对于任意极值点, 边缘上每个点被取到的概率都一样;<blockquote>
<p>设输入向量x=[1, 1, 1, 1]，两个权重向量$w_1=[1, 0, 0, 0]，w_2=[0.25, 0.25, 0.25, 0.25]$。那么$w_1^T<em>x=1,w_2^T</em>x=1$，两个权重向量都得到同样的内积，但是w1的L2惩罚是1.0，而w2的L2惩罚是0.25.因此，根据L2惩罚来看，w2更好，因为它的正则化损失更小。从直观上来看，这是因为w2的权重值更小且更分散。所以L2正则化倾向于是特征分散，更小。 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数:"></a>损失函数:</h3><ul>
<li>类型:<ul>
<li>0-1损失:</li>
<li>平方损失:</li>
<li>绝对损失:</li>
<li>对数损失:</li>
</ul>
</li>
<li>直接将(f(x),y)带进Loss函数去算,得到的是单个预测的损失;</li>
<li>我们要验证决策函数f的优良性, 应当求其期望:<ul>
<li>输入输出遵循联合分布P(X,Y),则<strong>期望损失</strong>: <ul>
<li><script type="math/tex; mode=display">R_{exp}(f) = E_P[L(Y,f(X))] = \inf_{\kappa\times y}L(x,f(x))P(x,y)dxdy</script></li>
</ul>
</li>
<li>然而我们无法知道P(X,Y) [这正是我们需要的], 故而我们只能用已知的—训练集的损失, 也即<strong>经验损失</strong>:<ul>
<li><script type="math/tex; mode=display">R_{emp}(f) =\frac{1}{N}\sum_{i=1}{N}L(y_i,f(x_i)</script></li>
</ul>
</li>
<li>根据经验风险最小化求最优:<ul>
<li><script type="math/tex; mode=display">\min_f \in F{\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}}</script></li>
</ul>
</li>
<li>就如同下图, 忽略黑线, 能够直接取到最中心的等值线[最小值];<ul>
<li><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/IMG/2022/11/23/20221123-163209.png" alt=""></li>
</ul>
</li>
<li>然而我们在这种情况下求到的只能是过拟合的, 因为根据大数定律, 只有当样本量无穷大的时候,我们才能让经验风险接近期望风险;</li>
<li>我们当然不希望过拟合(这意味着我们得到的模型只是贴近于训练数据集),因此我们要为其加上正则项:<ul>
<li><script type="math/tex; mode=display">R_{srm}(f) =\frac{1}{N}\sum_{i=1}{N}L(y_i,f(x_i)+\lambda J(f)\\ srm = structural risk minimization\\ J(f) = 模型复杂度</script></li>
<li>关于正则化可查看<a href="https://molaison.github.io/2022/11/23/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E5%8C%96/">什么是正则化</a></li>
<li>这时,当结构风险过小,也即模型过于复杂时[含有多个非零参数],第二项模型复杂度会比较大,因而不会被选取;</li>
</ul>
</li>
</ul>
</li>
<li>泛化误差: 刚才我们讲到的是对于训练数据集的风险, 最小化其得到模型f,用这个模型去预测没被用来训练的数据, 就可以得到泛化误差:<ul>
<li><script type="math/tex; mode=display">R_{exp}(\hat{f}(X)) = E_P[L(Y,\hat{f}(X)] = \inf_{\kappa\times y}L(x\hat{f}(X))P(x,y)dxdy</script></li>
<li>泛化误差也叫out of sample error,因为是经过最小化风险得到的模型, 参数已然确立, 相当于测定模型离真实值的偏离程度;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记: From Principles to Cases</title>
    <url>/2023/07/19/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-From-Principles-to-Cases/</url>
    <content><![CDATA[<h3 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h3><p>Git是一个分布式版本控制系统，由Linux内核创始人Linus Torvalds于2005年开发。相较于集中式版本控制系统，Git的分布式特性使得团队成员可以在本地独立地进行代码开发，不再依赖于中央服务器的稳定性和网络连接。这为团队协作带来了巨大的便利，同时也为个人开发者提供了强大的版本管理能力。</p>
<p>在本篇博客中，我们将深入探讨Git的使用方法，带你了解Git如何帮助你高效地管理代码版本。无论你是刚刚接触Git还是想深入了解其高级功能，这篇指南都将为你提供全面的帮助。</p>
<p>接下来，我们将一步步学习如何安装和配置Git，并介绍Git的基本概念，例如仓库、提交、分支等。随后，我们将探讨常用的Git工作流程，涵盖从创建新功能分支到合并代码的全过程。同时，我们还将了解如何处理代码冲突、回滚错误提交以及优化Git操作，使你在日常开发中更加游刃有余。</p>
<p>Git是一个功能强大而灵活的工具，但也可能会让初学者感到有些复杂。但不用担心，本篇博客将以简洁明了的语言，结合实例演示，带你逐步掌握Git的精髓。让我们一起开始，成为Git版本控制的高手吧！</p>
<h3 id="基本流程：Git工作流"><a href="#基本流程：Git工作流" class="headerlink" title="基本流程：Git工作流"></a>基本流程：Git工作流</h3><p>当学习Git时，建议按照以下顺序逐步掌握各个命令：</p>
<ol>
<li><p>git init：创建一个新的空白仓库或在现有目录中初始化一个Git仓库。</p>
</li>
<li><p>git add：将文件添加到暂存区，准备进行提交。</p>
</li>
<li><p>git commit：将暂存区中的文件提交到本地仓库，创建一个新的版本。</p>
</li>
<li><p>git status：查看当前仓库状态，包括已修改和未跟踪的文件。</p>
</li>
<li><p>git diff：查看未暂存文件与最后一次提交之间的差异。</p>
</li>
<li><p>git log：查看提交历史，包括提交者、日期和提交信息。</p>
</li>
<li><p>git checkout：切换分支或恢复文件，可以用于创建新分支。</p>
</li>
<li><p>git branch：查看、创建和删除分支。</p>
</li>
<li><p>git merge：将一个分支的更改合并到另一个分支。</p>
</li>
<li><p>git remote：连接远程仓库，可以添加、重命名和删除远程仓库。</p>
</li>
<li><p>git pull：从远程仓库拉取并合并更改到本地仓库。</p>
</li>
<li><p>git push：将本地仓库的更改推送到远程仓库。</p>
</li>
<li><p>git clone：克隆远程仓库到本地，用于初始化一个新的本地仓库。</p>
</li>
<li><p>git fetch：从远程仓库拉取代码，但不合并到本地仓库。</p>
</li>
<li><p>git reset：撤销提交，将HEAD指向之前的提交，并可选择保留或丢弃更改。</p>
</li>
<li><p>git revert：撤销指定的提交，并创建一个新的提交来反转更改。</p>
</li>
<li><p>git stash：将当前工作目录的更改保存在临时区域，以便稍后恢复。</p>
</li>
<li><p>git tag：创建、列出和删除标签，用于标记重要的提交或版本。</p>
</li>
</ol>
<h3 id="基本用法：案例"><a href="#基本用法：案例" class="headerlink" title="基本用法：案例"></a>基本用法：案例</h3><p>步骤1：初始化仓库和第一个提交</p>
<p>首先，我们创建一个新的空目录，进入该目录，并初始化Git仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-web-app</span><br><span class="line"><span class="built_in">cd</span> my-web-app</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>接下来，在该目录下创建一个简单的HTML文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Web App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，将该文件添加到暂存区并提交第一个版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit: Created index.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>步骤2：创建并切换分支</p>
<p>我们决定在项目中添加一个新的功能，为此，我们需要创建一个新的分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch feature/add-about-page</span><br><span class="line">git checkout feature/add-about-page</span><br></pre></td></tr></table></figure>
<p>或者可以使用一条命令来创建并切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature/add-about-page</span><br></pre></td></tr></table></figure>
<p>现在，我们在<code>index.html</code>文件中添加一个“关于”页面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Web App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后添加并提交这些更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br><span class="line">git commit -m <span class="string">&quot;Added About page link&quot;</span></span><br></pre></td></tr></table></figure>
<p>步骤3：合并分支</p>
<p>在添加了“关于”页面之后，我们决定将这个功能合并回主分支。</p>
<p>首先，切换回主分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure>
<p>然后将<code>feature/add-about-page</code>分支合并到<code>main</code>分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge feature/add-about-page</span><br></pre></td></tr></table></figure>
<p>步骤4：部署项目</p>
<p>现在，我们已经完成了项目的开发并将功能合并回主分支。接下来，我们可以将项目部署到服务器或托管平台上。</p>
<p>这里假设我们将代码托管在GitHub上。首先，我们将远程仓库与本地仓库关联。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;GitHub仓库URL&gt;</span><br></pre></td></tr></table></figure>
<p>然后将代码推送到远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>至此，我们的简单Git案例就完成了，包括了从初始化仓库到创建和合并分支，并最后将代码推送到远程仓库的过程。</p>
<h3 id="提交：commit-命名规范"><a href="#提交：commit-命名规范" class="headerlink" title="提交：commit 命名规范"></a>提交：commit 命名规范</h3><p>遵循一致的命名规范可以使提交历史更加清晰、易于理解和管理。以下是一些建议的Git <code>commit</code>命名规范：</p>
<ol>
<li><p>使用简洁明了的描述：每个<code>commit</code>的标题应该简洁明了地描述此次提交所做的更改。尽量避免冗长的标题。</p>
</li>
<li><p>使用现在时态：提交标题通常使用现在时来描述一个动作或更改，例如：”Add feature”, “Fix bug”等。</p>
</li>
<li><p>使用动词开头：在标题中使用动词开头，说明这次提交所做的主要操作。常见的动词有：”Add”（新增）、”Update”（更新）、”Fix”（修复）、”Remove”（删除）等。</p>
</li>
<li><p>分离主题和描述：提交标题与提交描述之间使用一个空行进行分隔，提交描述可以进一步补充说明本次提交的详细信息。</p>
</li>
<li><p>参考项目规范：如果你在一个团队或项目中工作，请遵循项目的提交规范。许多团队会有特定的提交规范，例如Angular的规范（Angular Commit Message Guidelines）。</p>
</li>
<li><p>使用标签：可以在标题中使用标签来更好地标识提交类型，如”[Feature]“, “[Bugfix]“, “[Docs]“, “[Refactor]“等。</p>
</li>
</ol>
<p>可以参考以下案例：</p>
<ul>
<li>添加新功能：<br><code>Add user authentication feature</code></li>
<li>修复Bug：<br><code>Fix login page alignment issue</code></li>
<li>更新文档：<br><code>Docs: Update README with installation instructions</code></li>
<li>重构代码：<br><code>Refactor: Improve performance of data processing</code></li>
</ul>
<p>其中，<code>commit</code>的类型至关重要，能够将我们的提交很好地分门别类。</p>
<ol>
<li><strong>feat（Feature）</strong>：添加新功能或特性。</li>
<li><strong>fix（Bugfix）</strong>：修复Bug或错误。</li>
<li><strong>docs（Documentation）</strong>：更新文档，如README、注释等。</li>
<li><strong>style</strong>：对代码样式进行调整，如缩进、空格、格式等，不影响代码逻辑。</li>
<li><strong>refactor</strong>：重构代码，优化代码结构、提高性能，不是Bug修复，也不是添加新功能。</li>
<li><strong>test</strong>：添加或修改测试用例、测试代码。</li>
<li><strong>chore</strong>：对构建过程或辅助工具的修改。</li>
<li><strong>perf（Performance）</strong>：改善代码性能的提交。</li>
<li><strong>build</strong>：修改项目构建相关的内容，如更新依赖、修改构建脚本等。</li>
<li><strong>revert</strong>：撤销之前的提交。</li>
<li><strong>merge</strong>：合并分支或解决合并冲突。</li>
<li><strong>init</strong>：初始化项目。</li>
<li><strong>dependencies</strong>：更新或修改项目依赖的外部库或工具。</li>
<li><strong>security</strong>：涉及安全性的提交，如修复安全漏洞。</li>
</ol>
<p>然而，我们有时仍然会忘记，或者偷懒而没有遵循提交的规范，这会给后期查看代码带来麻烦。而Commitizen是一个用于规范化Git提交消息的工具，旨在帮助团队成员更好地遵循一致的提交规范。它提供了一个交互式的命令行界面，引导用户填写提交信息，并根据预定义的提交规范生成规范化的提交消息。使用方法如下：</p>
<ol>
<li>安装：<code>-g commitizen</code>表示全局安装；<code>cz-conventional-changelog</code>为项目配置Commitizen适配器，最常用的适配器cz-conventional-changelog（约定式提交适配器）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure></li>
<li>在项目根目录下创建一个<code>.czrc</code>文件，指定使用的适配器：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cz-conventional-changelog&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>git cz</code>命令代替<code>git commit</code>来进行提交，然后按照交互式界面的提示填写提交信息。</li>
</ol>
<h3 id="命令详解：parameter-level-explanation"><a href="#命令详解：parameter-level-explanation" class="headerlink" title="命令详解：parameter-level explanation"></a>命令详解：parameter-level explanation</h3><h4 id="GIT-BRANCH-分支操作"><a href="#GIT-BRANCH-分支操作" class="headerlink" title="GIT BRANCH: 分支操作"></a>GIT BRANCH: 分支操作</h4><p><code>git branch</code> 是用于管理Git分支的命令，用于查看、创建、删除、重命名和切换分支。以下是<code>git branch</code>命令的常用参数及其作用：</p>
<ol>
<li><p><strong>不带参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>作用：查看当前仓库中的所有分支，并在当前分支前面添加一个星号<code>*</code>标识当前所在的分支。</p>
</li>
<li><p><strong><branch_name>：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>
<p>作用：创建一个新的分支，名称为<code>&lt;branch_name&gt;</code>。</p>
</li>
<li><p><strong>-d / —delete <branch_name>：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>
<p>作用：删除指定的分支，如果分支未合并到其他分支，则会警告；如果确定要删除，可以使用 <code>-D</code> 参数进行强制删除。</p>
</li>
<li><p><strong>-m / —move <old_branch_name> <new_branch_name>：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</span><br></pre></td></tr></table></figure>
<p>作用：重命名分支，将 <code>&lt;old_branch_name&gt;</code> 改为 <code>&lt;new_branch_name&gt;</code>。</p>
</li>
<li><p><strong>-M</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -M &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>作用：执行 <code>git branch -M main</code> 命令后，将会发生以下操作：你的默认分支将变成 <code>main</code>，并且原先的默认分支（如果存在）的更改将被保存在新的 <code>main</code> 分支上。</p>
</li>
<li>如果当前仓库的默认分支不是 <code>main</code>，Git 会将默认分支的名称更改为 <code>main</code>。</li>
<li><p>如果 <code>main</code> 分支已经存在，则将当前所在的分支（当前分支）重命名为 <code>main</code>，并且该操作是强制性的（因此使用了 <code>-M</code> 参数）。</p>
</li>
<li><p><strong>-r / —remotes：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<p>作用：显示远程分支。</p>
</li>
<li><p><strong>-a / —all：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>作用：显示所有本地和远程分支。</p>
</li>
<li><p><strong>-v / —verbose：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<p>作用：显示每个分支的最后一次提交信息。</p>
</li>
<li><p><strong>-vv：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<p>作用：显示每个分支的最后一次提交信息，并显示跟踪的远程分支。</p>
</li>
<li><p><strong>—no-color：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --no-color</span><br></pre></td></tr></table></figure>
<p>作用：在输出中禁用颜色。</p>
</li>
</ol>
<h4 id="GIT-ADD-加入暂存"><a href="#GIT-ADD-加入暂存" class="headerlink" title="GIT ADD: 加入暂存"></a>GIT ADD: 加入暂存</h4><p><code>git add</code> 是用于将工作目录中的文件更改添加到暂存区（Staging Area），准备提交到版本库。<code>git add</code> 命令有多个参数可以控制添加文件的方式。以下是常用的 <code>git add</code> 参数及其作用：</p>
<ol>
<li><p><strong>文件名：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>作用：将指定的文件 <code>&lt;file&gt;</code> 添加到暂存区。</p>
</li>
<li><p><strong>目录名：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>作用：将指定目录下的所有文件（包括子目录）添加到暂存区。</p>
</li>
<li><p><strong>-A / —all：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<p>作用：将所有更改（包括新文件、修改和删除）添加到暂存区。相当于 <code>git add .</code> 和 <code>git add -u</code> 的合并效果。</p>
</li>
<li><p><strong>-u / —update：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure>
<p>作用：将所有修改和新文件（不包括删除）添加到暂存区。不会添加新的未追踪文件。</p>
</li>
<li><p><strong>-p / —patch：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure>
<p>作用：交互式地选择要添加到暂存区的文件内容，可以选择部分修改并排除其他部分。</p>
<ol>
<li><code>y</code>：表示将当前修改块添加到暂存区。</li>
<li><code>n</code>：表示不将当前修改块添加到暂存区。</li>
<li><code>s</code>：表示将当前修改块分割成更小的块。譬如一个文件中，修改了多次，可以将每一个不同的更改分开来选择添加或修改</li>
<li><code>e</code>：表示手动编辑当前修改块。</li>
<li><code>q</code>：表示退出 <code>git add -p</code> 命令。</li>
<li><code>a</code>：表示将当前的显示的<code>修改</code>添加到暂存区。由于多个文件中的修改是逐个显示的，可以理解为<code>show next one</code>;</li>
</ol>
</li>
<li><p><strong>-i / —interactive：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>
<p>作用：以交互式的方式添加文件，可以选择添加、忽略或取消添加。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230720185654.png" alt=""><br>其中, 第一个表格展示了修改的状态, <code>Commands</code>展示了可输入的命令，可以通过输入<code>序号</code>或<code>首字母</code>来调用该命令。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230720190050.png" alt=""><br>我们修改了<code>test2</code>，随后<code>unstaged</code>栏有更新, 此时我们输入命令<code>2</code>或<code>u</code>，命令前缀符变为Update，即命令名称时，会出现选项选择要操作的文件对象，输入<code>1</code>选中一个，随后回车选中这一个文件，文件行前出现星号<code>*</code>。但此时并不会执行，如果继续输入序号，仍然会继续选中。直到我们直接输入回车。</p>
</li>
<li><p><strong>—intent-to-add：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --intent-to-add</span><br></pre></td></tr></table></figure>
<p>作用：将新创建但尚未添加的文件添加到暂存区。这对于标记即将添加的文件非常有用。</p>
</li>
<li><p><strong>—renormalize：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --renormalize</span><br></pre></td></tr></table></figure>
<p>作用：将已经跟踪的文件重新标记为未标准化状态，并添加到暂存区。文件在 Git 中被保存为对象，并在存储库中进行压缩，其中某些文件在保存时可能会被转换为特定的格式（例如换行符或空格的处理）。在一些情况下，可能需要更改这些转换规则，以便 Git 在存储库中正确地保存文件。</p>
</li>
</ol>
<h4 id="GIT-COMMIT-提交至本地版本库"><a href="#GIT-COMMIT-提交至本地版本库" class="headerlink" title="GIT COMMIT: 提交至本地版本库"></a>GIT COMMIT: 提交至本地版本库</h4><p><code>git commit</code> 命令用于将暂存区中的文件更改提交到本地版本库，并生成一个新的提交（commit）。</p>
<ol>
<li><p><strong>-m \<message\> / —message=\<message\>：</strong><br>作用：用于指定提交的消息（commit message），即提交的描述信息。消息应该简洁明了，描述本次提交的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Add new feature&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-a / —all：</strong><br>作用：自动将所有已跟踪文件的更改提交到本地版本库，==跳过 <code>git add</code> 步骤==。未跟踪的文件不会被提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">&quot;Fix bugs&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-v / —verbose：</strong><br>作用：在提交消息中显示 diff 信息，即显示每个更改的具体内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -v -m <span class="string">&quot;Update documentation&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>—amend：</strong><br>作用：修改最近一次提交的内容，将新的更改合并到该提交中。这个参数可以在忘记提交某些更改或修改了错误的提交消息时使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">&quot;Fix typo&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，如果你已经推送（push）了上一次的提交到远程仓库，修改提交消息后，最好不要再次推送，除非你确定这个操作不会影响其他开发者的工作。因为 <code>git commit --amend</code> 实际上是对历史提交进行修改，会改变提交的 SHA-1 值，如果将修改后的提交推送到远程仓库，可能会导致其他开发者的工作出现问题。</p>
</blockquote>
</li>
</ol>
<h4 id="GIT-STATUS-查看当前track状态"><a href="#GIT-STATUS-查看当前track状态" class="headerlink" title="GIT STATUS: 查看当前track状态"></a>GIT STATUS: 查看当前track状态</h4><p><code>git status</code> 是用于查看当前工作目录的状态和变更的命令。它会显示当前分支的状态，包括已修改、已暂存、未跟踪等文件的信息。以下是 <code>git status</code> 命令的详细用法和每个参数的介绍：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status [&lt;options&gt;] [--] [&lt;pathspec&gt;...]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>无参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>作用：显示当前分支的状态，包括已修改、已暂存、未跟踪的文件信息。</p>
</li>
<li><p><strong>-s / —short：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure>
<p>作用：以更简洁的格式显示状态信息。使用这个参数，状态的输出将被缩短并显示为两列。</p>
</li>
<li><p><strong>-b / —branch：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -b</span><br></pre></td></tr></table></figure>
<p>作用：显示分支的状态，包括本地分支和与之关联的远程跟踪分支。</p>
</li>
<li><p><strong>-v / —verbose：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -v</span><br></pre></td></tr></table></figure>
<p>作用：显示详细的状态信息，包括修改的文件内容和行数的变化。</p>
</li>
<li><p>-u[\<mode\>] / —untracked-files[\=\<mode\>]：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -u</span><br></pre></td></tr></table></figure>
<p>作用：显示未跟踪文件的状态。<code>&lt;mode&gt;</code> 参数可以是 <code>no</code>、<code>normal</code> 或 <code>all</code>，分别表示不显示、显示普通未跟踪文件和显示所有未跟踪文件。</p>
</li>
<li><p><strong>—ignored：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure>
<p>作用：显示被忽略的文件的状态。</p>
</li>
<li><p><strong>—no-renames：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status --no-renames</span><br></pre></td></tr></table></figure>
<p>作用：在状态中不显示重命名/复制的文件。</p>
</li>
<li><p><strong>—column[\=\<style\>]：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status --column</span><br></pre></td></tr></table></figure>
<p>作用：以栏格式显示状态，以更好地对齐文件名和状态。</p>
</li>
<li><p><strong>—ahead-behind：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status --ahead-behind</span><br></pre></td></tr></table></figure>
<p>作用：在与远程分支比较时，显示本地分支的提交落后或领先的提交数。</p>
</li>
</ul>
<h4 id="GIT-DIFF：看看改了什么"><a href="#GIT-DIFF：看看改了什么" class="headerlink" title="GIT DIFF：看看改了什么"></a>GIT DIFF：看看改了什么</h4><ol>
<li><strong><code>git diff</code>：</strong> 作用：比较工作目录中尚未暂存的更改与最后一次提交之间的差异。</li>
<li><strong><code>git diff &lt;commit&gt;</code>：</strong> 作用：比较工作目录中尚未暂存的更改与指定提交 <code>&lt;commit&gt;</code> 之间的差异。可以使用提交的 SHA-1 或分支名等来指定 <code>&lt;commit&gt;</code>。</li>
<li><strong><code>git diff &lt;commit&gt; &lt;commit&gt;</code>：</strong> 作用：比较两个提交 <code>&lt;commit&gt;</code> 之间的差异。可以使用提交的 SHA-1 或分支名等来指定 <code>&lt;commit&gt;</code>。</li>
<li><strong><code>git diff --cached</code> 或 <code>git diff --staged</code>：</strong> 作用：比较==暂存区（Staging Area）==中尚未提交的更改与最后一次提交（或是指定commit进行比较）之间的差异。即比较已暂存的更改与最后一次提交之间的差异。</li>
</ol>
<p>如何分析一个git diff的结果:<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230721090901.png" alt=""></p>
<ul>
<li><code>a/file.txt</code> 和 <code>b/file.txt</code>：文件在变化之前和之后的路径。</li>
<li><code>&lt;旧提交哈希&gt;</code> 和 <code>&lt;新提交哈希&gt;</code>：文件的上一个版本和当前版本的提交哈希。</li>
<li><code>&lt;模式&gt;</code>：文件的模式信息（例如，<code>100644</code> 表示普通文件）。</li>
<li><code>@@ -5,7 +5,7 @@</code>：该行指示了文件变化的上下文。</li>
<li><code>-This line was removed</code>：这是一个被删除的行。</li>
<li><code>+This line was added</code>：这是一个被添加的行。</li>
</ul>
<h4 id="GIT-LOG：TIMELINE"><a href="#GIT-LOG：TIMELINE" class="headerlink" title="GIT LOG：TIMELINE"></a>GIT LOG：TIMELINE</h4><p><code>git log</code> 是 Git 中一个用于查看提交历史的强大命令。它用于显示项目中的提交记录，按照提交时间的先后顺序排列。</p>
<ol>
<li><p><strong>基本用法：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>这会显示从最新到最旧的提交记录列表。默认情况下，会显示每个提交的哈希值（commit hash）、作者（author）、日期、和提交信息（commit message）。</p>
</li>
<li><p><strong>显示提交内容变更：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p</span><br></pre></td></tr></table></figure>
<p>使用 <code>-p</code> 或 <code>--patch</code> 参数，可以显示每个提交的详细内容变更（diff），包括哪些文件被修改以及具体的修改内容。</p>
</li>
<li><p><strong>单行显示提交记录：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--oneline</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--oneline</code> 参数，可以以单行的格式显示每个提交记录，只显示提交哈希值和提交信息，更加简洁。</p>
</li>
<li><p><strong>显示作者统计：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--author=&lt;author_name&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--author=&lt;author_name&gt;</code> 参数，可以过滤并只显示指定作者的提交记录。</p>
</li>
<li><p><strong>按照提交时间排序：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--date=short</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--date=short</code> 参数，可以以简洁日期格式显示提交记录，并按照提交时间排序。</p>
</li>
<li><p><strong>显示分支合并情况：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--graph</code> 参数，可以显示提交历史的分支合并情况图。<br>可以和<code>--pretty=format</code>联用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示指定文件的提交历史：</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span> <span class="variable">&lt;file_path&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 命令后面加上指定文件的路径，可以<strong>仅显示该文件的提交历史</strong>。</p>
</li>
<li><p><strong>显示指定范围的提交历史：</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span> <span class="variable">&lt;commit_range&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 命令后面加上两个提交之间的范围，可以显示在这个范围内的提交历史。范围的格式可以是单个提交哈希、分支名，或者是提交范围（例如：<code>master..develop</code>）。<br>在Git中，<code>git log</code>命令用于查看版本历史和提交日志。通过提供一个提交范围（commit_range），您可以仅查看该范围内的提交记录。提交范围可以指定一个或多个提交，以便从其中筛选出相应的提交历史。</p>
<ol>
<li>单个提交（Single Commit）：您可以指定一个具体的提交哈希（commit hash）或提交引用（例如分支名、标签名）来查看该提交的日志。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;commit_hash&gt;</span><br><span class="line">git <span class="built_in">log</span> &lt;branch_name&gt;</span><br><span class="line">git <span class="built_in">log</span> &lt;tag_name&gt;</span><br></pre></td></tr></table></figure></li>
<li>范围提交（Commit Range）：您可以通过使用两个提交引用，创建一个范围，来查看这两个提交之间的所有提交。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;commit_ref1&gt;..&lt;commit_ref2&gt;</span><br></pre></td></tr></table></figure>
在上述命令中，<code>&lt;commit_ref1&gt;</code>是范围的起始提交引用，<code>&lt;commit_ref2&gt;</code>是范围的结束提交引用。范围是包含 <code>&lt;commit_ref1&gt;</code> 提交但不包含 <code>&lt;commit_ref2&gt;</code> 提交的所有提交。</li>
<li>引用与父提交（Reference with Parent Commit）：您可以使用波浪符（<code>~</code>）后跟一个数字，来查看某个提交的父提交。例如，<code>HEAD~2</code>表示HEAD提交的第二个父提交。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;commit_ref&gt;~&lt;number&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>时间范围</strong>: 使用 <code>--since</code> 和/或 <code>--until</code> 参数来指定时间范围内的提交。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=&lt;<span class="built_in">date</span>&gt; --until=&lt;<span class="built_in">date</span>&gt;</span><br></pre></td></tr></table></figure>
其中<code>&lt;date&gt;</code>是日期时间的格式，例如：<code>&quot;2023-01-01&quot;</code>。</li>
<li><strong>作者过滤</strong>: 使用 <code>--author</code> 参数按作者筛选提交。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=&lt;author_name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>限制显示的提交数量：</strong><br>使用 <code>-n &lt;num&gt;</code> 参数，可以限制只显示最近的 <code>&lt;num&gt;</code> 条提交记录。</p>
</li>
<li><p><strong>显示某个提交之前的历史记录：</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span> <span class="variable">&lt;commit_hash&gt;</span>~</span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;commit_hash&gt;~</code> 表示显示某个提交之前的历史记录，其中 <code>~</code> 表示父提交。</p>
</li>
<li><p><strong>显示某个提交之后的历史记录：</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span> <span class="variable">&lt;commit_hash&gt;</span>..</span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;commit_hash&gt;..</code> 表示显示某个提交之后的历史记录。</p>
</li>
<li><p><strong>自定义输出格式：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=&lt;format&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--pretty=&lt;format&gt;</code> 参数，可以自定义输出的格式。例如，<code>--pretty=format:&quot;%h - %an, %ar : %s&quot;</code> 将以特定格式显示提交的哈希（<code>%h</code>）、作者名（<code>%an</code>）、提交日期（<code>%ad</code>）和提交信息（<code>%s</code>）。也可使用<code>--pretty=oneline</code>，等价于<code>--oneline</code>。</p>
<p>也可以使用其他选项：<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230721204802.png" alt=""></p>
</li>
<li><p><strong>显示变更的简要统计：</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--stat</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--stat</code> 参数，可以显示每个提交的简要统计信息，包括文件改动数量和行数的增减。==这一命令加上 —date=short 参数效果更佳。==</p>
</li>
<li><p><strong>汇总多个开发者提交</strong>：<br><code>git shortlog</code>是Git的一个命令，用于生成简洁的提交统计报告，以作者为单位汇总提交信息。它可以快速显示每个作者所提交的提交数目，以及他们的提交信息摘要。</p>
</li>
</ol>
<h4 id="GIT-CHECKOUT-在提交节点间跳跃"><a href="#GIT-CHECKOUT-在提交节点间跳跃" class="headerlink" title="GIT CHECKOUT:  在提交节点间跳跃"></a>GIT CHECKOUT:  在提交节点间跳跃</h4><p><code>git checkout</code> 命令在 Git 中是一个非常常用且功能丰富的命令。它主要用于切换分支，恢复文件或撤销更改。</p>
<ol>
<li><p><strong>切换分支：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout <span class="tag">&lt;<span class="name">branch_name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是 <code>git checkout</code> 最常用的用法之一。它允许你切换到指定的分支，并将工作目录和索引设置为该分支的最新状态。</p>
</li>
<li><p><strong>创建新分支并切换：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="tag">&lt;<span class="name">new_branch_name</span>&gt;</span> [<span class="tag">&lt;<span class="name">starting_point</span>&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>这个用法将创建一个新的分支，并将 HEAD 指向该分支。<strong>如果提供了 <code>&lt;starting_point&gt;</code> 参数，新分支将从指定的提交、分支或标签开始。</strong></p>
<p> <code>-B</code>参数，是<code>-b</code>的强制模式。当要创建的分支已然存在时，会出现<code>fatal: A branch named &#39;feature/add-about-page&#39; already exists.</code>错误。而<code>-B</code>命令则会强制创建该分支，用新创建的分支覆盖原分支。</p>
</li>
<li><p><strong>切换到先前的分支：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout -</span><br></pre></td></tr></table></figure>
<p>使用单独的短横线 <code>-</code> 作为参数，将你切换回之前所在的分支。</p>
</li>
<li><p><strong>切换到指定的提交：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout <span class="tag">&lt;<span class="name">commit_hash</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过提供提交哈希值，可以将工作目录设置为该提交的状态，进入分离头指针状态（detached HEAD）。</p>
</li>
<li><p><strong>丢弃工作目录中的更改：</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- &lt;file_path&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>--</code> 和文件路径来<strong>撤销</strong>对工作目录中某个文件所做的更改，将其恢复到最近一次提交的状态。</p>
<p>如果文件已经被添加到暂存区（Index），但你在工作目录中对其进行了修改，可以使用相同的命令来撤销暂存区中的更改，将其恢复到最近一次提交的状态。</p>
</li>
<li><p><strong>使用远程分支创建本地分支：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="tag">&lt;<span class="name">local_branch_name</span>&gt;</span> <span class="tag">&lt;<span class="name">remote_name</span>&gt;</span>/<span class="tag">&lt;<span class="name">remote_branch_name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个用法允许你使用远程分支作为起点创建一个本地分支。</p>
</li>
<li><p><strong>切换到标签（Tag）：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout <span class="tag">&lt;<span class="name">tag_name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过提供标签名称，可以将工作目录设置为标签所指向的提交状态，进入分离头指针状态（detached HEAD）。</p>
</li>
<li><p><strong>强制切换：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout -f <span class="tag">&lt;<span class="name">branch_name</span>&gt;</span>git </span><br></pre></td></tr></table></figure>
<p>这个命令将强制切换分支，即使有未保存的更改。慎用，因为未保存的更改将会丢失。</p>
</li>
<li><p><strong>检出子模块的提交：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git checkout <span class="tag">&lt;<span class="name">submodule_path</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在包含子模块的仓库中，这个命令可以用来检出子模块的提交。</p>
</li>
<li><p><strong>查看分支和提交信息：</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout</span></span><br></pre></td></tr></table></figure>
<p>不带参数的 <code>git checkout</code> 会显示当前所在的分支或提交信息。</p>
</li>
</ol>
<h4 id="GIT-MERGE-合并到当前分支"><a href="#GIT-MERGE-合并到当前分支" class="headerlink" title="GIT MERGE: 合并到当前分支"></a>GIT MERGE: 合并到当前分支</h4><h3 id="原理：dive-into-details"><a href="#原理：dive-into-details" class="headerlink" title="原理：dive into details"></a>原理：dive into details</h3><h4 id="git-folders-了解git原理的关键"><a href="#git-folders-了解git原理的关键" class="headerlink" title=".git folders: 了解git原理的关键"></a><code>.git</code> folders: 了解git原理的关键</h4><h5 id="对象数据库（Object-Database）："><a href="#对象数据库（Object-Database）：" class="headerlink" title="对象数据库（Object Database）："></a><strong>对象数据库（Object Database）</strong>：</h5><p>在.git文件夹中，有一个名为”objects”的目录，它是Git的对象数据库。Git以对象的形式存储文件和目录的快照、提交信息等。这些对象是Git中的基本数据单元。Git使用SHA-1哈希算法对这些对象进行唯一标识，并根据内容计算哈希值。</p>
<p><strong>Blob（文件快照）</strong>： Blob是Git中表示文件内容的数据对象。它仅仅存储文件内容本身，不包含文件名或路径等信息。</p>
<pre><code>1. Blob使用SHA-1哈希算法计算唯一标识，由Javascript逆向那一节我们知道，SHA-1生成一个160位的哈希值，转成16进制则为40个字符。为了管理方便，在文件系统中前两位作为`.git/objects/` 子目录的名字，后38为作为文件名字。`git cat-file -p &lt;hash value&gt;`能够将Blob文件逆向输出为文本文件。
2. 每当文件内容发生变化时，Git都会创建一个新的Blob对象，而非存储更改，保留文件历史的完整性。 Git通过SHA-1哈希值来唯一标识每个文件，如果文件内容未发生变化，Git会复用之前的数据块，从而节省存储空间。
</code></pre><p><strong>Tree（目录结构）</strong>： Tree是Git中表示目录结构的数据对象。</p>
<pre><code>1. Blob对象中只存储了文件内容，并不含该对象的文件名等信息。故GIT用树结构来解决文件名保存的问题。具体而言，类似文件树，一个树对象包含一个文件模式(在新增文件时出现的 create mode xxxx)，对象的类型（是Blob对象还是子树对象，可以用`git cat-file -t &lt;key&gt;`来查看类型），对象的SHA-1指针，最后是文件名。
2. ![](https://gcore.jsdelivr.net/gh/Molaison/IMages/20230722004544.png)![](https://gcore.jsdelivr.net/gh/Molaison/IMages/20230722004731.png)
</code></pre><p>Blob对象对应的是文件一次次不同的版本（位于不同的blob文件中）；而Tree对象对应的是一次次版本，当版本更新时，新建一个Tree并将现有Tree作为其子节点，同为子节点的还有修改后的文件的Blob对象条目。</p>
<p><strong>Commit（提交信息）</strong>： Commit是Git中表示项目版本的数据对象。它包含了提交作者、提交时间、提交信息和指向对应文件树（Tree）的哈希指针等信息。每次执行”git commit”命令时，都会生成一个新的Commit对象，记录了当前项目状态的快照，可以看做是Tree对象的一个封装。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/909968-20220427104818588-1136887141.png" alt=""><br>而对于多个提交，其格式如下：当文件内容未被修改时，复用之前的数据块。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/909968-20220427104847129-1712158832.png" alt=""></p>
<p><strong>Tag（标签）</strong>： Tag是Git中表示版本标签的数据对象，Tag对象存储在Git的对象数据库中，和其他对象（如提交对象、树对象和Blob对象）一样，以压缩形式存储在<code>.git/objects</code>目录下。它是对某个Commit的引用，用于标记特定的版本，如软件发布的稳定版本或<strong>里程碑</strong>。类似Commit，Tag对象包含了标签名、标签作者、标签信息和指向对应Commit的哈希指针。</p>
<blockquote>
<p>默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后，你必须显式地(手动)推送标签到远程服务器上。使用<code>git push origin &lt;tagname&gt;</code> 或<code>git push origin --tags</code>来完成。</p>
</blockquote>
<h5 id="分支与引用（Branches-and-References）"><a href="#分支与引用（Branches-and-References）" class="headerlink" title="分支与引用（Branches and References）"></a><strong>分支与引用（Branches and References）</strong></h5><p>在.git文件夹中，有一个名为”refs”的目录，其中包含分支和引用。分支是指向提交对象（commits）的指针，而引用是指向分支或标签（tags）的指针。这些指针的存在使得Git能够跟踪项目的不同开发分支，并快速访问最新的提交。<br>存储于<code>.git/refs/tags</code>目录中的是以标签名作为文件名而以校验值作为内容的文件。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230722094941.png" alt=""><br>Tag对象的文件结构如下：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">object &lt;commit对象的SHA-1&gt;</span><br><span class="line">type commit</span><br><span class="line">tag &lt;标签名&gt;</span><br><span class="line">tagger &lt;标签作者&gt; &lt;时间戳&gt; &lt;标签信息&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;commit对象的SHA-1&gt;</code>：这个字段存储了标签对应的提交的SHA-1哈希值，即标签所指向的提交。</li>
<li><code>type commit</code>：表示这个Tag对象是一个指向提交的标签。</li>
<li><code>&lt;标签名&gt;</code>：这个字段存储了标签的名称。</li>
<li><code>tagger &lt;标签作者&gt; &lt;时间戳&gt; &lt;标签信息&gt;</code>：这个字段包含了标签的作者信息、创建时间和标签信息。通常情况下，Git会自动记录创建标签的人和时间，除非在创建Tag时指定了自定义信息。</li>
</ul>
<p>而对于分支对象的引用， 它存储在<code>refs/heads/</code>目录下，当使用<code>feature/add-about-page</code>分支名时，会使用<code>feature</code>作为子目录，<code>add-about-page</code>作为子文件。该文件同样存储的是blob文件的校验码。<br>远程分支也采用类似操作，储存于<code>refs/remotes</code>目录下。每个远程仓库对应一个文件或目录。<br>这个目录位于<code>.git</code>目录下，是Git存储分支引用（即分支指针）的地方。每当你创建一个新的分支或切换到一个分支，Git会在<code>refs/heads/</code>目录下创建或更新相应的分支引用。</p>
<p>另一种特别的引用是<code>stash</code>，其储存于<code>refs/stash</code>中。实际上，<code>.git/refs/stash</code>文件只存储了最近一个stash的哈希值。这是因为在Git中，stash通常被存储为一个栈（stack）结构，最新的stash会覆盖之前的stash，弹出一个stash时使用上一个stash。其他stash的哈希值实际上存储在一个名为<code>.git/logs/refs/stash</code>的文件中。<code>.git/logs/refs/stash</code>文件记录了stash的历史，包含了过去每次stash的提交信息，每条记录包含了一个哈希值和相关的提交信息。这个文件允许你查看stash的历史，以及在需要时恢复特定的stash。</p>
<h5 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a><strong>索引（Index）</strong></h5><p>Git使用一个名为”index”的文件来暂存即将提交的更改。在工作目录中修改文件后，将这些更改暂存到索引中，然后通过”git commit”命令将索引中的更改提交到版本历史中。</p>
<ul>
<li>暂存区：<code>.git/index</code>文件是Git的暂存区，用于存储即将提交的文件修改信息。在进行提交前，你可以使用<code>git add</code>命令将工作目录中的文件修改添加到暂存区，<code>.git/index</code>就会记录这些文件的状态和变化。</li>
<li>跟踪差异：<code>.git/index</code>文件还用于跟踪当前工作目录和版本库之间的差异。它记录了哪些文件被修改，哪些文件被添加或删除，以便在提交时可以准确地记录这些变化。</li>
</ul>
<p>主要存储的内容有：</p>
<ul>
<li>文件信息：<code>.git/index</code>中存储了当前暂存区的文件状态，包括文件路径、文件权限、对象（blob）的SHA-1哈希值和文件大小等。</li>
<li>目录树信息：Git使用目录树来表示文件和目录的结构。<code>.git/index</code>中包含了当前版本库中的目录树信息，以便跟踪工作目录的变化。</li>
<li>其他元数据：<code>.git/index</code>文件还可能包含一些其他元数据，例如文件版本、时间戳和标记信息等。</li>
</ul>
<h5 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a><strong>配置（Configuration）</strong></h5><p>Git的配置文件存储在.git/config中，也可以在用户主目录下的.gitconfig中设置。配置文件包含有关Git仓库和全局设置的信息，例如用户名、邮箱、默认分支等。</p>
<h5 id="日志（Logs）"><a href="#日志（Logs）" class="headerlink" title="日志（Logs）"></a><strong>日志（Logs）</strong></h5><p>在.git文件夹中的”logs”目录下存储着对仓库进行操作的日志信息，如分支的提交历史和引用的更新记录。<br><code>.git/logs/HEAD</code>：<code>.git/logs/HEAD</code>文件用于记录<code>HEAD</code>引用的历史变更。这包括<code>HEAD</code>引用在不同分支或提交之间切换的历史记录，以及直接指向特定提交的情况。<br>内容通常包括一系列记录，每条记录对应一个<code>HEAD</code>引用的历史修改。每条记录可能包含以下信息：</p>
<ul>
<li><code>HEAD</code>的旧值和新值：记录<code>HEAD</code>引用在修改前后的状态，即旧的<code>HEAD</code>引用值和新的<code>HEAD</code>引用值（通常是提交的SHA-1哈希值）。</li>
<li>提交信息：通常包括引用变更的提交信息、作者和提交时间等。</li>
<li>操作者信息：记录进行<code>HEAD</code>引用修改的人员信息。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230722110637.png" alt=""></li>
</ul>
<h5 id="钩子（Hooks）"><a href="#钩子（Hooks）" class="headerlink" title="钩子（Hooks）"></a><strong>钩子（Hooks）</strong></h5><p>Git允许用户在特定的操作点上运行自定义脚本，这些脚本称为钩子。.git/hooks目录存储了这些钩子的样本文件，用户可以根据需要复制并重命名这些样本文件，以创建自己的钩子来触发特定的操作。</p>
<h5 id="配置文件（config和ignore）"><a href="#配置文件（config和ignore）" class="headerlink" title="配置文件（config和ignore）"></a><strong>配置文件（config和ignore）</strong></h5><p>.git/config和.gitignore文件分别用于存储项目特定的仓库配置和要忽略的文件列表。.gitignore文件中列出的文件和目录将不会被Git跟踪和纳入版本控制。</p>
<p>.git/config: <code>.git/config</code>文件是每个Git仓库的仓库级别配置文件。它用于存储与该仓库相关的配置信息，这些配置信息包括用户信息、远程仓库的URL、分支设置、别名、提交模板等。这些配置项仅适用于当前的Git仓库，不会影响其他仓库或全局设置。</p>
<p>.gitignore: <code>.gitignore</code>文件中的规则用于指定要忽略的文件和目录，以防止它们被Git纳入版本控制。以下是一些常见的<code>.gitignore</code>规则案例：</p>
<ol>
<li>忽略特定文件：<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">myfile.txt          <span class="meta"># 忽略名为<span class="string">&quot;myfile.txt&quot;</span>的文件</span></span><br><span class="line">*.<span class="built_in">log</span>               <span class="meta"># 忽略所有以<span class="string">&quot;.log&quot;</span>为后缀的文件</span></span><br><span class="line">secrets.txt         <span class="meta"># 忽略名为<span class="string">&quot;secrets.txt&quot;</span>的文件</span></span><br></pre></td></tr></table></figure></li>
<li>忽略特定目录：<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">build/              <span class="meta"># 忽略名为<span class="string">&quot;build&quot;</span>的目录及其所有内容</span></span><br><span class="line">output/             <span class="meta"># 忽略名为<span class="string">&quot;output&quot;</span>的目录及其所有内容</span></span><br></pre></td></tr></table></figure></li>
<li>忽略指定后缀的文件：<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">*.exe               <span class="meta"># 忽略所有以<span class="string">&quot;.exe&quot;</span>为后缀的文件</span></span><br><span class="line">*.tmp               <span class="meta"># 忽略所有以<span class="string">&quot;.tmp&quot;</span>为后缀的文件</span></span><br></pre></td></tr></table></figure></li>
<li>忽略特定文件或目录的所有内容：<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">logs/*              <span class="meta"># 忽略名为&quot;logs&quot;目录中的所有内容</span></span><br><span class="line">secret_folder/      <span class="meta"># 忽略名为&quot;secret_folder&quot;的目录及其所有内容</span></span><br></pre></td></tr></table></figure></li>
<li>使用通配符和正则表达式：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">*.log               <span class="meta"># 忽略所有以<span class="string">&quot;.log&quot;</span>为后缀的文件</span></span><br><span class="line"><span class="keyword">/build/</span>             <span class="meta"># 忽略位于仓库根目录下的名为<span class="string">&quot;build&quot;</span>的目录</span></span><br><span class="line"><span class="keyword">/docs/</span>*.pdf         <span class="meta"># 忽略位于仓库根目录下的名为<span class="string">&quot;docs&quot;</span>目录中的所有以<span class="string">&quot;.pdf&quot;</span>为后缀的文件</span></span><br></pre></td></tr></table></figure></li>
<li>忽略特定路径模式：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">**/temp.txt         <span class="meta"># 忽略任意深度下的名为<span class="string">&quot;temp.txt&quot;</span>的文件</span></span><br><span class="line">!<span class="keyword">/src/</span>temp.txt      <span class="meta"># 除了<span class="string">&quot;src&quot;</span>目录下的<span class="string">&quot;temp.txt&quot;</span>文件之外，忽略其他位置的同名文件</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol>
<li><p><strong>COMMIT_EDITMSG</strong>： <code>COMMIT_EDITMSG</code>文件是在进行提交（commit）操作时使用的文件。当你执行<code>git commit</code>命令提交代码时，Git会打开一个文本编辑器，并让你输入提交消息（commit message）。<strong>这个编辑器打开的文件就是<code>COMMIT_EDITMSG</code></strong>。你需要在其中输入一条简洁明了的提交消息，描述你所做的更改。</p>
</li>
<li><p><strong>HEAD</strong>： <code>HEAD</code>是一个特殊的引用（reference）指针，它始终指向当前所在分支的最新提交。在Git中，<code>HEAD</code>表示当前工作目录所在的位置。当你检出（checkout）不同的分支或提交时，<code>HEAD</code>引用会更新指向相应的分支或提交，从而指示当前工作目录所在的位置。在分支操作中，<code>HEAD</code>是非常关键的。</p>
</li>
<li><p><strong>ORIG_HEAD</strong>： <code>ORIG_HEAD</code>是一个自动设置的引用，它用于保存分支操作前的<code>HEAD</code>引用的值。当你执行某些具有潜在风险的分支操作，例如合并（merge）、重置（reset）、回滚（revert）等时，Git会自动设置<code>ORIG_HEAD</code>引用，以保存你执行操作前<code>HEAD</code>引用所指向的位置。这样，你可以在需要时回到操作前的状态。</p>
</li>
</ol>
<h4 id="Merge的底层逻辑-file-level"><a href="#Merge的底层逻辑-file-level" class="headerlink" title="Merge的底层逻辑: file level"></a>Merge的底层逻辑: file level</h4><ol>
<li><strong>查找共同祖先</strong>： 在进行合并之前，Git首先查找两个分支的共同祖先（合并基础），这个共同祖先是它们最近的共同提交。通过找到共同祖先，Git可以确定要合并的范围，并知道各个分支的修改是从哪个点开始的。</li>
<li><strong>比较修改</strong>： Git比较共同祖先和要合并的两个分支之间的差异，确定哪些内容在每个分支上进行了修改。对于BLOB对象，Git会比较文件内容，找出每个分支上的修改。</li>
<li><strong>合并修改</strong>： 对于BLOB对象，合并修改意味着将两个分支对同一文件所做的修改合并到一起。如果两个分支对文件的修改没有冲突，Git会自动合并这些修改，生成一个新的文件内容，作为合并结果。</li>
<li><strong>解决冲突</strong>： 如果两个分支对同一文件的修改发生冲突，即它们修改了相同的内容，并且没有共同祖先的提交来指导合并，那么就会发生合并冲突。对于BLOB对象的合并冲突，通常是Git无法自动解决的，需要开发者手动解决冲突。</li>
<li><strong>生成新的BLOB对象</strong>： 在合并成功或者手动解决冲突后，Git会生成一个新的BLOB对象，其中包含了合并后的文件内容。这个新的BLOB对象将作为合并结果，用于创建一个新的合并提交。</li>
</ol>
<p>总结一下：git使用的是三路合并(Three-way merge)的方法。我们首先要找到共同祖先，即修改前的版本作为基准。相对于基准，分别逐行进行比对，只要不是同时对一行文本进行修改，git会自动接受修改。</p>
<blockquote>
<p>多个公共祖先？<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230722134518.png" alt=""></p>
</blockquote>
<p>merge <code>X&#39;&#39; Y&#39;</code>和<code>X&#39; Y&#39;&#39;</code>的时候发现有两个节点都符合<code>最近的公共祖先</code>，即：</p>
<ul>
<li><code>X&#39; Y</code></li>
<li><code>X Y&#39;</code><br>我们称这种情况为：<code>Criss-cross-merge</code>，这时就需要用到<code>Recursive three-way merge</code>算法，具体步骤如下：</li>
</ul>
<ol>
<li>先把候选的两个<code>最近的公共祖先</code>递归调用merge，生成成一个虚拟的节点。</li>
<li>然后让这个虚拟节点作为<code>Base</code>进行合并。</li>
</ol>
]]></content>
      <categories>
        <category>skill learning</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象：Digging into details</title>
    <url>/2023/07/23/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9ADigging-into-details/</url>
    <content><![CDATA[<p>在Python编程语言中，所有的数据类型（包括基本数据类型和自定义数据类型）、函数、模块、类、甚至模块、包等都被视为对象。</p>
<p>在一些其他编程语言中，基本数据类型（如整数、浮点数、布尔值等）和复合数据类型（如数组、结构体等）与对象有所区别，而在Python中，这种区别消失了。无论是简单的整数还是复杂的类对象，它们在Python中都是对象。</p>
<h3 id="Meta-amp-Base-Type与Object详解"><a href="#Meta-amp-Base-Type与Object详解" class="headerlink" title="Meta&amp;Base: Type与Object详解"></a>Meta&amp;Base: Type与Object详解</h3><p>由引言我们已经知道，Python中一切都是对象，而对象又分为两类：</p>
<ol>
<li>类型对象（Type Objects）：<ul>
<li>“类型对象”通常指的是用来创建其他对象的对象，也就是类（class）。在Python中，类本身也是对象，由元类<code>type</code>来定义。类是用来实例化创建其他对象的模板，它定义了对象的属性和方法。</li>
<li>所有的内置数据类型（如<code>int</code>、<code>str</code>、<code>list</code>等）和用户自定义的类都属于类型对象。这些类型对象定义了一类对象所具有的共同特征和行为。</li>
</ul>
</li>
<li>非类型对象（Non-Type Objects）：<ul>
<li>“非类型对象”指的是类实例化后得到的对象，也就是我们常见的数据类型和对象实例。这些对象是类的实例，它们继承了所属类的属性和方法，并具有自己的特定值和状态。</li>
<li>除了类实例外，Python中的一些原始数据类型（如整数、浮点数、字符串等）也属于非类型对象。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类型对象示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:   <span class="comment"># 这是一个类，是类型对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非类型对象示例</span></span><br><span class="line">obj1 = MyClass()  <span class="comment"># 创建MyClass的实例，是非类型对象</span></span><br><span class="line">obj2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment"># 创建一个列表，是非类型对象</span></span><br><span class="line">x = <span class="number">10</span>            <span class="comment"># x是整数，是非类型对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>然而，“类型”到底指什么？<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/obj.png" alt=""></p>
<p><caption>object 和 type 关系图 （实线表继承关系，虚线表实例关系 Shalabh Chaturvedi）</caption></p>
<ol>
<li><code>object</code>：<ul>
<li><code>object</code>是Python中所有类的基类(baseclass)。在Python中，一切皆对象，所有的数据类型和类都是<code>object</code>的子类，包括内置数据类型（如<code>int</code>、<code>str</code>、<code>list</code>等）和用户自定义的类。</li>
<li><code>object</code>类提供了一些通用的方法，例如<code>__init__()</code>、<code>__str__()</code>、<code>__repr__()</code>等，这些方法在所有类中都是可用的，因为所有类都继承自<code>object</code>，即使自定义类没有显式地继承任何其他类，它也隐式地继承了<code>object</code>类。</li>
</ul>
</li>
<li><code>type</code>：<ul>
<li><code>type</code>是一个元类（metaclass），它用于创建所有类的类（class of classes）。在Python中，类本身也是一个对象，由元类来定义类的行为。而<code>type</code>就是Python内置的元类。</li>
<li>在一般情况下，我们使用<code>type()</code>函数来获取对象的类型（类）。例如，<code>type(5)</code>将返回<code>int</code>，<code>type(&#39;hello&#39;)</code>将返回<code>str</code>。</li>
<li>此外，我们还可以通过<code>type()</code>函数来动态地创建新的类。它接受三个参数：类名、基类元组和包含属性和方法的字典。通过使用<code>type</code>，我们可以在运行时动态地创建新的类，这种能力被称为”metaclass programming”。</li>
</ul>
</li>
</ol>
<p>故而，一个最基本的类，要由两个组分组成。1）从object那继承类的基本特征与方法；2）从type那实例化成为类，这也是type被称为元类的原因。只要是类，就必然是元类的实例，就必然是类型对象，包含obejct；只要是类，就必然继承自object，包括type。</p>
<h3 id="Attrs-amp-Methods-属性与方法"><a href="#Attrs-amp-Methods-属性与方法" class="headerlink" title="Attrs&amp;Methods: 属性与方法"></a>Attrs&amp;Methods: 属性与方法</h3><p>类有两个主要成分，其一是方法(可理解为常说的函数，方法是与对象相关联的函数。) ，其二则是属性。</p>
<h4 id="类方法、实例方法、静态方法"><a href="#类方法、实例方法、静态方法" class="headerlink" title="类方法、实例方法、静态方法"></a>类方法、实例方法、静态方法</h4><p>类方法、实例方法和静态方法是三种不同类型的方法，它们具有以下区别：</p>
<ol>
<li><p>实例方法（Instance Method）：</p>
<ul>
<li>定义方式：实例方法是最常见的方法类型，定义时必须包含一个<code>self</code>参数，代表类的==实例本身==。</li>
<li>调用方式：实例方法<strong>只能通过类的实例来调用</strong>，而不能通过类名直接调用。</li>
<li>访问权限：实例方法可以访问和修改类的实例属性以及调用其他实例方法。</li>
<li>用途：实例方法通常用于操作和处理类的实例，以及实现类的特定行为。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x + x</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">result = obj.instance_method(<span class="number">5</span>)   <span class="comment"># 通过实例调用实例方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类方法（Class Method）：</p>
<ul>
<li>定义方式：类方法使用<code>@classmethod</code>装饰器定义，第一个参数通常为<code>cls</code>，表示类本身。</li>
<li>调用方式：类方法可以通过类名直接调用，也可以通过类的实例调用。</li>
<li>访问权限：类方法可以访问和修改类的属性，但不能访问实例的属性，也不能调用实例方法。</li>
<li>用途：类方法通常用于处理和修改类级别的属性，执行与类相关的操作。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_variable = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls, x</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.class_variable + x</span><br><span class="line"></span><br><span class="line">result = MyClass.class_method(<span class="number">5</span>)   <span class="comment"># 通过类名直接调用类方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>静态方法（Static Method）：</p>
<ul>
<li>定义方式：静态方法使用<code>@staticmethod</code>装饰器定义，没有特殊的参数，与类和实例无关。</li>
<li>调用方式：静态方法可以通过类名直接调用，也可以通过类的实例调用。仅仅能通过”\<classname\>.method()”的方法进行访问。</li>
<li>访问权限：静态方法不能访问类和实例的属性，它们与类和实例无关。</li>
<li>用途：静态方法通常用于实现与类和实例无关的一般性功能，类似于普通函数，但是定义在类中，仅为了方便封装。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">result = MyClass.static_method(<span class="number">3</span>)   <span class="comment"># 通过类名直接调用静态方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>总结区别：</p>
<ul>
<li>实例方法是与类的实例绑定的，需要通过类的实例来调用，可以访问实例属性和调用其他实例方法。</li>
<li>类方法是与类绑定的，可以通过类名直接调用或通过类的实例调用，可以访问类的属性，但不能访问实例的属性。</li>
<li>静态方法与类和实例无关，可以通过类名直接调用或通过类的实例调用，不能访问类和实例的属性。</li>
</ul>
<p>对象中的函数被称为 method 方法类型，普通函数类型为 function。普通函数会将<code>self</code>作为一个普通形参而非对象来处理，因此直接使用function来更新method会出现错误。如下例子：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>():</span><br><span class="line">    __class_version = <span class="string">&quot;v1.0&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My id is %d&quot;</span> % self.age)</span><br><span class="line"></span><br><span class="line">worker0 = Employee(<span class="number">0</span>, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">worker0.age = <span class="number">25</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_age</span>(<span class="params">self</span>):  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My id is %d&quot;</span> % self.age)</span><br><span class="line">worker0.say_age = say_age  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(worker0.say_age))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(say_age))  </span><br><span class="line">worker0.say_age()</span><br></pre></td></tr></table></figure><br>会出现如下错误，因为<code>say_age</code>是一个<code>function</code>而非<code>method</code>，无法识别<code>self</code>。<br><img src="https://gcore.jsdelivr.net/gh/Molaison/IMages/20230723210559.png" alt=""><br>正确的做法应当是利用<code>types</code>库中的<code>MethodType</code>函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType  </span><br><span class="line">worker0.say_age = MethodType(say_age, worker0)</span><br></pre></td></tr></table></figure></p>
<h4 id="类属性-amp-对象属性"><a href="#类属性-amp-对象属性" class="headerlink" title="类属性&amp;对象属性"></a>类属性&amp;对象属性</h4><ol>
<li><p>定义位置：</p>
<ul>
<li>类属性：类属性是定义在类中，类的所有实例共享同一个类属性。它们属于类本身而不是实例。</li>
<li>对象属性：对象属性是定义在类的方法中或在 <code>__init__</code> 构造方法中，每个实例都有自己的一份对象属性。它们属于类的每个实例。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_attribute = <span class="string">&quot;This is a class attribute.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.instance_attribute = value</span><br><span class="line"></span><br><span class="line">obj1 = MyClass(<span class="number">42</span>)</span><br><span class="line">obj2 = MyClass(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问方式：</p>
<ul>
<li>类属性：可以通过类名直接访问类属性，也可以通过实例对象访问。<strong>当通过实例对象访问类属性时，如果实例对象中没有同名的对象属性，会自动访问类属性。</strong></li>
<li>对象属性：只能通过实例对象访问对象属性，每个实例都有自己的一份对象属性，彼此之间不共享。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问类属性</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attribute)  <span class="comment"># 输出: This is a class attribute.</span></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attribute)      <span class="comment"># 输出: This is a class attribute.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问对象属性</span></span><br><span class="line"><span class="built_in">print</span>(obj1.instance_attribute)   <span class="comment"># 输出: 42</span></span><br><span class="line"><span class="built_in">print</span>(obj2.instance_attribute)   <span class="comment"># 输出: 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>更新方式：<ul>
<li>类属性：可以通过类名直接更新类属性的值，更新后所有实例共享更新后的值。</li>
<li>对象属性：只能通过实例对象来更新对象属性的值，更新只影响当前实例本身，不会影响其他实例。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新类属性</span></span><br><span class="line">MyClass.class_attribute = <span class="string">&quot;Updated class attribute.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attribute)  <span class="comment"># 输出: Updated class attribute.</span></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attribute)      <span class="comment"># 输出: Updated class attribute.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新对象属性</span></span><br><span class="line">obj1.instance_attribute = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(obj1.instance_attribute)   <span class="comment"># 输出: 50</span></span><br><span class="line"><span class="built_in">print</span>(obj2.instance_attribute)   <span class="comment"># 输出: 100</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>还有一点需要注意的是，类属性在创建实例时并不会被单独创建，都是引用的类的属性。但通过实例来改变类属性时，我们并非修改了类的属性，而是将其拷贝了一份并进行修改，与类的属性解除了绑定，再对类属性做修改将不再影响到这一实例的同名属性值。</p>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>Python类中的私有属性严格来讲并不是私有属性，可以说是只防君子，不防小人。同样的，既有类的私有属性也有实例的私有属性：</p>
<ol>
<li>类的私有属性：类的私有属性是在类定义中使用双下划线 <code>__</code> 开头的属性，它们通常被称为”名称修饰”（Name Mangling），并且在类外部无法直接访问。Python 会将属性名转换为 <code>_ClassName__attribute</code> 的形式，其中 <code>ClassName</code> 是实例所属的类的名称，这样就使属性在外部变得不容易访问。虽然属性名称发生了变化，但实际上它不是严格意义上的”私有属性”，因为在某些情况下，仍然可以通过特定的方式访问到。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">	__private_attribute = <span class="string">&quot;I am a private attribute.&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="comment"># 无法直接访问类的私有属性</span></span><br><span class="line"><span class="built_in">print</span>(obj.__private_attribute)  </span><br><span class="line"><span class="comment"># 报错：&#x27;MyClass&#x27; object has no attribute &#x27;__private_attribute&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(obj._MyClass__private_attribute)  </span><br><span class="line"><span class="comment"># 输出: I am a private attribute.</span></span><br></pre></td></tr></table></figure></li>
<li>实例的私有属性也是一样：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_attribute = <span class="string">&quot;I am a private attribute.&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="comment"># 实际上是访问了名称修饰后的属性</span></span><br><span class="line"><span class="built_in">print</span>(obj._MyClass__private_attribute)  <span class="comment"># 输出: I am a private attribute.</span></span><br></pre></td></tr></table></figure>
在上面的示例中，<code>__private_attribute</code> 是实例 <code>obj</code> 的私有属性。虽然我们在类的外部无法直接访问它，但通过名称修饰后的 <code>_MyClass__private_attribute</code>，我们仍然可以在一定条件下访问到它。</li>
</ol>
<p>毫无疑问，我们虽然能访问并修改私有属性，但这会带来隐患（可能对一个只读属性赋值，也可以动态绑定一个私有属性）。标准的访问方式应该是通过类方法进行（cls.__private_variable）。</p>
<p>更加靠谱的方法是将实例方法属性化。以下内容来自<a href="https://pythonhowto.readthedocs.io/zh_CN/latest/decorator.html#property-decorator">Python 从入门到深入 1.0 文档</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__arg = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getarg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__arg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setarg</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__arg = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delarg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__arg</span><br><span class="line"></span><br><span class="line">    arg = <span class="built_in">property</span>(fget=getarg, fset=setarg, fdel=delarg, doc=<span class="string">&quot;&#x27;arg&#x27; property.&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.arg = <span class="number">10</span>        <span class="comment"># 调用 setarg</span></span><br><span class="line"><span class="built_in">print</span>(c.arg)      <span class="comment"># 调用 getarg</span></span><br><span class="line"></span><br><span class="line">c.setarg(<span class="number">20</span>)      <span class="comment"># 调用 setarg</span></span><br><span class="line"><span class="built_in">print</span>(c.getarg()) <span class="comment"># 调用 getarg</span></span><br><span class="line"><span class="keyword">del</span> c.arg         <span class="comment"># 调用 delarg</span></span><br></pre></td></tr></table></figure><br><code>property</code>函数赋值的变量即为属性（<code>&#123;obj&#125;.&#123;varname&#125;</code>）。或者使用装饰器实现：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__arg = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">argopt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @argopt.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">argopt</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__arg = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @argopt.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">argopt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__arg</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.argopt = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(c.argopt)</span><br><span class="line"><span class="keyword">del</span> c.argopt</span><br></pre></td></tr></table></figure><br>需要注意的是并没有<code>@&#123;&#125;.getter</code>，而是直接<code>@property</code>；此外，要访问该属性，我们要用<code>@property</code>装饰的那个函数的名称(这里为<code>argopt</code>)，通过调用属性的方式调用方法，就是实例方法的属性化；且大多数情况下需要用到<code>@property</code>时是希望利用其readonly属性，故并不是每一个都需要设置<code>setter&amp;deleter</code>。</p>
<h4 id="基类属性"><a href="#基类属性" class="headerlink" title="基类属性"></a>基类属性</h4><ul>
<li><code>__slots__</code> 属性是一个包含属性名称的元组，指定了允许的属性列表。当一个类定义了 <code>__slots__</code> 属性后，它的实例对象只能拥有 <code>__slots__</code> 中列出的属性，并且不能再动态添加其他属性。<ol>
<li><code>__slots__</code> 属性只对当前类的实例对象有效，对于继承的子类不起作用。</li>
<li><code>__slots__</code> 中定义的属性名不包括继承的父类属性，即继承的属性不受限制。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;address&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = Child()</span><br><span class="line">obj.name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">obj.age = <span class="number">30</span></span><br><span class="line">obj.gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">obj.address = <span class="string">&quot;123 Main St.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类 Child 的实例对象只能拥有子类定义的属性，不会继承父类 Parent 的 __slots__</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)     <span class="comment"># 输出: Alice</span></span><br><span class="line"><span class="built_in">print</span>(obj.age)      <span class="comment"># 输出: 30</span></span><br><span class="line"><span class="built_in">print</span>(obj.gender)   <span class="comment"># 输出: female</span></span><br><span class="line"><span class="built_in">print</span>(obj.address)  <span class="comment"># 输出: 123 Main St.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法添加其他属性，因为 __slots__ 限制了对象的属性</span></span><br><span class="line"><span class="comment"># obj.email = &quot;alice@example.com&quot;  # 报错：&#x27;Child&#x27; object has no attribute &#x27;email&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><code>__dir__</code> 是一个特殊方法（也称为魔法方法），用于返回对象的属性列表。当调用内置函数 <code>dir(obj)</code> 时，实际上会调用 <code>obj.__dir__()</code> 方法来获取对象的属性列表。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">        self.age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dir__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 自定义 __dir__ 方法返回属性列表</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 dir(obj) 实际上调用了 obj.__dir__() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(obj))</span><br></pre></td></tr></table></figure></li>
<li><code>__doc__</code> 是一个特殊属性（也称为魔法属性），用于存储类或函数的文档字符串（docstring）。当你定义类、函数或模块时，可以在其开头的第一个字符串中编写文档字符串。这个字符串会被Python 解释器识别为==文档字符串==，并将其存储在对象的 <code>__doc__</code> 属性中。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This function calculates the sum of two numbers.</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        a (int): The first number.</span></span><br><span class="line"><span class="string">        b (int): The second number.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: The sum of the two numbers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__doc__)</span><br><span class="line"><span class="comment"># This function calculates the sum of two numbers.  </span></span><br><span class="line"><span class="comment"># Parameters:  </span></span><br><span class="line"><span class="comment"># a (int): The first number.  </span></span><br><span class="line"><span class="comment"># b (int): The second number.  </span></span><br><span class="line"><span class="comment"># Returns:  </span></span><br><span class="line"><span class="comment"># int: The sum of the two numbers.</span></span><br></pre></td></tr></table></figure></li>
<li><code>__str__</code> 用于定义对象的字符串表示形式。当一个对象被传递给内置的 <code>str()</code> 函数时，Python 解释器会尝试调用该对象的 <code>__str__()</code> 方法，以获取对象的字符串表示形式。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Person: <span class="subst">&#123;self.name&#125;</span>, Age: <span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 str(person) 实际上调用了 person.__str__() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(person))</span><br><span class="line"><span class="comment"># Person: Alice, Age: 30</span></span><br><span class="line"><span class="comment"># 为对象的 &quot;informal&quot; 字符串表示形式，通常用于提供对象的可读性好的字符串形式。</span></span><br></pre></td></tr></table></figure></li>
<li><code>__repr__</code> 用于定义对象的 “official” 字符串表示形式。当一个对象被传递给内置的 <code>repr()</code> 函数时，Python 解释器会尝试调用该对象的 <code>__repr__()</code> 方法，以获取对象的官方字符串表示形式。如果一个对象没有定义 <code>__repr__</code> 方法，Python 解释器会尝试调用 <code>__str__</code> 方法。如果 <code>__str__</code> 方法也没有定义，Python 将使用默认的 <code>__repr__</code> 方法，==其结果是对象的内存地址表示==。<ul>
<li>如果一个对象同时定义了 <code>__repr__</code> 和 <code>__str__</code> 方法，那么在普通上下文中，<code>__str__</code> 方法会优先于 <code>__repr__</code> 方法被调用。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(x=<span class="subst">&#123;self.x&#125;</span>, y=<span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">point = Point(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 repr(point) 实际上调用了 point.__repr__() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(point))</span><br><span class="line"><span class="comment"># Point(x=3, y=5)</span></span><br><span class="line"><span class="comment"># 上为官方表达，供调试时查看对象详细信息用</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__call__</code>用于使对象可以像函数一样被调用。如果一个对象定义了 <code>__call__</code> 方法，那么该对象可以被当作函数一样调用，就像调用普通函数一样。(如一个神经网络就会定义一个<code>__call__</code>方法，以前向运算产生输出值)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base</span>):</span><br><span class="line">        self.base = base</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base + x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Adder 实例</span></span><br><span class="line">adder = Adder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 Adder 实例，实际上调用了 adder.__call__(5) 方法</span></span><br><span class="line">result = adder(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 15</span></span><br></pre></td></tr></table></figure></li>
<li><code>__delattr__</code>, <code>__setattr__</code>, 和 <code>__getattribute__</code> 分别用于自定义对象属性的设置、访问和删除行为。它们提供了对对象属性的高级控制。Python 提供了三个内置方法 getattr()，setattr() 和 hasattr()，它们均是基于类的属性方法来实现的。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.hello = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;delattr %s&quot;</span> % name)</span><br><span class="line">        <span class="built_in">super</span>().__delattr__(name)       <span class="comment"># 调用 object 的 __delattr__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;setattr %s&quot;</span> % attr)</span><br><span class="line">        <span class="built_in">super</span>().__setattr__(attr, value)<span class="comment"># 调用 object 的 __setattr__</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="keyword">del</span> c.hello      <span class="comment"># 调用类对象的 __delattr__</span></span><br><span class="line"><span class="built_in">print</span>(c.hello)   <span class="comment"># 报错 hello 属性不存在</span></span><br><span class="line"></span><br><span class="line">c.newarg = <span class="string">&quot;100&quot;</span> <span class="comment"># 调用类对象的 __setattr__</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">delattr</span> hello</span><br><span class="line"><span class="built_in">setattr</span> newarg</span><br></pre></td></tr></table></figure>
无论属性是否存在均会调用自定义的 <strong>getattribute</strong> 方法。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.hello = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;getattribute %s&quot;</span> % name)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getattribute__(name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(C().hello)</span><br><span class="line"><span class="built_in">print</span>(C().ARG)  <span class="comment"># 报错没有 ARG 属性</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">getattribute hello</span><br><span class="line">getattribute ARG</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>basic knowledge</category>
      </categories>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
</search>
